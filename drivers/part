./hid/hid-prodikeys.c:643:	strncpy(card->driver, shortname, sizeof(card->driver));
./hid/hid-prodikeys.c:644:	strncpy(card->shortname, shortname, sizeof(card->shortname));
./hid/hid-prodikeys.c:645:	strncpy(card->longname, longname, sizeof(card->longname));
./hid/hid-prodikeys.c:648:	err = snd_rawmidi_new(card, card->shortname, 0,
./hid/hid-prodikeys.c:656:	strncpy(rwmidi->name, card->shortname, sizeof(rwmidi->name));
./platform/x86/thinkpad_acpi.c:7305:	if (alsa_card && alsa_card->private_data) {
./platform/x86/thinkpad_acpi.c:7306:		d = alsa_card->private_data;
./platform/x86/thinkpad_acpi.c:7443:	BUG_ON(!card->private_data);
./platform/x86/thinkpad_acpi.c:7444:	data = card->private_data;
./platform/x86/thinkpad_acpi.c:7447:	strlcpy(card->driver, TPACPI_ALSA_DRVNAME,
./platform/x86/thinkpad_acpi.c:7448:		sizeof(card->driver));
./platform/x86/thinkpad_acpi.c:7449:	strlcpy(card->shortname, TPACPI_ALSA_SHRTNAME,
./platform/x86/thinkpad_acpi.c:7450:		sizeof(card->shortname));
./platform/x86/thinkpad_acpi.c:7451:	snprintf(card->mixername, sizeof(card->mixername), "ThinkPad EC %s",
./platform/x86/thinkpad_acpi.c:7454:	snprintf(card->longname, sizeof(card->longname),
./platform/x86/thinkpad_acpi.c:7455:		 "%s at EC reg 0x%02x, fw %s", card->shortname, TP_EC_AUDIO,
./s390/crypto/ap_bus.c:702:			 &to_ap_queue(dev)->card->queues);
./s390/crypto/ap_queue.c:269:		if (aq->queue_count < aq->card->queue_depth) {
./s390/crypto/ap_queue.c:671:	atomic_inc(&aq->card->total_request_count);
./s390/crypto/zcrypt_cex4.c:199:	if (ap_test_bit(&aq->card->functions, AP_FUNC_ACCEL)) {
./s390/crypto/zcrypt_cex4.c:205:	} else if (ap_test_bit(&aq->card->functions, AP_FUNC_COPRO)) {
./s390/crypto/zcrypt_cex4.c:211:	} else if (ap_test_bit(&aq->card->functions, AP_FUNC_EP11)) {
./s390/crypto/zcrypt_card.c:81:	id = zc->card->id;
./s390/crypto/zcrypt_card.c:154:	rc = sysfs_create_group(&zc->card->ap_dev.device.kobj,
./s390/crypto/zcrypt_card.c:165:	ZCRYPT_DBF(DBF_INFO, "card=%02x register online=1\n", zc->card->id);
./s390/crypto/zcrypt_card.c:179:	ZCRYPT_DBF(DBF_INFO, "card=%02x unregister\n", zc->card->id);
./s390/crypto/zcrypt_card.c:184:	sysfs_remove_group(&zc->card->ap_dev.device.kobj,
./s390/crypto/zcrypt_msgtype50.c:315:		   (zq->zcard->max_mod_size == CEX3A_MAX_MOD_SIZE)) {
./s390/crypto/zcrypt_msgtype50.c:377:	if (zq->zcard->user_space_type == ZCRYPT_CEX2A)
./s390/crypto/zcrypt_msgtype50.c:470:	if (zq->zcard->user_space_type == ZCRYPT_CEX2A)
./s390/crypto/zcrypt_msgtype50.c:516:	if (zq->zcard->user_space_type == ZCRYPT_CEX2A)
./s390/crypto/zcrypt_api.c:207:		return atomic_read(&zc->card->total_request_count) >
./s390/crypto/zcrypt_api.c:208:			atomic_read(&pref_zc->card->total_request_count);
./s390/crypto/zcrypt_api.c:260:		if (!zc->online || !(zc->card->functions & 0x18000000))
./s390/crypto/zcrypt_api.c:334:		if (!zc->online || !(zc->card->functions & 0x18000000))
./s390/crypto/zcrypt_api.c:398:		if (!zc->online || !(zc->card->functions & 0x10000000))
./s390/crypto/zcrypt_api.c:402:		    xcRB->user_defined != zc->card->id)
./s390/crypto/zcrypt_api.c:516:		if (!zc->online || !(zc->card->functions & 0x04000000))
./s390/crypto/zcrypt_api.c:520:		    !is_desired_ep11_card(zc->card->id, target_num, targets))
./s390/crypto/zcrypt_api.c:586:		if (!zc->online || !(zc->card->functions & 0x10000000))
./s390/crypto/zcrypt_api.c:636:			stat->hwtype = zc->card->ap_dev.device_type;
./s390/crypto/zcrypt_api.c:637:			stat->functions = zc->card->functions >> 26;
./s390/crypto/zcrypt_api.c:764:		if (zc->card->id != type)
./s390/crypto/zcrypt_queue.c:162:	zc = zq->queue->card->private;
./s390/crypto/zcrypt_msgtype6.c:654:			zq->zcard->min_mod_size =
./s390/crypto/zcrypt_msgtype6.c:794:			if (zq->zcard->max_exp_bit_length <= 17) {
./s390/crypto/zcrypt_msgtype6.c:795:				zq->zcard->max_exp_bit_length = 17;
./s390/net/qeth_l2_main.c:45:		if (card->dev == dev) {
./s390/net/qeth_l2_main.c:69:			ndev = card->dev;
./s390/net/qeth_l2_main.c:138:		card->info.mac_bits |= QETH_LAYER2_MAC_REGISTERED;
./s390/net/qeth_l2_main.c:139:		memcpy(card->dev->dev_addr, mac, OSA_ADDR_LEN);
./s390/net/qeth_l2_main.c:140:		dev_info(&card->gdev->dev,
./s390/net/qeth_l2_main.c:142:			card->dev->dev_addr, card->dev->name);
./s390/net/qeth_l2_main.c:144:		card->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;
./s390/net/qeth_l2_main.c:147:			dev_warn(&card->gdev->dev,
./s390/net/qeth_l2_main.c:151:			dev_warn(&card->gdev->dev,
./s390/net/qeth_l2_main.c:164:	if (!(card->info.mac_bits & QETH_LAYER2_MAC_REGISTERED))
./s390/net/qeth_l2_main.c:168:		card->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;
./s390/net/qeth_l2_main.c:226:	spin_lock_bh(&card->mclock);
./s390/net/qeth_l2_main.c:227:	hash_for_each_safe(card->mac_htable, i, tmp, mac, hnode) {
./s390/net/qeth_l2_main.c:231:	spin_unlock_bh(&card->mclock);
./s390/net/qeth_l2_main.c:236:	if (card->info.type == QETH_CARD_TYPE_OSN)
./s390/net/qeth_l2_main.c:258:	if (card->options.performance_stats)
./s390/net/qeth_l2_main.c:259:		card->perf_stats.tx_csum++;
./s390/net/qeth_l2_main.c:325:	spin_lock_bh(&card->vlanlock);
./s390/net/qeth_l2_main.c:326:	list_for_each_entry(id, &card->vid_list, list) {
./s390/net/qeth_l2_main.c:329:	spin_unlock_bh(&card->vlanlock);
./s390/net/qeth_l2_main.c:342:	if (card->info.type == QETH_CARD_TYPE_OSM) {
./s390/net/qeth_l2_main.c:358:		spin_lock_bh(&card->vlanlock);
./s390/net/qeth_l2_main.c:359:		list_add_tail(&id->list, &card->vid_list);
./s390/net/qeth_l2_main.c:360:		spin_unlock_bh(&card->vlanlock);
./s390/net/qeth_l2_main.c:375:	if (card->info.type == QETH_CARD_TYPE_OSM) {
./s390/net/qeth_l2_main.c:383:	spin_lock_bh(&card->vlanlock);
./s390/net/qeth_l2_main.c:384:	list_for_each_entry(id, &card->vid_list, list) {
./s390/net/qeth_l2_main.c:391:	spin_unlock_bh(&card->vlanlock);
./s390/net/qeth_l2_main.c:396:	qeth_l2_set_rx_mode(card->dev);
./s390/net/qeth_l2_main.c:406:	if (card->read.state == CH_STATE_UP &&
./s390/net/qeth_l2_main.c:407:	    card->write.state == CH_STATE_UP &&
./s390/net/qeth_l2_main.c:408:	    (card->state == CARD_STATE_UP)) {
./s390/net/qeth_l2_main.c:410:		    card->info.type != QETH_CARD_TYPE_OSN) {
./s390/net/qeth_l2_main.c:411:			qeth_l2_stop(card->dev);
./s390/net/qeth_l2_main.c:414:			dev_close(card->dev);
./s390/net/qeth_l2_main.c:417:		card->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;
./s390/net/qeth_l2_main.c:418:		card->state = CARD_STATE_SOFTSETUP;
./s390/net/qeth_l2_main.c:420:	if (card->state == CARD_STATE_SOFTSETUP) {
./s390/net/qeth_l2_main.c:423:		card->state = CARD_STATE_HARDSETUP;
./s390/net/qeth_l2_main.c:425:	if (card->state == CARD_STATE_HARDSETUP) {
./s390/net/qeth_l2_main.c:429:		card->state = CARD_STATE_DOWN;
./s390/net/qeth_l2_main.c:431:	if (card->state == CARD_STATE_DOWN) {
./s390/net/qeth_l2_main.c:432:		qeth_clear_cmd_buffers(&card->read);
./s390/net/qeth_l2_main.c:433:		qeth_clear_cmd_buffers(&card->write);
./s390/net/qeth_l2_main.c:449:			&card->qdio.in_q->bufs[card->rx.b_index],
./s390/net/qeth_l2_main.c:450:			&card->rx.b_element, &card->rx.e_offset, &hdr);
./s390/net/qeth_l2_main.c:455:		skb->dev = card->dev;
./s390/net/qeth_l2_main.c:460:			if ((card->dev->features & NETIF_F_RXCSUM)
./s390/net/qeth_l2_main.c:470:				*((__u32 *)skb->cb) = ++card->seqno.pkt_seqno;
./s390/net/qeth_l2_main.c:472:			napi_gro_receive(&card->napi, skb);
./s390/net/qeth_l2_main.c:475:			if (card->info.type == QETH_CARD_TYPE_OSN) {
./s390/net/qeth_l2_main.c:480:				card->osn_info.data_cb(skb);
./s390/net/qeth_l2_main.c:492:		card->stats.rx_packets++;
./s390/net/qeth_l2_main.c:493:		card->stats.rx_bytes += len;
./s390/net/qeth_l2_main.c:516:	if (card->info.type == QETH_CARD_TYPE_IQD ||
./s390/net/qeth_l2_main.c:517:	    card->info.type == QETH_CARD_TYPE_OSM ||
./s390/net/qeth_l2_main.c:518:	    card->info.type == QETH_CARD_TYPE_OSX ||
./s390/net/qeth_l2_main.c:519:	    card->info.guestlan) {
./s390/net/qeth_l2_main.c:528:		eth_random_addr(card->dev->dev_addr);
./s390/net/qeth_l2_main.c:529:		memcpy(card->dev->dev_addr, vendor_pre, 3);
./s390/net/qeth_l2_main.c:532:	QETH_DBF_HEX(SETUP, 2, card->dev->dev_addr, card->dev->addr_len);
./s390/net/qeth_l2_main.c:549:	if (card->info.type == QETH_CARD_TYPE_OSN ||
./s390/net/qeth_l2_main.c:550:	    card->info.type == QETH_CARD_TYPE_OSM ||
./s390/net/qeth_l2_main.c:551:	    card->info.type == QETH_CARD_TYPE_OSX) {
./s390/net/qeth_l2_main.c:560:	rc = qeth_l2_send_delmac(card, &card->dev->dev_addr[0]);
./s390/net/qeth_l2_main.c:568:	struct net_device *dev = card->dev;
./s390/net/qeth_l2_main.c:575:	if (!card->options.sbp.reflect_promisc)
./s390/net/qeth_l2_main.c:579:	if (promisc_mode == card->info.promisc_mode)
./s390/net/qeth_l2_main.c:583:		if (card->options.sbp.reflect_promisc_primary)
./s390/net/qeth_l2_main.c:594:		card->options.sbp.role = role;
./s390/net/qeth_l2_main.c:595:		card->info.promisc_mode = promisc_mode;
./s390/net/qeth_l2_main.c:609:	hash_for_each_possible(card->mac_htable, mac, hnode, mac_hash) {
./s390/net/qeth_l2_main.c:626:	hash_add(card->mac_htable, &mac->hnode, mac_hash);
./s390/net/qeth_l2_main.c:638:	if (card->info.type == QETH_CARD_TYPE_OSN)
./s390/net/qeth_l2_main.c:643:	    (card->state != CARD_STATE_UP))
./s390/net/qeth_l2_main.c:646:	spin_lock_bh(&card->mclock);
./s390/net/qeth_l2_main.c:654:	hash_for_each_safe(card->mac_htable, i, tmp, mac, hnode) {
./s390/net/qeth_l2_main.c:671:	spin_unlock_bh(&card->mclock);
./s390/net/qeth_l2_main.c:721:		if (card->options.performance_stats) {
./s390/net/qeth_l2_main.c:723:				card->perf_stats.tx_linfail++;
./s390/net/qeth_l2_main.c:725:				card->perf_stats.tx_lin++;
./s390/net/qeth_l2_main.c:759:		if (card->options.performance_stats && nr_frags) {
./s390/net/qeth_l2_main.c:760:			card->perf_stats.sg_skbs_sent++;
./s390/net/qeth_l2_main.c:762:			card->perf_stats.sg_frags_sent += nr_frags + 1;
./s390/net/qeth_l2_main.c:801:	if (card->qdio.do_prio_queueing || (cast_type &&
./s390/net/qeth_l2_main.c:802:					card->info.is_multicast_different))
./s390/net/qeth_l2_main.c:803:		queue = card->qdio.out_qs[qeth_get_priority_queue(card, skb,
./s390/net/qeth_l2_main.c:806:		queue = card->qdio.out_qs[card->qdio.default_out_queue];
./s390/net/qeth_l2_main.c:808:	if ((card->state != CARD_STATE_UP) || !card->lan_online) {
./s390/net/qeth_l2_main.c:809:		card->stats.tx_carrier_errors++;
./s390/net/qeth_l2_main.c:813:	if (card->options.performance_stats) {
./s390/net/qeth_l2_main.c:814:		card->perf_stats.outbound_cnt++;
./s390/net/qeth_l2_main.c:815:		card->perf_stats.outbound_start_time = qeth_get_micros();
./s390/net/qeth_l2_main.c:819:	switch (card->info.type) {
./s390/net/qeth_l2_main.c:831:		card->stats.tx_packets++;
./s390/net/qeth_l2_main.c:832:		card->stats.tx_bytes += tx_bytes;
./s390/net/qeth_l2_main.c:833:		if (card->options.performance_stats)
./s390/net/qeth_l2_main.c:834:			card->perf_stats.outbound_time += qeth_get_micros() -
./s390/net/qeth_l2_main.c:835:				card->perf_stats.outbound_start_time;
./s390/net/qeth_l2_main.c:843:	card->stats.tx_dropped++;
./s390/net/qeth_l2_main.c:844:	card->stats.tx_errors++;
./s390/net/qeth_l2_main.c:856:	if (card->state == CARD_STATE_UP)
./s390/net/qeth_l2_main.c:858:	if (card->state != CARD_STATE_SOFTSETUP)
./s390/net/qeth_l2_main.c:861:	if ((card->info.type != QETH_CARD_TYPE_OSN) &&
./s390/net/qeth_l2_main.c:862:	     (!(card->info.mac_bits & QETH_LAYER2_MAC_REGISTERED))) {
./s390/net/qeth_l2_main.c:866:	card->data.state = CH_STATE_UP;
./s390/net/qeth_l2_main.c:867:	card->state = CARD_STATE_UP;
./s390/net/qeth_l2_main.c:870:	if (qdio_stop_irq(card->data.ccwdev, 0) >= 0) {
./s390/net/qeth_l2_main.c:871:		napi_enable(&card->napi);
./s390/net/qeth_l2_main.c:872:		napi_schedule(&card->napi);
./s390/net/qeth_l2_main.c:896:	if (card->state == CARD_STATE_UP) {
./s390/net/qeth_l2_main.c:897:		card->state = CARD_STATE_SOFTSETUP;
./s390/net/qeth_l2_main.c:898:		napi_disable(&card->napi);
./s390/net/qeth_l2_main.c:918:	INIT_LIST_HEAD(&card->vid_list);
./s390/net/qeth_l2_main.c:919:	hash_init(card->mac_htable);
./s390/net/qeth_l2_main.c:920:	card->options.layer2 = 1;
./s390/net/qeth_l2_main.c:921:	card->info.hwtrap = 0;
./s390/net/qeth_l2_main.c:932:	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
./s390/net/qeth_l2_main.c:937:	if (card->dev) {
./s390/net/qeth_l2_main.c:938:		unregister_netdev(card->dev);
./s390/net/qeth_l2_main.c:939:		free_netdev(card->dev);
./s390/net/qeth_l2_main.c:940:		card->dev = NULL;
./s390/net/qeth_l2_main.c:981:	switch (card->info.type) {
./s390/net/qeth_l2_main.c:983:		card->dev = alloc_netdev(0, "hsi%d", NET_NAME_UNKNOWN,
./s390/net/qeth_l2_main.c:987:		card->dev = alloc_netdev(0, "osn%d", NET_NAME_UNKNOWN,
./s390/net/qeth_l2_main.c:991:		card->dev = alloc_etherdev(0);
./s390/net/qeth_l2_main.c:994:	if (!card->dev)
./s390/net/qeth_l2_main.c:997:	card->dev->ml_priv = card;
./s390/net/qeth_l2_main.c:998:	card->dev->watchdog_timeo = QETH_TX_TIMEOUT;
./s390/net/qeth_l2_main.c:999:	card->dev->mtu = card->info.initial_mtu;
./s390/net/qeth_l2_main.c:1000:	card->dev->min_mtu = 64;
./s390/net/qeth_l2_main.c:1001:	card->dev->max_mtu = ETH_MAX_MTU;
./s390/net/qeth_l2_main.c:1002:	card->dev->netdev_ops = &qeth_l2_netdev_ops;
./s390/net/qeth_l2_main.c:1003:	if (card->info.type == QETH_CARD_TYPE_OSN) {
./s390/net/qeth_l2_main.c:1004:		card->dev->ethtool_ops = &qeth_l2_osn_ops;
./s390/net/qeth_l2_main.c:1005:		card->dev->flags |= IFF_NOARP;
./s390/net/qeth_l2_main.c:1007:		card->dev->ethtool_ops = &qeth_l2_ethtool_ops;
./s390/net/qeth_l2_main.c:1009:	card->dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
./s390/net/qeth_l2_main.c:1010:	if (card->info.type == QETH_CARD_TYPE_OSD && !card->info.guestlan) {
./s390/net/qeth_l2_main.c:1011:		card->dev->hw_features = NETIF_F_SG;
./s390/net/qeth_l2_main.c:1012:		card->dev->vlan_features = NETIF_F_SG;
./s390/net/qeth_l2_main.c:1013:		card->dev->features |= NETIF_F_SG;
./s390/net/qeth_l2_main.c:1016:			card->dev->hw_features |= NETIF_F_IP_CSUM;
./s390/net/qeth_l2_main.c:1017:			card->dev->vlan_features |= NETIF_F_IP_CSUM;
./s390/net/qeth_l2_main.c:1020:			card->dev->hw_features |= NETIF_F_RXCSUM;
./s390/net/qeth_l2_main.c:1021:			card->dev->vlan_features |= NETIF_F_RXCSUM;
./s390/net/qeth_l2_main.c:1024:	if (card->info.type != QETH_CARD_TYPE_OSN &&
./s390/net/qeth_l2_main.c:1025:	    card->info.type != QETH_CARD_TYPE_IQD) {
./s390/net/qeth_l2_main.c:1026:		card->dev->priv_flags &= ~IFF_TX_SKB_SHARING;
./s390/net/qeth_l2_main.c:1027:		card->dev->needed_headroom = sizeof(struct qeth_hdr);
./s390/net/qeth_l2_main.c:1030:	card->info.broadcast_capable = 1;
./s390/net/qeth_l2_main.c:1032:	SET_NETDEV_DEV(card->dev, &card->gdev->dev);
./s390/net/qeth_l2_main.c:1033:	netif_napi_add(card->dev, &card->napi, qeth_poll, QETH_NAPI_WEIGHT);
./s390/net/qeth_l2_main.c:1034:	netif_carrier_off(card->dev);
./s390/net/qeth_l2_main.c:1035:	return register_netdev(card->dev);
./s390/net/qeth_l2_main.c:1049:	QETH_CARD_HEX(card, 2, &card->options.sbp.supported_funcs,
./s390/net/qeth_l2_main.c:1050:		      sizeof(card->options.sbp.supported_funcs));
./s390/net/qeth_l2_main.c:1059:	mutex_lock(&card->discipline_mutex);
./s390/net/qeth_l2_main.c:1060:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l2_main.c:1064:	recover_flag = card->state;
./s390/net/qeth_l2_main.c:1072:	if (card->options.sbp.supported_funcs)
./s390/net/qeth_l2_main.c:1073:		dev_info(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1078:	if (!card->dev && qeth_l2_setup_netdev(card)) {
./s390/net/qeth_l2_main.c:1083:	if (card->info.type != QETH_CARD_TYPE_OSN)
./s390/net/qeth_l2_main.c:1084:		qeth_l2_send_setmac(card, &card->dev->dev_addr[0]);
./s390/net/qeth_l2_main.c:1087:		if (card->info.hwtrap &&
./s390/net/qeth_l2_main.c:1089:			card->info.hwtrap = 0;
./s390/net/qeth_l2_main.c:1091:		card->info.hwtrap = 0;
./s390/net/qeth_l2_main.c:1095:	card->state = CARD_STATE_HARDSETUP;
./s390/net/qeth_l2_main.c:1096:	memset(&card->rx, 0, sizeof(struct qeth_rx));
./s390/net/qeth_l2_main.c:1102:	if ((card->info.type == QETH_CARD_TYPE_OSD) ||
./s390/net/qeth_l2_main.c:1103:	    (card->info.type == QETH_CARD_TYPE_OSX)) {
./s390/net/qeth_l2_main.c:1109:	if (card->info.type != QETH_CARD_TYPE_OSN &&
./s390/net/qeth_l2_main.c:1110:	    card->info.type != QETH_CARD_TYPE_OSM)
./s390/net/qeth_l2_main.c:1113:	netif_tx_disable(card->dev);
./s390/net/qeth_l2_main.c:1121:	card->state = CARD_STATE_SOFTSETUP;
./s390/net/qeth_l2_main.c:1122:	if (card->lan_online)
./s390/net/qeth_l2_main.c:1123:		netif_carrier_on(card->dev);
./s390/net/qeth_l2_main.c:1125:		netif_carrier_off(card->dev);
./s390/net/qeth_l2_main.c:1130:		    card->info.type != QETH_CARD_TYPE_OSN) {
./s390/net/qeth_l2_main.c:1131:			__qeth_l2_open(card->dev);
./s390/net/qeth_l2_main.c:1134:			dev_open(card->dev);
./s390/net/qeth_l2_main.c:1138:		qeth_l2_set_rx_mode(card->dev);
./s390/net/qeth_l2_main.c:1140:		qeth_recover_features(card->dev);
./s390/net/qeth_l2_main.c:1145:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l2_main.c:1146:	mutex_unlock(&card->discipline_mutex);
./s390/net/qeth_l2_main.c:1156:		card->state = CARD_STATE_RECOVER;
./s390/net/qeth_l2_main.c:1158:		card->state = CARD_STATE_DOWN;
./s390/net/qeth_l2_main.c:1159:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l2_main.c:1160:	mutex_unlock(&card->discipline_mutex);
./s390/net/qeth_l2_main.c:1176:	mutex_lock(&card->discipline_mutex);
./s390/net/qeth_l2_main.c:1177:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l2_main.c:1181:	if (card->dev && netif_carrier_ok(card->dev))
./s390/net/qeth_l2_main.c:1182:		netif_carrier_off(card->dev);
./s390/net/qeth_l2_main.c:1183:	recover_flag = card->state;
./s390/net/qeth_l2_main.c:1184:	if ((!recovery_mode && card->info.hwtrap) || card->info.hwtrap == 2) {
./s390/net/qeth_l2_main.c:1186:		card->info.hwtrap = 1;
./s390/net/qeth_l2_main.c:1198:		card->state = CARD_STATE_RECOVER;
./s390/net/qeth_l2_main.c:1201:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l2_main.c:1202:	mutex_unlock(&card->discipline_mutex);
./s390/net/qeth_l2_main.c:1221:	dev_warn(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1224:	__qeth_l2_set_offline(card->gdev, 1);
./s390/net/qeth_l2_main.c:1225:	rc = __qeth_l2_set_online(card->gdev, 1);
./s390/net/qeth_l2_main.c:1227:		dev_info(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1231:		dev_warn(&card->gdev->dev, "The qeth device driver "
./s390/net/qeth_l2_main.c:1255:	if (card->dev)
./s390/net/qeth_l2_main.c:1256:		netif_device_detach(card->dev);
./s390/net/qeth_l2_main.c:1258:	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
./s390/net/qeth_l2_main.c:1261:	if (card->state == CARD_STATE_UP) {
./s390/net/qeth_l2_main.c:1262:		if (card->info.hwtrap)
./s390/net/qeth_l2_main.c:1264:		__qeth_l2_set_offline(card->gdev, 1);
./s390/net/qeth_l2_main.c:1266:		__qeth_l2_set_offline(card->gdev, 0);
./s390/net/qeth_l2_main.c:1278:	if (card->state == CARD_STATE_RECOVER) {
./s390/net/qeth_l2_main.c:1279:		rc = __qeth_l2_set_online(card->gdev, 1);
./s390/net/qeth_l2_main.c:1282:			dev_close(card->dev);
./s390/net/qeth_l2_main.c:1286:		rc = __qeth_l2_set_online(card->gdev, 0);
./s390/net/qeth_l2_main.c:1289:	if (card->dev)
./s390/net/qeth_l2_main.c:1290:		netif_device_attach(card->dev);
./s390/net/qeth_l2_main.c:1292:		dev_warn(&card->gdev->dev, "The qeth device driver "
./s390/net/qeth_l2_main.c:1345:	wait_event(card->wait_q,
./s390/net/qeth_l2_main.c:1346:		   atomic_cmpxchg(&card->write.irq_pending, 0, 1) == 0);
./s390/net/qeth_l2_main.c:1349:	spin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);
./s390/net/qeth_l2_main.c:1350:	rc = ccw_device_start(card->write.ccwdev, &card->write.ccw,
./s390/net/qeth_l2_main.c:1352:	spin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);
./s390/net/qeth_l2_main.c:1358:		atomic_set(&card->write.irq_pending, 0);
./s390/net/qeth_l2_main.c:1359:		wake_up(&card->wait_q);
./s390/net/qeth_l2_main.c:1395:	iob = qeth_wait_for_buffer(&card->write);
./s390/net/qeth_l2_main.c:1417:	card->osn_info.assist_cb = assist_cb;
./s390/net/qeth_l2_main.c:1418:	card->osn_info.data_cb = data_cb;
./s390/net/qeth_l2_main.c:1433:	card->osn_info.assist_cb = NULL;
./s390/net/qeth_l2_main.c:1434:	card->osn_info.data_cb = NULL;
./s390/net/qeth_l2_main.c:1503:	kobject_uevent_env(&card->gdev->dev.kobj, KOBJ_CHANGE, env);
./s390/net/qeth_l2_main.c:1530:	mutex_lock(&data->card->conf_mutex);
./s390/net/qeth_l2_main.c:1531:	data->card->options.sbp.role = entry->role;
./s390/net/qeth_l2_main.c:1532:	mutex_unlock(&data->card->conf_mutex);
./s390/net/qeth_l2_main.c:1545:	kobject_uevent_env(&data->card->gdev->dev.kobj,
./s390/net/qeth_l2_main.c:1590:		dev_info(&data->card->gdev->dev,
./s390/net/qeth_l2_main.c:1592:			data->card->dev->name,
./s390/net/qeth_l2_main.c:1598:		mutex_lock(&data->card->conf_mutex);
./s390/net/qeth_l2_main.c:1599:		data->card->options.sbp.hostnotification = 0;
./s390/net/qeth_l2_main.c:1600:		mutex_unlock(&data->card->conf_mutex);
./s390/net/qeth_l2_main.c:1675:	int is_iqd = (card->info.type == QETH_CARD_TYPE_IQD);
./s390/net/qeth_l2_main.c:1690:			dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1696:			dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1704:				dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1709:				dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1719:			dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1725:			dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1731:			dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1737:			dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:1766:	enum qeth_ipa_cmds ipa_cmd = (card->info.type == QETH_CARD_TYPE_IQD) ?
./s390/net/qeth_l2_main.c:1806: * strucutre: card->options.sbp.supported_funcs.
./s390/net/qeth_l2_main.c:1823:		card->options.sbp.role = QETH_SBP_ROLE_NONE;
./s390/net/qeth_l2_main.c:1826:	card->options.sbp.supported_funcs = cbctl.data.supported;
./s390/net/qeth_l2_main.c:1881:	if (!(card->options.sbp.supported_funcs & IPA_SBP_QUERY_BRIDGE_PORTS))
./s390/net/qeth_l2_main.c:1937:	if (!(card->options.sbp.supported_funcs & setcmd))
./s390/net/qeth_l2_main.c:1968:			dev_err(&card->gdev->dev,
./s390/net/qeth_l2_main.c:2027:	if (!card->options.sbp.supported_funcs)
./s390/net/qeth_l3_main.c:159:		hash_for_each_possible(card->ip_mc_htable, addr, hnode, key)
./s390/net/qeth_l3_main.c:163:		hash_for_each_possible(card->ip_htable,  addr, hnode, key)
./s390/net/qeth_l3_main.c:192:	if (!card->ipato.enabled)
./s390/net/qeth_l3_main.c:199:	list_for_each_entry(ipatoe, &card->ipato.entries, entry) {
./s390/net/qeth_l3_main.c:215:	if ((addr->proto == QETH_PROT_IPV4) && card->ipato.invert4)
./s390/net/qeth_l3_main.c:217:	else if ((addr->proto == QETH_PROT_IPV6) && card->ipato.invert6)
./s390/net/qeth_l3_main.c:281:		dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:296:		hash_add(card->ip_htable, &addr->hnode,
./s390/net/qeth_l3_main.c:313:			spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:315:			spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:361:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:363:	hash_for_each_safe(card->ip_htable, i, tmp, addr, hnode) {
./s390/net/qeth_l3_main.c:372:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:374:	spin_lock_bh(&card->mclock);
./s390/net/qeth_l3_main.c:376:	hash_for_each_safe(card->ip_mc_htable, i, tmp, addr, hnode) {
./s390/net/qeth_l3_main.c:381:	spin_unlock_bh(&card->mclock);
./s390/net/qeth_l3_main.c:394:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:396:	hash_for_each_safe(card->ip_htable, i, tmp, addr, hnode) {
./s390/net/qeth_l3_main.c:400:				spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:402:				spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:418:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:515:	if (card->info.type == QETH_CARD_TYPE_IQD) {
./s390/net/qeth_l3_main.c:550:	rc = qeth_l3_correct_routing_type(card, &card->options.route4.type,
./s390/net/qeth_l3_main.c:555:	rc = qeth_l3_send_setrouting(card, card->options.route4.type,
./s390/net/qeth_l3_main.c:558:		card->options.route4.type = NO_ROUTER;
./s390/net/qeth_l3_main.c:575:	rc = qeth_l3_correct_routing_type(card, &card->options.route6.type,
./s390/net/qeth_l3_main.c:580:	rc = qeth_l3_send_setrouting(card, card->options.route6.type,
./s390/net/qeth_l3_main.c:583:		card->options.route6.type = NO_ROUTER;
./s390/net/qeth_l3_main.c:606:	hash_for_each(card->ip_htable, i, addr, hnode) {
./s390/net/qeth_l3_main.c:620:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:622:	list_for_each_entry_safe(ipatoe, tmp, &card->ipato.entries, entry) {
./s390/net/qeth_l3_main.c:628:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:639:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:641:	list_for_each_entry(ipatoe, &card->ipato.entries, entry) {
./s390/net/qeth_l3_main.c:653:		list_add_tail(&new->entry, &card->ipato.entries);
./s390/net/qeth_l3_main.c:657:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:669:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:671:	list_for_each_entry_safe(ipatoe, tmp, &card->ipato.entries, entry) {
./s390/net/qeth_l3_main.c:683:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:712:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:714:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:741:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:743:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:775:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:777:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:804:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:806:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:818:	if (card->options.sniffer)
./s390/net/qeth_l3_main.c:844:		dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:855:	if (card->options.sniffer)
./s390/net/qeth_l3_main.c:910:			dev_warn(&card->gdev->dev, "Reading the adapter MAC"
./s390/net/qeth_l3_main.c:942:		dev_info(&card->gdev->dev,
./s390/net/qeth_l3_main.c:950:		dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:964:		dev_info(&card->gdev->dev,
./s390/net/qeth_l3_main.c:973:		dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:986:		dev_info(&card->gdev->dev,
./s390/net/qeth_l3_main.c:994:		dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:998:		dev_info(&card->gdev->dev, "VLAN enabled\n");
./s390/net/qeth_l3_main.c:1010:		dev_info(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1019:		dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1023:		dev_info(&card->gdev->dev, "Multicast enabled\n");
./s390/net/qeth_l3_main.c:1024:		card->dev->flags |= IFF_MULTICAST;
./s390/net/qeth_l3_main.c:1038:		dev_err(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1044:	if (card->info.type == QETH_CARD_TYPE_IQD)
./s390/net/qeth_l3_main.c:1050:		dev_err(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1058:		dev_err(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1066:		dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1072:	dev_info(&card->gdev->dev, "IPV6 enabled\n");
./s390/net/qeth_l3_main.c:1084:		dev_info(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1099:	card->info.broadcast_capable = 0;
./s390/net/qeth_l3_main.c:1101:		dev_info(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1110:		dev_warn(&card->gdev->dev, "Enabling broadcast filtering for "
./s390/net/qeth_l3_main.c:1118:		dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:1123:	card->info.broadcast_capable = QETH_BROADCAST_WITH_ECHO;
./s390/net/qeth_l3_main.c:1124:	dev_info(&card->gdev->dev, "Broadcast enabled\n");
./s390/net/qeth_l3_main.c:1128:		dev_warn(&card->gdev->dev, "Setting up broadcast echo "
./s390/net/qeth_l3_main.c:1132:	card->info.broadcast_capable = QETH_BROADCAST_WITHOUT_ECHO;
./s390/net/qeth_l3_main.c:1134:	if (card->info.broadcast_capable)
./s390/net/qeth_l3_main.c:1135:		card->dev->flags |= IFF_BROADCAST;
./s390/net/qeth_l3_main.c:1137:		card->dev->flags &= ~IFF_BROADCAST;
./s390/net/qeth_l3_main.c:1163:		memcpy(card->dev->dev_addr,
./s390/net/qeth_l3_main.c:1166:		eth_random_addr(card->dev->dev_addr);
./s390/net/qeth_l3_main.c:1185:			card->info.unique_id;
./s390/net/qeth_l3_main.c:1199:		card->info.unique_id = *((__u16 *)
./s390/net/qeth_l3_main.c:1202:		card->info.unique_id =  UNIQUE_ID_IF_CREATE_ADDR_FAILED |
./s390/net/qeth_l3_main.c:1204:		dev_warn(&card->gdev->dev, "The network adapter failed to "
./s390/net/qeth_l3_main.c:1219:		card->info.unique_id =  UNIQUE_ID_IF_CREATE_ADDR_FAILED |
./s390/net/qeth_l3_main.c:1230:			card->info.unique_id;
./s390/net/qeth_l3_main.c:1256:			card->info.promisc_mode = SET_PROMISC_MODE_OFF;
./s390/net/qeth_l3_main.c:1257:			dev_info(&card->gdev->dev, "The HiperSockets network "
./s390/net/qeth_l3_main.c:1267:			card->info.promisc_mode = SET_PROMISC_MODE_ON;
./s390/net/qeth_l3_main.c:1268:			dev_info(&card->gdev->dev, "The HiperSockets network "
./s390/net/qeth_l3_main.c:1272:			dev_warn(&card->gdev->dev, "The device is not "
./s390/net/qeth_l3_main.c:1277:			dev_warn(&card->gdev->dev, "A HiperSockets "
./s390/net/qeth_l3_main.c:1322:	hash_for_each(card->ip_mc_htable, i, addr, hnode)
./s390/net/qeth_l3_main.c:1334:	hash_for_each_safe(card->ip_mc_htable, i, tmp, addr, hnode) {
./s390/net/qeth_l3_main.c:1355:	hash_for_each_safe(card->ip_mc_htable, i, tmp, addr, hnode) {
./s390/net/qeth_l3_main.c:1401:			hash_add(card->ip_mc_htable,
./s390/net/qeth_l3_main.c:1420:	for_each_set_bit(vid, card->active_vlans, VLAN_N_VID) {
./s390/net/qeth_l3_main.c:1423:		netdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q),
./s390/net/qeth_l3_main.c:1442:	in4_dev = __in_dev_get_rcu(card->dev);
./s390/net/qeth_l3_main.c:1490:		hash_add(card->ip_mc_htable,
./s390/net/qeth_l3_main.c:1508:	for_each_set_bit(vid, card->active_vlans, VLAN_N_VID) {
./s390/net/qeth_l3_main.c:1511:		netdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q),
./s390/net/qeth_l3_main.c:1534:	in6_dev = in6_dev_get(card->dev);
./s390/net/qeth_l3_main.c:1558:	netdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q), vid);
./s390/net/qeth_l3_main.c:1569:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:1578:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:1596:	netdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q), vid);
./s390/net/qeth_l3_main.c:1608:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:1618:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:1640:	set_bit(vid, card->active_vlans);
./s390/net/qeth_l3_main.c:1657:	clear_bit(vid, card->active_vlans);
./s390/net/qeth_l3_main.c:1658:	qeth_l3_set_multicast_list(card->dev);
./s390/net/qeth_l3_main.c:1680:				     tg_addr, card->dev, 0);
./s390/net/qeth_l3_main.c:1688:				memcpy(tg_addr, card->dev->broadcast,
./s390/net/qeth_l3_main.c:1689:					card->dev->addr_len);
./s390/net/qeth_l3_main.c:1691:			card->stats.multicast++;
./s390/net/qeth_l3_main.c:1695:			memcpy(tg_addr, card->dev->broadcast,
./s390/net/qeth_l3_main.c:1696:				card->dev->addr_len);
./s390/net/qeth_l3_main.c:1697:			card->stats.multicast++;
./s390/net/qeth_l3_main.c:1704:			if (card->options.sniffer)
./s390/net/qeth_l3_main.c:1708:			memcpy(tg_addr, card->dev->dev_addr,
./s390/net/qeth_l3_main.c:1709:				card->dev->addr_len);
./s390/net/qeth_l3_main.c:1712:			card->dev->header_ops->create(skb, card->dev, prot,
./s390/net/qeth_l3_main.c:1714:				card->dev->addr_len);
./s390/net/qeth_l3_main.c:1716:			card->dev->header_ops->create(skb, card->dev, prot,
./s390/net/qeth_l3_main.c:1717:				tg_addr, "FAKELL", card->dev->addr_len);
./s390/net/qeth_l3_main.c:1720:	skb->protocol = eth_type_trans(skb, card->dev);
./s390/net/qeth_l3_main.c:1729:	if (card->dev->features & NETIF_F_RXCSUM) {
./s390/net/qeth_l3_main.c:1758:			&card->qdio.in_q->bufs[card->rx.b_index],
./s390/net/qeth_l3_main.c:1759:			&card->rx.b_element, &card->rx.e_offset, &hdr);
./s390/net/qeth_l3_main.c:1764:		skb->dev = card->dev;
./s390/net/qeth_l3_main.c:1768:			if ((card->info.type == QETH_CARD_TYPE_IQD) &&
./s390/net/qeth_l3_main.c:1773:				skb->dev = card->dev;
./s390/net/qeth_l3_main.c:1775:				card->dev->header_ops->create(skb, card->dev, 0,
./s390/net/qeth_l3_main.c:1776:					card->dev->dev_addr, "FAKELL",
./s390/net/qeth_l3_main.c:1777:					card->dev->addr_len);
./s390/net/qeth_l3_main.c:1783:				if (is_vlan && !card->options.sniffer)
./s390/net/qeth_l3_main.c:1786:				napi_gro_receive(&card->napi, skb);
./s390/net/qeth_l3_main.c:1803:		card->stats.rx_packets++;
./s390/net/qeth_l3_main.c:1804:		card->stats.rx_bytes += len;
./s390/net/qeth_l3_main.c:1815:	for_each_set_bit(vid, card->active_vlans, VLAN_N_VID) {
./s390/net/qeth_l3_main.c:1819:		netdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q),
./s390/net/qeth_l3_main.c:1842:		if (card->dev == dev) {
./s390/net/qeth_l3_main.c:1865:	if (card && card->options.layer2)
./s390/net/qeth_l3_main.c:1878:	if (card->options.sniffer &&
./s390/net/qeth_l3_main.c:1879:	    (card->info.promisc_mode == SET_PROMISC_MODE_ON))
./s390/net/qeth_l3_main.c:1881:	if (card->read.state == CH_STATE_UP &&
./s390/net/qeth_l3_main.c:1882:	    card->write.state == CH_STATE_UP &&
./s390/net/qeth_l3_main.c:1883:	    (card->state == CARD_STATE_UP)) {
./s390/net/qeth_l3_main.c:1885:			qeth_l3_stop(card->dev);
./s390/net/qeth_l3_main.c:1888:			dev_close(card->dev);
./s390/net/qeth_l3_main.c:1891:		card->state = CARD_STATE_SOFTSETUP;
./s390/net/qeth_l3_main.c:1893:	if (card->state == CARD_STATE_SOFTSETUP) {
./s390/net/qeth_l3_main.c:1896:		card->state = CARD_STATE_HARDSETUP;
./s390/net/qeth_l3_main.c:1898:	if (card->state == CARD_STATE_HARDSETUP) {
./s390/net/qeth_l3_main.c:1902:		card->state = CARD_STATE_DOWN;
./s390/net/qeth_l3_main.c:1904:	if (card->state == CARD_STATE_DOWN) {
./s390/net/qeth_l3_main.c:1905:		qeth_clear_cmd_buffers(&card->read);
./s390/net/qeth_l3_main.c:1906:		qeth_clear_cmd_buffers(&card->write);
./s390/net/qeth_l3_main.c:1917:	struct net_device *dev = card->dev;
./s390/net/qeth_l3_main.c:1920:	     (card->info.promisc_mode == SET_PROMISC_MODE_ON)) ||
./s390/net/qeth_l3_main.c:1922:	     (card->info.promisc_mode == SET_PROMISC_MODE_OFF)))
./s390/net/qeth_l3_main.c:1925:	if (card->info.guestlan) {		/* Guestlan trace */
./s390/net/qeth_l3_main.c:1928:	} else if (card->options.sniffer &&	/* HiperSockets trace */
./s390/net/qeth_l3_main.c:1946:	    (card->state != CARD_STATE_UP))
./s390/net/qeth_l3_main.c:1948:	if (!card->options.sniffer) {
./s390/net/qeth_l3_main.c:1950:		spin_lock_bh(&card->mclock);
./s390/net/qeth_l3_main.c:1961:		spin_unlock_bh(&card->mclock);
./s390/net/qeth_l3_main.c:2004:	if (card->info.guestlan)
./s390/net/qeth_l3_main.c:2157:	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_l3_main.c:2262:	if (card->info.guestlan)
./s390/net/qeth_l3_main.c:2303:	if (card->info.guestlan)
./s390/net/qeth_l3_main.c:2341:	if (card->info.guestlan || (card->info.type == QETH_CARD_TYPE_IQD))
./s390/net/qeth_l3_main.c:2451:		switch (card->info.link_type) {
./s390/net/qeth_l3_main.c:2502:		if ((ipv == 4) || (card->info.type == QETH_CARD_TYPE_IQD))
./s390/net/qeth_l3_main.c:2533:		if (card->info.type == QETH_CARD_TYPE_IQD)
./s390/net/qeth_l3_main.c:2564:	if (card->options.performance_stats)
./s390/net/qeth_l3_main.c:2565:		card->perf_stats.tx_csum++;
./s390/net/qeth_l3_main.c:2649:		card->qdio.out_qs[card->qdio.do_prio_queueing
./s390/net/qeth_l3_main.c:2650:			|| (cast_type && card->info.is_multicast_different) ?
./s390/net/qeth_l3_main.c:2652:			card->qdio.default_out_queue];
./s390/net/qeth_l3_main.c:2659:	if (((card->info.type == QETH_CARD_TYPE_IQD) &&
./s390/net/qeth_l3_main.c:2660:	     (((card->options.cq != QETH_CQ_ENABLED) && !ipv) ||
./s390/net/qeth_l3_main.c:2661:	      ((card->options.cq == QETH_CQ_ENABLED) &&
./s390/net/qeth_l3_main.c:2663:	    card->options.sniffer)
./s390/net/qeth_l3_main.c:2666:	if ((card->state != CARD_STATE_UP) || !card->lan_online) {
./s390/net/qeth_l3_main.c:2667:		card->stats.tx_carrier_errors++;
./s390/net/qeth_l3_main.c:2672:	    (card->info.broadcast_capable == 0))
./s390/net/qeth_l3_main.c:2675:	if (card->options.performance_stats) {
./s390/net/qeth_l3_main.c:2676:		card->perf_stats.outbound_cnt++;
./s390/net/qeth_l3_main.c:2677:		card->perf_stats.outbound_start_time = qeth_get_micros();
./s390/net/qeth_l3_main.c:2684:	if (card->info.type == QETH_CARD_TYPE_IQD) {
./s390/net/qeth_l3_main.c:2721:	if ((card->info.type != QETH_CARD_TYPE_IQD) &&
./s390/net/qeth_l3_main.c:2726:		if (card->options.performance_stats) {
./s390/net/qeth_l3_main.c:2728:				card->perf_stats.tx_linfail++;
./s390/net/qeth_l3_main.c:2730:				card->perf_stats.tx_lin++;
./s390/net/qeth_l3_main.c:2773:	if (card->info.type != QETH_CARD_TYPE_IQD) {
./s390/net/qeth_l3_main.c:2792:		card->stats.tx_packets++;
./s390/net/qeth_l3_main.c:2793:		card->stats.tx_bytes += tx_bytes;
./s390/net/qeth_l3_main.c:2796:		if (card->options.performance_stats) {
./s390/net/qeth_l3_main.c:2798:				card->perf_stats.large_send_bytes += tx_bytes;
./s390/net/qeth_l3_main.c:2799:				card->perf_stats.large_send_cnt++;
./s390/net/qeth_l3_main.c:2802:				card->perf_stats.sg_skbs_sent++;
./s390/net/qeth_l3_main.c:2804:				card->perf_stats.sg_frags_sent += nr_frags + 1;
./s390/net/qeth_l3_main.c:2821:	if (card->options.performance_stats)
./s390/net/qeth_l3_main.c:2822:		card->perf_stats.outbound_time += qeth_get_micros() -
./s390/net/qeth_l3_main.c:2823:			card->perf_stats.outbound_start_time;
./s390/net/qeth_l3_main.c:2827:	card->stats.tx_dropped++;
./s390/net/qeth_l3_main.c:2828:	card->stats.tx_errors++;
./s390/net/qeth_l3_main.c:2842:	if (card->state == CARD_STATE_UP)
./s390/net/qeth_l3_main.c:2844:	if (card->state != CARD_STATE_SOFTSETUP)
./s390/net/qeth_l3_main.c:2846:	card->data.state = CH_STATE_UP;
./s390/net/qeth_l3_main.c:2847:	card->state = CARD_STATE_UP;
./s390/net/qeth_l3_main.c:2850:	if (qdio_stop_irq(card->data.ccwdev, 0) >= 0) {
./s390/net/qeth_l3_main.c:2851:		napi_enable(&card->napi);
./s390/net/qeth_l3_main.c:2852:		napi_schedule(&card->napi);
./s390/net/qeth_l3_main.c:2876:	if (card->state == CARD_STATE_UP) {
./s390/net/qeth_l3_main.c:2877:		card->state = CARD_STATE_SOFTSETUP;
./s390/net/qeth_l3_main.c:2878:		napi_disable(&card->napi);
./s390/net/qeth_l3_main.c:2954:	if (card->info.type == QETH_CARD_TYPE_OSD ||
./s390/net/qeth_l3_main.c:2955:	    card->info.type == QETH_CARD_TYPE_OSX) {
./s390/net/qeth_l3_main.c:2956:		if ((card->info.link_type == QETH_LINK_TYPE_LANE_TR) ||
./s390/net/qeth_l3_main.c:2957:		    (card->info.link_type == QETH_LINK_TYPE_HSTR)) {
./s390/net/qeth_l3_main.c:2961:			card->dev = alloc_etherdev(0);
./s390/net/qeth_l3_main.c:2962:			if (!card->dev)
./s390/net/qeth_l3_main.c:2964:			card->dev->netdev_ops = &qeth_l3_osa_netdev_ops;
./s390/net/qeth_l3_main.c:2968:			if (!(card->info.unique_id & UNIQUE_ID_NOT_BY_CARD))
./s390/net/qeth_l3_main.c:2969:				card->dev->dev_id = card->info.unique_id &
./s390/net/qeth_l3_main.c:2971:			if (!card->info.guestlan) {
./s390/net/qeth_l3_main.c:2972:				card->dev->hw_features = NETIF_F_SG |
./s390/net/qeth_l3_main.c:2975:				card->dev->vlan_features = NETIF_F_SG |
./s390/net/qeth_l3_main.c:2978:				card->dev->features |= NETIF_F_SG;
./s390/net/qeth_l3_main.c:2981:	} else if (card->info.type == QETH_CARD_TYPE_IQD) {
./s390/net/qeth_l3_main.c:2982:		card->dev = alloc_netdev(0, "hsi%d", NET_NAME_UNKNOWN,
./s390/net/qeth_l3_main.c:2984:		if (!card->dev)
./s390/net/qeth_l3_main.c:2986:		card->dev->flags |= IFF_NOARP;
./s390/net/qeth_l3_main.c:2987:		card->dev->netdev_ops = &qeth_l3_netdev_ops;
./s390/net/qeth_l3_main.c:2991:		if (card->options.hsuid[0])
./s390/net/qeth_l3_main.c:2992:			memcpy(card->dev->perm_addr, card->options.hsuid, 9);
./s390/net/qeth_l3_main.c:2996:	card->dev->ml_priv = card;
./s390/net/qeth_l3_main.c:2997:	card->dev->watchdog_timeo = QETH_TX_TIMEOUT;
./s390/net/qeth_l3_main.c:2998:	card->dev->mtu = card->info.initial_mtu;
./s390/net/qeth_l3_main.c:2999:	card->dev->min_mtu = 64;
./s390/net/qeth_l3_main.c:3000:	card->dev->max_mtu = ETH_MAX_MTU;
./s390/net/qeth_l3_main.c:3001:	card->dev->ethtool_ops = &qeth_l3_ethtool_ops;
./s390/net/qeth_l3_main.c:3002:	card->dev->features |=	NETIF_F_HW_VLAN_CTAG_TX |
./s390/net/qeth_l3_main.c:3005:	netif_keep_dst(card->dev);
./s390/net/qeth_l3_main.c:3006:	netif_set_gso_max_size(card->dev, (QETH_MAX_BUFFER_ELEMENTS(card) - 1) *
./s390/net/qeth_l3_main.c:3009:	SET_NETDEV_DEV(card->dev, &card->gdev->dev);
./s390/net/qeth_l3_main.c:3010:	netif_napi_add(card->dev, &card->napi, qeth_poll, QETH_NAPI_WEIGHT);
./s390/net/qeth_l3_main.c:3011:	netif_carrier_off(card->dev);
./s390/net/qeth_l3_main.c:3012:	return register_netdev(card->dev);
./s390/net/qeth_l3_main.c:3030:	hash_init(card->ip_htable);
./s390/net/qeth_l3_main.c:3031:	hash_init(card->ip_mc_htable);
./s390/net/qeth_l3_main.c:3032:	card->options.layer2 = 0;
./s390/net/qeth_l3_main.c:3033:	card->info.hwtrap = 0;
./s390/net/qeth_l3_main.c:3045:	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
./s390/net/qeth_l3_main.c:3050:	if (card->dev) {
./s390/net/qeth_l3_main.c:3051:		unregister_netdev(card->dev);
./s390/net/qeth_l3_main.c:3052:		free_netdev(card->dev);
./s390/net/qeth_l3_main.c:3053:		card->dev = NULL;
./s390/net/qeth_l3_main.c:3067:	mutex_lock(&card->discipline_mutex);
./s390/net/qeth_l3_main.c:3068:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_main.c:3072:	recover_flag = card->state;
./s390/net/qeth_l3_main.c:3080:	if (!card->dev && qeth_l3_setup_netdev(card)) {
./s390/net/qeth_l3_main.c:3086:		if (card->info.hwtrap &&
./s390/net/qeth_l3_main.c:3088:			card->info.hwtrap = 0;
./s390/net/qeth_l3_main.c:3090:		card->info.hwtrap = 0;
./s390/net/qeth_l3_main.c:3092:	card->state = CARD_STATE_HARDSETUP;
./s390/net/qeth_l3_main.c:3093:	memset(&card->rx, 0, sizeof(struct qeth_rx));
./s390/net/qeth_l3_main.c:3102:	if (!card->options.sniffer) {
./s390/net/qeth_l3_main.c:3115:	netif_tx_disable(card->dev);
./s390/net/qeth_l3_main.c:3123:	card->state = CARD_STATE_SOFTSETUP;
./s390/net/qeth_l3_main.c:3127:	if (card->lan_online)
./s390/net/qeth_l3_main.c:3128:		netif_carrier_on(card->dev);
./s390/net/qeth_l3_main.c:3130:		netif_carrier_off(card->dev);
./s390/net/qeth_l3_main.c:3134:			__qeth_l3_open(card->dev);
./s390/net/qeth_l3_main.c:3136:			dev_open(card->dev);
./s390/net/qeth_l3_main.c:3137:		qeth_l3_set_multicast_list(card->dev);
./s390/net/qeth_l3_main.c:3138:		qeth_recover_features(card->dev);
./s390/net/qeth_l3_main.c:3144:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_main.c:3145:	mutex_unlock(&card->discipline_mutex);
./s390/net/qeth_l3_main.c:3154:		card->state = CARD_STATE_RECOVER;
./s390/net/qeth_l3_main.c:3156:		card->state = CARD_STATE_DOWN;
./s390/net/qeth_l3_main.c:3157:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_main.c:3158:	mutex_unlock(&card->discipline_mutex);
./s390/net/qeth_l3_main.c:3174:	mutex_lock(&card->discipline_mutex);
./s390/net/qeth_l3_main.c:3175:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_main.c:3179:	if (card->dev && netif_carrier_ok(card->dev))
./s390/net/qeth_l3_main.c:3180:		netif_carrier_off(card->dev);
./s390/net/qeth_l3_main.c:3181:	recover_flag = card->state;
./s390/net/qeth_l3_main.c:3182:	if ((!recovery_mode && card->info.hwtrap) || card->info.hwtrap == 2) {
./s390/net/qeth_l3_main.c:3184:		card->info.hwtrap = 1;
./s390/net/qeth_l3_main.c:3187:	if ((card->options.cq == QETH_CQ_ENABLED) && card->dev) {
./s390/net/qeth_l3_main.c:3189:		call_netdevice_notifiers(NETDEV_REBOOT, card->dev);
./s390/net/qeth_l3_main.c:3201:		card->state = CARD_STATE_RECOVER;
./s390/net/qeth_l3_main.c:3204:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_main.c:3205:	mutex_unlock(&card->discipline_mutex);
./s390/net/qeth_l3_main.c:3225:	dev_warn(&card->gdev->dev,
./s390/net/qeth_l3_main.c:3228:	__qeth_l3_set_offline(card->gdev, 1);
./s390/net/qeth_l3_main.c:3229:	rc = __qeth_l3_set_online(card->gdev, 1);
./s390/net/qeth_l3_main.c:3231:		dev_info(&card->gdev->dev,
./s390/net/qeth_l3_main.c:3235:		dev_warn(&card->gdev->dev, "The qeth device driver "
./s390/net/qeth_l3_main.c:3248:	if (card->dev)
./s390/net/qeth_l3_main.c:3249:		netif_device_detach(card->dev);
./s390/net/qeth_l3_main.c:3251:	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
./s390/net/qeth_l3_main.c:3254:	if (card->state == CARD_STATE_UP) {
./s390/net/qeth_l3_main.c:3255:		if (card->info.hwtrap)
./s390/net/qeth_l3_main.c:3257:		__qeth_l3_set_offline(card->gdev, 1);
./s390/net/qeth_l3_main.c:3259:		__qeth_l3_set_offline(card->gdev, 0);
./s390/net/qeth_l3_main.c:3271:	if (card->state == CARD_STATE_RECOVER) {
./s390/net/qeth_l3_main.c:3272:		rc = __qeth_l3_set_online(card->gdev, 1);
./s390/net/qeth_l3_main.c:3275:			dev_close(card->dev);
./s390/net/qeth_l3_main.c:3279:		rc = __qeth_l3_set_online(card->gdev, 0);
./s390/net/qeth_l3_main.c:3282:	if (card->dev)
./s390/net/qeth_l3_main.c:3283:		netif_device_attach(card->dev);
./s390/net/qeth_l3_main.c:3285:		dev_warn(&card->gdev->dev, "The qeth device driver "
./s390/net/qeth_l3_main.c:3343:		spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:3345:		spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:3348:		spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:3350:		spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:3392:		spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:3394:		spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:3397:		spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_main.c:3399:		spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_core.h:72:	debug_text_event(card->debug, level, text)
./s390/net/qeth_core.h:75:	debug_event(card->debug, level, (void *)(addr), len)
./s390/net/qeth_core.h:78:	debug_sprintf_event(card->debug, level, text)
./s390/net/qeth_core.h:81:	qeth_dbf_longtext(card->debug, level, text)
./s390/net/qeth_core.h:91:#define CARD_RDEV(card) card->read.ccwdev
./s390/net/qeth_core.h:92:#define CARD_WDEV(card) card->write.ccwdev
./s390/net/qeth_core.h:93:#define CARD_DDEV(card) card->data.ccwdev
./s390/net/qeth_core.h:94:#define CARD_BUS_ID(card) dev_name(&card->gdev->dev)
./s390/net/qeth_core.h:95:#define CARD_RDEV_ID(card) dev_name(&card->read.ccwdev->dev)
./s390/net/qeth_core.h:96:#define CARD_WDEV_ID(card) dev_name(&card->write.ccwdev->dev)
./s390/net/qeth_core.h:97:#define CARD_DDEV_ID(card) dev_name(&card->data.ccwdev->dev)
./s390/net/qeth_core.h:869:	list_add_tail(&entry->list, &card->qdio.in_buf_pool.entry_list);
./s390/net/qeth_core.h:875:	return card->info.diagass_support & (__u32)cmd;
./s390/net/qeth_l3_sys.c:27:		if (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)
./s390/net/qeth_l3_sys.c:32:		if (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)
./s390/net/qeth_l3_sys.c:37:		if (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)
./s390/net/qeth_l3_sys.c:54:	return qeth_l3_dev_route_show(card, &card->options.route4, buf);
./s390/net/qeth_l3_sys.c:64:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:91:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:103:	return qeth_l3_dev_route_store(card, &card->options.route4,
./s390/net/qeth_l3_sys.c:118:	return qeth_l3_dev_route_show(card, &card->options.route6, buf);
./s390/net/qeth_l3_sys.c:129:	return qeth_l3_dev_route_store(card, &card->options.route6,
./s390/net/qeth_l3_sys.c:144:	return sprintf(buf, "%i\n", card->options.fake_broadcast? 1:0);
./s390/net/qeth_l3_sys.c:157:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:158:	if ((card->state != CARD_STATE_DOWN) &&
./s390/net/qeth_l3_sys.c:159:	    (card->state != CARD_STATE_RECOVER)) {
./s390/net/qeth_l3_sys.c:166:		card->options.fake_broadcast = i;
./s390/net/qeth_l3_sys.c:170:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:185:	return sprintf(buf, "%i\n", card->options.sniffer ? 1 : 0);
./s390/net/qeth_l3_sys.c:198:	if (card->info.type != QETH_CARD_TYPE_IQD)
./s390/net/qeth_l3_sys.c:200:	if (card->options.cq == QETH_CQ_ENABLED)
./s390/net/qeth_l3_sys.c:203:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:204:	if ((card->state != CARD_STATE_DOWN) &&
./s390/net/qeth_l3_sys.c:205:	    (card->state != CARD_STATE_RECOVER)) {
./s390/net/qeth_l3_sys.c:217:		card->options.sniffer = i;
./s390/net/qeth_l3_sys.c:220:		qdio_get_ssqd_desc(CARD_DDEV(card), &card->ssqd);
./s390/net/qeth_l3_sys.c:221:		if (card->ssqd.qdioac2 & QETH_SNIFF_AVAIL) {
./s390/net/qeth_l3_sys.c:222:			card->options.sniffer = i;
./s390/net/qeth_l3_sys.c:223:			if (card->qdio.init_pool.buf_count !=
./s390/net/qeth_l3_sys.c:234:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:251:	if (card->info.type != QETH_CARD_TYPE_IQD)
./s390/net/qeth_l3_sys.c:254:	memcpy(tmp_hsuid, card->options.hsuid, sizeof(tmp_hsuid));
./s390/net/qeth_l3_sys.c:270:	if (card->info.type != QETH_CARD_TYPE_IQD)
./s390/net/qeth_l3_sys.c:272:	if (card->state != CARD_STATE_DOWN &&
./s390/net/qeth_l3_sys.c:273:	    card->state != CARD_STATE_RECOVER)
./s390/net/qeth_l3_sys.c:275:	if (card->options.sniffer)
./s390/net/qeth_l3_sys.c:277:	if (card->options.cq == QETH_CQ_NOTAVAILABLE)
./s390/net/qeth_l3_sys.c:284:	if (card->options.hsuid[0]) {
./s390/net/qeth_l3_sys.c:294:				card->options.hsuid[i - 8];
./s390/net/qeth_l3_sys.c:298:		spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:300:		spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:306:		card->options.hsuid[0] = '\0';
./s390/net/qeth_l3_sys.c:307:		if (card->dev)
./s390/net/qeth_l3_sys.c:308:			memcpy(card->dev->perm_addr, card->options.hsuid, 9);
./s390/net/qeth_l3_sys.c:316:	snprintf(card->options.hsuid, sizeof(card->options.hsuid),
./s390/net/qeth_l3_sys.c:318:	ASCEBC(card->options.hsuid, 8);
./s390/net/qeth_l3_sys.c:319:	if (card->dev)
./s390/net/qeth_l3_sys.c:320:		memcpy(card->dev->perm_addr, card->options.hsuid, 9);
./s390/net/qeth_l3_sys.c:327:			addr->u.a6.addr.s6_addr[i] = card->options.hsuid[i - 8];
./s390/net/qeth_l3_sys.c:333:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:335:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:366:	return sprintf(buf, "%i\n", card->ipato.enabled? 1:0);
./s390/net/qeth_l3_sys.c:379:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:380:	if ((card->state != CARD_STATE_DOWN) &&
./s390/net/qeth_l3_sys.c:381:	    (card->state != CARD_STATE_RECOVER)) {
./s390/net/qeth_l3_sys.c:387:		enable = !card->ipato.enabled;
./s390/net/qeth_l3_sys.c:393:	if (card->ipato.enabled != enable) {
./s390/net/qeth_l3_sys.c:394:		card->ipato.enabled = enable;
./s390/net/qeth_l3_sys.c:395:		spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:397:		spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:400:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:416:	return sprintf(buf, "%i\n", card->ipato.invert4? 1:0);
./s390/net/qeth_l3_sys.c:430:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:432:		invert = !card->ipato.invert4;
./s390/net/qeth_l3_sys.c:438:	if (card->ipato.invert4 != invert) {
./s390/net/qeth_l3_sys.c:439:		card->ipato.invert4 = invert;
./s390/net/qeth_l3_sys.c:440:		spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:442:		spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:445:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:464:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:465:	list_for_each_entry(ipatoe, &card->ipato.entries, entry) {
./s390/net/qeth_l3_sys.c:477:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:529:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:547:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:573:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:577:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:603:	return sprintf(buf, "%i\n", card->ipato.invert6? 1:0);
./s390/net/qeth_l3_sys.c:616:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:618:		invert = !card->ipato.invert6;
./s390/net/qeth_l3_sys.c:624:	if (card->ipato.invert6 != invert) {
./s390/net/qeth_l3_sys.c:625:		card->ipato.invert6 = invert;
./s390/net/qeth_l3_sys.c:626:		spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:628:		spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:631:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:707:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:708:	hash_for_each(card->ip_htable, i, ipaddr, hnode) {
./s390/net/qeth_l3_sys.c:723:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:755:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:759:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:784:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:788:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:870:	spin_lock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:871:	hash_for_each(card->ip_htable, i, ipaddr, hnode) {
./s390/net/qeth_l3_sys.c:886:	spin_unlock_bh(&card->ip_lock);
./s390/net/qeth_l3_sys.c:935:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:939:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:964:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l3_sys.c:968:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:25:	switch (card->state) {
./s390/net/qeth_core_sys.c:33:		if (card->lan_online)
./s390/net/qeth_core_sys.c:53:	return sprintf(buf, "%02X\n", card->info.chpid);
./s390/net/qeth_core_sys.c:83:	if (card->qdio.in_buf_size == 16384)
./s390/net/qeth_core_sys.c:85:	else if (card->qdio.in_buf_size == 24576)
./s390/net/qeth_core_sys.c:87:	else if (card->qdio.in_buf_size == 32768)
./s390/net/qeth_core_sys.c:89:	else if (card->qdio.in_buf_size == 40960)
./s390/net/qeth_core_sys.c:114:	return sprintf(buf, "%i\n", card->info.portno);
./s390/net/qeth_core_sys.c:128:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:129:	if ((card->state != CARD_STATE_DOWN) &&
./s390/net/qeth_core_sys.c:130:	    (card->state != CARD_STATE_RECOVER)) {
./s390/net/qeth_core_sys.c:140:	limit = (card->ssqd.pcnt ? card->ssqd.pcnt - 1 : card->ssqd.pcnt);
./s390/net/qeth_core_sys.c:145:	card->info.portno = portno;
./s390/net/qeth_core_sys.c:147:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:164:	dev_warn_once(&card->gdev->dev,
./s390/net/qeth_core_sys.c:180:	switch (card->qdio.do_prio_queueing) {
./s390/net/qeth_core_sys.c:191:			       card->qdio.default_out_queue);
./s390/net/qeth_core_sys.c:204:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:205:	if ((card->state != CARD_STATE_DOWN) &&
./s390/net/qeth_core_sys.c:206:	    (card->state != CARD_STATE_RECOVER)) {
./s390/net/qeth_core_sys.c:214:	if (card->qdio.no_out_queues == 1) {
./s390/net/qeth_core_sys.c:215:		card->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;
./s390/net/qeth_core_sys.c:221:		card->qdio.do_prio_queueing = QETH_PRIO_Q_ING_PREC;
./s390/net/qeth_core_sys.c:222:		card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
./s390/net/qeth_core_sys.c:224:		card->qdio.do_prio_queueing = QETH_PRIO_Q_ING_SKB;
./s390/net/qeth_core_sys.c:225:		card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
./s390/net/qeth_core_sys.c:227:		card->qdio.do_prio_queueing = QETH_PRIO_Q_ING_TOS;
./s390/net/qeth_core_sys.c:228:		card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
./s390/net/qeth_core_sys.c:230:		if (!card->options.layer2) {
./s390/net/qeth_core_sys.c:234:		card->qdio.do_prio_queueing = QETH_PRIO_Q_ING_VLAN;
./s390/net/qeth_core_sys.c:235:		card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
./s390/net/qeth_core_sys.c:237:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./s390/net/qeth_core_sys.c:238:		card->qdio.default_out_queue = 0;
./s390/net/qeth_core_sys.c:240:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./s390/net/qeth_core_sys.c:241:		card->qdio.default_out_queue = 1;
./s390/net/qeth_core_sys.c:243:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./s390/net/qeth_core_sys.c:244:		card->qdio.default_out_queue = 2;
./s390/net/qeth_core_sys.c:246:		if (card->info.type == QETH_CARD_TYPE_IQD) {
./s390/net/qeth_core_sys.c:250:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./s390/net/qeth_core_sys.c:251:		card->qdio.default_out_queue = 3;
./s390/net/qeth_core_sys.c:253:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./s390/net/qeth_core_sys.c:254:		card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
./s390/net/qeth_core_sys.c:258:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:273:	return sprintf(buf, "%i\n", card->qdio.in_buf_pool.buf_count);
./s390/net/qeth_core_sys.c:287:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:288:	if ((card->state != CARD_STATE_DOWN) &&
./s390/net/qeth_core_sys.c:289:	    (card->state != CARD_STATE_RECOVER)) {
./s390/net/qeth_core_sys.c:294:	old_cnt = card->qdio.in_buf_pool.buf_count;
./s390/net/qeth_core_sys.c:302:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:319:	if (card->state != CARD_STATE_UP)
./s390/net/qeth_core_sys.c:339:	return sprintf(buf, "%i\n", card->options.performance_stats ? 1:0);
./s390/net/qeth_core_sys.c:352:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:355:		if (i == card->options.performance_stats)
./s390/net/qeth_core_sys.c:357:		card->options.performance_stats = i;
./s390/net/qeth_core_sys.c:359:			memset(&card->perf_stats, 0,
./s390/net/qeth_core_sys.c:361:		card->perf_stats.initial_rx_packets = card->stats.rx_packets;
./s390/net/qeth_core_sys.c:362:		card->perf_stats.initial_tx_packets = card->stats.tx_packets;
./s390/net/qeth_core_sys.c:366:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:381:	return sprintf(buf, "%i\n", card->options.layer2);
./s390/net/qeth_core_sys.c:395:	mutex_lock(&card->discipline_mutex);
./s390/net/qeth_core_sys.c:396:	if (card->state != CARD_STATE_DOWN) {
./s390/net/qeth_core_sys.c:414:	if (card->options.layer2 == newdis)
./s390/net/qeth_core_sys.c:416:	if (card->info.layer_enforced) {
./s390/net/qeth_core_sys.c:422:	card->info.mac_bits = 0;
./s390/net/qeth_core_sys.c:423:	if (card->discipline) {
./s390/net/qeth_core_sys.c:424:		card->discipline->remove(card->gdev);
./s390/net/qeth_core_sys.c:426:		card->options.layer2 = -1;
./s390/net/qeth_core_sys.c:433:	rc = card->discipline->setup(card->gdev);
./s390/net/qeth_core_sys.c:437:	mutex_unlock(&card->discipline_mutex);
./s390/net/qeth_core_sys.c:456:	switch (card->options.isolation) {
./s390/net/qeth_core_sys.c:478:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:480:	if (card->info.type != QETH_CARD_TYPE_OSD &&
./s390/net/qeth_core_sys.c:481:	    card->info.type != QETH_CARD_TYPE_OSX &&
./s390/net/qeth_core_sys.c:482:	    card->info.type != QETH_CARD_TYPE_UNKNOWN) {
./s390/net/qeth_core_sys.c:484:		dev_err(&card->gdev->dev, "Adapter does not "
./s390/net/qeth_core_sys.c:503:	card->options.prev_isolation = card->options.isolation;
./s390/net/qeth_core_sys.c:504:	card->options.isolation = isolation;
./s390/net/qeth_core_sys.c:511:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:560:	if (card->info.hwtrap)
./s390/net/qeth_core_sys.c:576:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:580:	if (sysfs_streq(buf, "arm") && !card->info.hwtrap) {
./s390/net/qeth_core_sys.c:586:					card->info.hwtrap = 1;
./s390/net/qeth_core_sys.c:590:			card->info.hwtrap = 1;
./s390/net/qeth_core_sys.c:591:	} else if (sysfs_streq(buf, "disarm") && card->info.hwtrap) {
./s390/net/qeth_core_sys.c:595:				card->info.hwtrap = 0;
./s390/net/qeth_core_sys.c:597:			card->info.hwtrap = 0;
./s390/net/qeth_core_sys.c:598:	} else if (sysfs_streq(buf, "trap") && state && card->info.hwtrap)
./s390/net/qeth_core_sys.c:603:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:628:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:629:	if ((card->state != CARD_STATE_DOWN) &&
./s390/net/qeth_core_sys.c:630:	    (card->state != CARD_STATE_RECOVER)) {
./s390/net/qeth_core_sys.c:640:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_core_sys.c:649:	return qeth_dev_blkt_show(buf, card, card->info.blkt.time_total);
./s390/net/qeth_core_sys.c:658:				   &card->info.blkt.time_total, 5000);
./s390/net/qeth_core_sys.c:671:	return qeth_dev_blkt_show(buf, card, card->info.blkt.inter_packet);
./s390/net/qeth_core_sys.c:680:				   &card->info.blkt.inter_packet, 1000);
./s390/net/qeth_core_sys.c:692:				  card->info.blkt.inter_packet_jumbo);
./s390/net/qeth_core_sys.c:701:				   &card->info.blkt.inter_packet_jumbo, 1000);
./s390/net/qeth_core_main.c:86:	return (card->state == CARD_STATE_SOFTSETUP) ||
./s390/net/qeth_core_main.c:87:		(card->state == CARD_STATE_UP);
./s390/net/qeth_core_main.c:98:	dev_close(card->dev);
./s390/net/qeth_core_main.c:100:	ccwgroup_set_offline(card->gdev);
./s390/net/qeth_core_main.c:106:	queue_work(qeth_wq, &card->close_dev_work);
./s390/net/qeth_core_main.c:112:	if (card->info.guestlan) {
./s390/net/qeth_core_main.c:113:		switch (card->info.type) {
./s390/net/qeth_core_main.c:126:		switch (card->info.type) {
./s390/net/qeth_core_main.c:147:	if (card->info.guestlan) {
./s390/net/qeth_core_main.c:148:		switch (card->info.type) {
./s390/net/qeth_core_main.c:161:		switch (card->info.type) {
./s390/net/qeth_core_main.c:163:			switch (card->info.link_type) {
./s390/net/qeth_core_main.c:200:	card->recovery_task = current;
./s390/net/qeth_core_main.c:206:	card->recovery_task = NULL;
./s390/net/qeth_core_main.c:212:	return card->recovery_task == current;
./s390/net/qeth_core_main.c:220:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:221:	card->thread_allowed_mask = threads;
./s390/net/qeth_core_main.c:223:		card->thread_start_mask &= threads;
./s390/net/qeth_core_main.c:224:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:225:	wake_up(&card->wait_q);
./s390/net/qeth_core_main.c:234:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:235:	rc = (card->thread_running_mask & threads);
./s390/net/qeth_core_main.c:236:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:245:	return wait_event_interruptible(card->wait_q,
./s390/net/qeth_core_main.c:256:			    &card->qdio.in_buf_pool.entry_list, list){
./s390/net/qeth_core_main.c:269:	for (i = 0; i < card->qdio.init_pool.buf_count; ++i) {
./s390/net/qeth_core_main.c:288:			 &card->qdio.init_pool.entry_list);
./s390/net/qeth_core_main.c:297:	if ((card->state != CARD_STATE_DOWN) &&
./s390/net/qeth_core_main.c:298:	    (card->state != CARD_STATE_RECOVER))
./s390/net/qeth_core_main.c:304:	card->qdio.in_buf_pool.buf_count = bufcnt;
./s390/net/qeth_core_main.c:305:	card->qdio.init_pool.buf_count = bufcnt;
./s390/net/qeth_core_main.c:343:	if (card->options.cq == QETH_CQ_ENABLED) {
./s390/net/qeth_core_main.c:345:		qdio_reset_buffers(card->qdio.c_q->qdio_bufs,
./s390/net/qeth_core_main.c:347:		card->qdio.c_q->next_buf_to_init = 127;
./s390/net/qeth_core_main.c:349:			     card->qdio.no_in_queues - 1, 0,
./s390/net/qeth_core_main.c:365:	if (card->options.cq == QETH_CQ_ENABLED) {
./s390/net/qeth_core_main.c:370:		card->qdio.c_q = qeth_alloc_qdio_queue();
./s390/net/qeth_core_main.c:371:		if (!card->qdio.c_q) {
./s390/net/qeth_core_main.c:375:		card->qdio.no_in_queues = 2;
./s390/net/qeth_core_main.c:376:		card->qdio.out_bufstates =
./s390/net/qeth_core_main.c:377:			kzalloc(card->qdio.no_out_queues *
./s390/net/qeth_core_main.c:380:		outbuf_states = card->qdio.out_bufstates;
./s390/net/qeth_core_main.c:385:		for (i = 0; i < card->qdio.no_out_queues; ++i) {
./s390/net/qeth_core_main.c:386:			card->qdio.out_qs[i]->bufstates = outbuf_states;
./s390/net/qeth_core_main.c:391:		card->qdio.c_q = NULL;
./s390/net/qeth_core_main.c:392:		card->qdio.no_in_queues = 1;
./s390/net/qeth_core_main.c:394:	QETH_DBF_TEXT_(SETUP, 2, "iqc%d", card->qdio.no_in_queues);
./s390/net/qeth_core_main.c:399:	qeth_free_qdio_queue(card->qdio.c_q);
./s390/net/qeth_core_main.c:400:	card->qdio.c_q = NULL;
./s390/net/qeth_core_main.c:402:	dev_err(&card->gdev->dev, "Failed to create completion queue\n");
./s390/net/qeth_core_main.c:408:	if (card->qdio.c_q) {
./s390/net/qeth_core_main.c:409:		--card->qdio.no_in_queues;
./s390/net/qeth_core_main.c:410:		qeth_free_qdio_queue(card->qdio.c_q);
./s390/net/qeth_core_main.c:411:		card->qdio.c_q = NULL;
./s390/net/qeth_core_main.c:413:	kfree(card->qdio.out_bufstates);
./s390/net/qeth_core_main.c:414:	card->qdio.out_bufstates = NULL;
./s390/net/qeth_core_main.c:445:	if (q->card->options.cq != QETH_CQ_ENABLED)
./s390/net/qeth_core_main.c:524:	return card->options.cq == QETH_CQ_ENABLED &&
./s390/net/qeth_core_main.c:525:	    card->qdio.c_q != NULL &&
./s390/net/qeth_core_main.c:527:	    queue == card->qdio.no_in_queues - 1;
./s390/net/qeth_core_main.c:536:	if (card->read.state != CH_STATE_UP)
./s390/net/qeth_core_main.c:538:	iob = qeth_get_buffer(&card->read);
./s390/net/qeth_core_main.c:540:		dev_warn(&card->gdev->dev, "The qeth device driver "
./s390/net/qeth_core_main.c:543:			"available\n", dev_name(&card->gdev->dev));
./s390/net/qeth_core_main.c:546:	qeth_setup_ccw(&card->read, iob->data, QETH_BUFSIZE);
./s390/net/qeth_core_main.c:548:	rc = ccw_device_start(card->read.ccwdev, &card->read.ccw,
./s390/net/qeth_core_main.c:552:			"rc=%i\n", dev_name(&card->gdev->dev), rc);
./s390/net/qeth_core_main.c:553:		atomic_set(&card->read.irq_pending, 0);
./s390/net/qeth_core_main.c:554:		card->read_or_write_problem = 1;
./s390/net/qeth_core_main.c:556:		wake_up(&card->wait_q);
./s390/net/qeth_core_main.c:607:				ipa_name, com, dev_name(&card->gdev->dev),
./s390/net/qeth_core_main.c:612:				ipa_name, com, dev_name(&card->gdev->dev),
./s390/net/qeth_core_main.c:637:					dev_err(&card->gdev->dev,
./s390/net/qeth_core_main.c:644:					dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:648:					   card->info.chpid);
./s390/net/qeth_core_main.c:652:				card->lan_online = 0;
./s390/net/qeth_core_main.c:653:				if (card->dev && netif_carrier_ok(card->dev))
./s390/net/qeth_core_main.c:654:					netif_carrier_off(card->dev);
./s390/net/qeth_core_main.c:657:				dev_info(&card->gdev->dev,
./s390/net/qeth_core_main.c:661:					   card->info.chpid);
./s390/net/qeth_core_main.c:662:				netif_carrier_on(card->dev);
./s390/net/qeth_core_main.c:663:				card->lan_online = 1;
./s390/net/qeth_core_main.c:664:				if (card->info.hwtrap)
./s390/net/qeth_core_main.c:665:					card->info.hwtrap = 2;
./s390/net/qeth_core_main.c:671:				if (card->discipline->control_event_handler
./s390/net/qeth_core_main.c:701:	spin_lock_irqsave(&card->lock, flags);
./s390/net/qeth_core_main.c:702:	list_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {
./s390/net/qeth_core_main.c:710:	spin_unlock_irqrestore(&card->lock, flags);
./s390/net/qeth_core_main.c:711:	atomic_set(&card->write.irq_pending, 0);
./s390/net/qeth_core_main.c:732:			dev_err(&card->gdev->dev,
./s390/net/qeth_core_main.c:756:	if (channel == &card->read)
./s390/net/qeth_core_main.c:856:	if ((cmd == NULL) && (card->state != CARD_STATE_DOWN))
./s390/net/qeth_core_main.c:859:	if (card->info.type == QETH_CARD_TYPE_OSN &&
./s390/net/qeth_core_main.c:862:	    card->osn_info.assist_cb != NULL) {
./s390/net/qeth_core_main.c:863:		card->osn_info.assist_cb(card->dev, cmd);
./s390/net/qeth_core_main.c:867:	spin_lock_irqsave(&card->lock, flags);
./s390/net/qeth_core_main.c:868:	list_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {
./s390/net/qeth_core_main.c:873:			spin_unlock_irqrestore(&card->lock, flags);
./s390/net/qeth_core_main.c:892:				spin_lock_irqsave(&card->lock, flags);
./s390/net/qeth_core_main.c:894:					      &card->cmd_waiter_list);
./s390/net/qeth_core_main.c:895:				spin_unlock_irqrestore(&card->lock, flags);
./s390/net/qeth_core_main.c:904:	spin_unlock_irqrestore(&card->lock, flags);
./s390/net/qeth_core_main.c:906:	memcpy(&card->seqno.pdu_hdr_ack,
./s390/net/qeth_core_main.c:946:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:947:	if (!(card->thread_allowed_mask & thread) ||
./s390/net/qeth_core_main.c:948:	      (card->thread_start_mask & thread)) {
./s390/net/qeth_core_main.c:949:		spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:952:	card->thread_start_mask |= thread;
./s390/net/qeth_core_main.c:953:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:961:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:962:	card->thread_start_mask &= ~thread;
./s390/net/qeth_core_main.c:963:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:964:	wake_up(&card->wait_q);
./s390/net/qeth_core_main.c:972:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:973:	card->thread_running_mask &= ~thread;
./s390/net/qeth_core_main.c:974:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:975:	wake_up_all(&card->wait_q);
./s390/net/qeth_core_main.c:984:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:985:	if (card->thread_start_mask & thread) {
./s390/net/qeth_core_main.c:986:		if ((card->thread_allowed_mask & thread) &&
./s390/net/qeth_core_main.c:987:		    !(card->thread_running_mask & thread)) {
./s390/net/qeth_core_main.c:989:			card->thread_start_mask &= ~thread;
./s390/net/qeth_core_main.c:990:			card->thread_running_mask |= thread;
./s390/net/qeth_core_main.c:994:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:1002:	wait_event(card->wait_q,
./s390/net/qeth_core_main.c:1012:		schedule_work(&card->kernel_thread_starter);
./s390/net/qeth_core_main.c:1088:			if (card->data.ccwdev == cdev) {
./s390/net/qeth_core_main.c:1089:				card->data.state = CH_STATE_DOWN;
./s390/net/qeth_core_main.c:1090:				wake_up(&card->wait_q);
./s390/net/qeth_core_main.c:1125:	if (card->read.ccwdev == cdev) {
./s390/net/qeth_core_main.c:1126:		channel = &card->read;
./s390/net/qeth_core_main.c:1128:	} else if (card->write.ccwdev == cdev) {
./s390/net/qeth_core_main.c:1129:		channel = &card->write;
./s390/net/qeth_core_main.c:1132:		channel = &card->data;
./s390/net/qeth_core_main.c:1144:	if ((channel == &card->data) && (intparm != 0) &&
./s390/net/qeth_core_main.c:1179:			card->read_or_write_problem = 1;
./s390/net/qeth_core_main.c:1194:	if (channel == &card->data)
./s390/net/qeth_core_main.c:1196:	if (channel == &card->read &&
./s390/net/qeth_core_main.c:1210:	wake_up(&card->wait_q);
./s390/net/qeth_core_main.c:1321:	for (i = 0; i < card->qdio.no_out_queues; ++i) {
./s390/net/qeth_core_main.c:1322:		if (card->qdio.out_qs[i]) {
./s390/net/qeth_core_main.c:1323:			qeth_clear_outq_buffers(card->qdio.out_qs[i], 0);
./s390/net/qeth_core_main.c:1334:				 &card->qdio.init_pool.entry_list, init_list){
./s390/net/qeth_core_main.c:1353:	if ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&
./s390/net/qeth_core_main.c:1354:	    (card->qdio.no_out_queues == 4))
./s390/net/qeth_core_main.c:1357:	card->qdio.no_out_queues = 1;
./s390/net/qeth_core_main.c:1358:	if (card->qdio.default_out_queue != 0)
./s390/net/qeth_core_main.c:1359:		dev_info(&card->gdev->dev, "Priority Queueing not supported\n");
./s390/net/qeth_core_main.c:1361:	card->qdio.default_out_queue = 0;
./s390/net/qeth_core_main.c:1366:	if ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&
./s390/net/qeth_core_main.c:1367:	    (card->qdio.no_out_queues == 1)) {
./s390/net/qeth_core_main.c:1369:		card->qdio.default_out_queue = 2;
./s390/net/qeth_core_main.c:1371:	card->qdio.no_out_queues = 4;
./s390/net/qeth_core_main.c:1381:	ccwdev = card->data.ccwdev;
./s390/net/qeth_core_main.c:1386:	card->info.func_level = 0x4100 + chp_dsc->desc;
./s390/net/qeth_core_main.c:1387:	if (card->info.type == QETH_CARD_TYPE_IQD)
./s390/net/qeth_core_main.c:1397:	QETH_DBF_TEXT_(SETUP, 2, "nr:%x", card->qdio.no_out_queues);
./s390/net/qeth_core_main.c:1398:	QETH_DBF_TEXT_(SETUP, 2, "lvl:%02x", card->info.func_level);
./s390/net/qeth_core_main.c:1404:	atomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);
./s390/net/qeth_core_main.c:1406:	card->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;
./s390/net/qeth_core_main.c:1407:	if (card->info.type == QETH_CARD_TYPE_IQD)
./s390/net/qeth_core_main.c:1408:		card->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_HSDEFAULT;
./s390/net/qeth_core_main.c:1410:		card->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_DEFAULT;
./s390/net/qeth_core_main.c:1411:	card->qdio.in_buf_pool.buf_count = card->qdio.init_pool.buf_count;
./s390/net/qeth_core_main.c:1412:	INIT_LIST_HEAD(&card->qdio.in_buf_pool.entry_list);
./s390/net/qeth_core_main.c:1413:	INIT_LIST_HEAD(&card->qdio.init_pool.entry_list);
./s390/net/qeth_core_main.c:1418:	card->options.route4.type = NO_ROUTER;
./s390/net/qeth_core_main.c:1419:	card->options.route6.type = NO_ROUTER;
./s390/net/qeth_core_main.c:1420:	card->options.fake_broadcast = 0;
./s390/net/qeth_core_main.c:1421:	card->options.performance_stats = 0;
./s390/net/qeth_core_main.c:1422:	card->options.rx_sg_cb = QETH_RX_SG_CB;
./s390/net/qeth_core_main.c:1423:	card->options.isolation = ISOLATION_MODE_NONE;
./s390/net/qeth_core_main.c:1424:	card->options.cq = QETH_CQ_DISABLED;
./s390/net/qeth_core_main.c:1432:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:1434:			(u8) card->thread_start_mask,
./s390/net/qeth_core_main.c:1435:			(u8) card->thread_allowed_mask,
./s390/net/qeth_core_main.c:1436:			(u8) card->thread_running_mask);
./s390/net/qeth_core_main.c:1437:	rc = (card->thread_start_mask & thread);
./s390/net/qeth_core_main.c:1438:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./s390/net/qeth_core_main.c:1449:	if (card->read.state != CH_STATE_UP &&
./s390/net/qeth_core_main.c:1450:	    card->write.state != CH_STATE_UP)
./s390/net/qeth_core_main.c:1453:		ts = kthread_run(card->discipline->recover, (void *)card,
./s390/net/qeth_core_main.c:1470:	card->read.state  = CH_STATE_DOWN;
./s390/net/qeth_core_main.c:1471:	card->write.state = CH_STATE_DOWN;
./s390/net/qeth_core_main.c:1472:	card->data.state  = CH_STATE_DOWN;
./s390/net/qeth_core_main.c:1473:	card->state = CARD_STATE_DOWN;
./s390/net/qeth_core_main.c:1474:	card->lan_online = 0;
./s390/net/qeth_core_main.c:1475:	card->read_or_write_problem = 0;
./s390/net/qeth_core_main.c:1476:	card->dev = NULL;
./s390/net/qeth_core_main.c:1477:	spin_lock_init(&card->vlanlock);
./s390/net/qeth_core_main.c:1478:	spin_lock_init(&card->mclock);
./s390/net/qeth_core_main.c:1479:	spin_lock_init(&card->lock);
./s390/net/qeth_core_main.c:1480:	spin_lock_init(&card->ip_lock);
./s390/net/qeth_core_main.c:1481:	spin_lock_init(&card->thread_mask_lock);
./s390/net/qeth_core_main.c:1482:	mutex_init(&card->conf_mutex);
./s390/net/qeth_core_main.c:1483:	mutex_init(&card->discipline_mutex);
./s390/net/qeth_core_main.c:1484:	card->thread_start_mask = 0;
./s390/net/qeth_core_main.c:1485:	card->thread_allowed_mask = 0;
./s390/net/qeth_core_main.c:1486:	card->thread_running_mask = 0;
./s390/net/qeth_core_main.c:1487:	INIT_WORK(&card->kernel_thread_starter, qeth_start_kernel_thread);
./s390/net/qeth_core_main.c:1488:	INIT_LIST_HEAD(&card->cmd_waiter_list);
./s390/net/qeth_core_main.c:1489:	init_waitqueue_head(&card->wait_q);
./s390/net/qeth_core_main.c:1493:	INIT_LIST_HEAD(&card->ipato.entries);
./s390/net/qeth_core_main.c:1494:	card->ipato.enabled = false;
./s390/net/qeth_core_main.c:1495:	card->ipato.invert4 = false;
./s390/net/qeth_core_main.c:1496:	card->ipato.invert6 = false;
./s390/net/qeth_core_main.c:1499:	INIT_DELAYED_WORK(&card->buffer_reclaim_work, qeth_buffer_reclaim_work);
./s390/net/qeth_core_main.c:1500:	INIT_WORK(&card->close_dev_work, qeth_close_dev_handler);
./s390/net/qeth_core_main.c:1508:	if (card->info.mcl_level[0])
./s390/net/qeth_core_main.c:1510:			CARD_BUS_ID(card), card->info.mcl_level);
./s390/net/qeth_core_main.c:1522:	if (qeth_setup_channel(&card->read))
./s390/net/qeth_core_main.c:1524:	if (qeth_setup_channel(&card->write))
./s390/net/qeth_core_main.c:1526:	card->options.layer2 = -1;
./s390/net/qeth_core_main.c:1527:	card->qeth_service_level.seq_print = qeth_core_sl_print;
./s390/net/qeth_core_main.c:1528:	register_service_level(&card->qeth_service_level);
./s390/net/qeth_core_main.c:1532:	qeth_clean_channel(&card->read);
./s390/net/qeth_core_main.c:1545:	card->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;
./s390/net/qeth_core_main.c:1546:	card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
./s390/net/qeth_core_main.c:1552:			card->info.type = known_devices[i][QETH_DEV_MODEL_IND];
./s390/net/qeth_core_main.c:1553:			card->qdio.no_out_queues =
./s390/net/qeth_core_main.c:1555:			card->qdio.no_in_queues = 1;
./s390/net/qeth_core_main.c:1556:			card->info.is_multicast_different =
./s390/net/qeth_core_main.c:1563:	card->info.type = QETH_CARD_TYPE_UNKNOWN;
./s390/net/qeth_core_main.c:1564:	dev_err(&card->gdev->dev, "The adapter hardware is of an "
./s390/net/qeth_core_main.c:1583:	rc = wait_event_interruptible_timeout(card->wait_q,
./s390/net/qeth_core_main.c:1607:	rc = wait_event_interruptible_timeout(card->wait_q,
./s390/net/qeth_core_main.c:1621:	rc1 = qeth_halt_channel(&card->read);
./s390/net/qeth_core_main.c:1622:	rc2 = qeth_halt_channel(&card->write);
./s390/net/qeth_core_main.c:1623:	rc3 = qeth_halt_channel(&card->data);
./s390/net/qeth_core_main.c:1636:	rc1 = qeth_clear_channel(&card->read);
./s390/net/qeth_core_main.c:1637:	rc2 = qeth_clear_channel(&card->write);
./s390/net/qeth_core_main.c:1638:	rc3 = qeth_clear_channel(&card->data);
./s390/net/qeth_core_main.c:1664:	switch (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ESTABLISHED,
./s390/net/qeth_core_main.c:1667:		if (card->info.type == QETH_CARD_TYPE_IQD)
./s390/net/qeth_core_main.c:1675:		atomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);
./s390/net/qeth_core_main.c:1685:	card->state = CARD_STATE_DOWN;
./s390/net/qeth_core_main.c:1696:	struct qeth_channel *channel = &card->data;
./s390/net/qeth_core_main.c:1720:		wait_event(card->wait_q,
./s390/net/qeth_core_main.c:1741:	card->info.chpid = prcd[30];
./s390/net/qeth_core_main.c:1742:	card->info.unit_addr2 = prcd[31];
./s390/net/qeth_core_main.c:1743:	card->info.cula = prcd[63];
./s390/net/qeth_core_main.c:1744:	card->info.guestlan = ((prcd[0x10] == _ascebc['V']) &&
./s390/net/qeth_core_main.c:1751:	if (card->info.type == QETH_CARD_TYPE_OSM ||
./s390/net/qeth_core_main.c:1752:	    card->info.type == QETH_CARD_TYPE_OSN) {
./s390/net/qeth_core_main.c:1758:	if (card->info.guestlan && card->info.type == QETH_CARD_TYPE_IQD) {
./s390/net/qeth_core_main.c:1773:		card->info.blkt.time_total = 0;
./s390/net/qeth_core_main.c:1774:		card->info.blkt.inter_packet = 0;
./s390/net/qeth_core_main.c:1775:		card->info.blkt.inter_packet_jumbo = 0;
./s390/net/qeth_core_main.c:1777:		card->info.blkt.time_total = 250;
./s390/net/qeth_core_main.c:1778:		card->info.blkt.inter_packet = 5;
./s390/net/qeth_core_main.c:1779:		card->info.blkt.inter_packet_jumbo = 15;
./s390/net/qeth_core_main.c:1785:	card->token.issuer_rm_w = 0x00010103UL;
./s390/net/qeth_core_main.c:1786:	card->token.cm_filter_w = 0x00010108UL;
./s390/net/qeth_core_main.c:1787:	card->token.cm_connection_w = 0x0001010aUL;
./s390/net/qeth_core_main.c:1788:	card->token.ulp_filter_w = 0x0001010bUL;
./s390/net/qeth_core_main.c:1789:	card->token.ulp_connection_w = 0x0001010dUL;
./s390/net/qeth_core_main.c:1794:	switch (card->info.type) {
./s390/net/qeth_core_main.c:1796:		card->info.func_level =	QETH_IDX_FUNC_LEVEL_IQD;
./s390/net/qeth_core_main.c:1800:		card->info.func_level = QETH_IDX_FUNC_LEVEL_OSD;
./s390/net/qeth_core_main.c:1826:	wait_event(card->wait_q,
./s390/net/qeth_core_main.c:1838:		wake_up(&card->wait_q);
./s390/net/qeth_core_main.c:1841:	rc = wait_event_interruptible_timeout(card->wait_q,
./s390/net/qeth_core_main.c:1877:	if (channel == &card->write) {
./s390/net/qeth_core_main.c:1880:		       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);
./s390/net/qeth_core_main.c:1881:		card->seqno.trans_hdr++;
./s390/net/qeth_core_main.c:1885:		       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);
./s390/net/qeth_core_main.c:1887:	tmp = ((__u8)card->info.portno) | 0x80;
./s390/net/qeth_core_main.c:1890:	       &card->token.issuer_rm_w, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:1892:	       &card->info.func_level, sizeof(__u16));
./s390/net/qeth_core_main.c:1895:	temp = (card->info.cula << 8) + card->info.unit_addr2;
./s390/net/qeth_core_main.c:1898:	wait_event(card->wait_q,
./s390/net/qeth_core_main.c:1911:		wake_up(&card->wait_q);
./s390/net/qeth_core_main.c:1914:	rc = wait_event_interruptible_timeout(card->wait_q,
./s390/net/qeth_core_main.c:1955:			dev_err(&card->write.ccwdev->dev,
./s390/net/qeth_core_main.c:1961:				dev_name(&card->write.ccwdev->dev));
./s390/net/qeth_core_main.c:1965:	if ((temp & ~0x0100) != qeth_peer_func_level(card->info.func_level)) {
./s390/net/qeth_core_main.c:1968:			"0x%x)\n", dev_name(&card->write.ccwdev->dev),
./s390/net/qeth_core_main.c:1969:			card->info.func_level, temp);
./s390/net/qeth_core_main.c:1996:			dev_err(&card->write.ccwdev->dev,
./s390/net/qeth_core_main.c:2002:			dev_err(&card->read.ccwdev->dev,
./s390/net/qeth_core_main.c:2009:				dev_name(&card->read.ccwdev->dev));
./s390/net/qeth_core_main.c:2017:	if (temp != qeth_peer_func_level(card->info.func_level)) {
./s390/net/qeth_core_main.c:2020:			dev_name(&card->read.ccwdev->dev),
./s390/net/qeth_core_main.c:2021:			card->info.func_level, temp);
./s390/net/qeth_core_main.c:2024:	memcpy(&card->token.issuer_rm_r,
./s390/net/qeth_core_main.c:2027:	memcpy(&card->info.mcl_level[0],
./s390/net/qeth_core_main.c:2037:	qeth_setup_ccw(&card->write, iob->data, len);
./s390/net/qeth_core_main.c:2041:	       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);
./s390/net/qeth_core_main.c:2042:	card->seqno.trans_hdr++;
./s390/net/qeth_core_main.c:2044:	       &card->seqno.pdu_hdr, QETH_SEQ_NO_LENGTH);
./s390/net/qeth_core_main.c:2045:	card->seqno.pdu_hdr++;
./s390/net/qeth_core_main.c:2047:	       &card->seqno.pdu_hdr_ack, QETH_SEQ_NO_LENGTH);
./s390/net/qeth_core_main.c:2092:	if (card->read_or_write_problem) {
./s390/net/qeth_core_main.c:2106:	while (atomic_cmpxchg(&card->write.irq_pending, 0, 1)) ;
./s390/net/qeth_core_main.c:2110:		cmd->hdr.seqno = card->seqno.ipa++;
./s390/net/qeth_core_main.c:2119:	spin_lock_irqsave(&card->lock, flags);
./s390/net/qeth_core_main.c:2120:	list_add_tail(&reply->list, &card->cmd_waiter_list);
./s390/net/qeth_core_main.c:2121:	spin_unlock_irqrestore(&card->lock, flags);
./s390/net/qeth_core_main.c:2126:	spin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);
./s390/net/qeth_core_main.c:2127:	rc = ccw_device_start(card->write.ccwdev, &card->write.ccw,
./s390/net/qeth_core_main.c:2129:	spin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);
./s390/net/qeth_core_main.c:2133:			dev_name(&card->write.ccwdev->dev), rc);
./s390/net/qeth_core_main.c:2135:		spin_lock_irqsave(&card->lock, flags);
./s390/net/qeth_core_main.c:2138:		spin_unlock_irqrestore(&card->lock, flags);
./s390/net/qeth_core_main.c:2140:		atomic_set(&card->write.irq_pending, 0);
./s390/net/qeth_core_main.c:2141:		wake_up(&card->wait_q);
./s390/net/qeth_core_main.c:2168:	spin_lock_irqsave(&reply->card->lock, flags);
./s390/net/qeth_core_main.c:2170:	spin_unlock_irqrestore(&reply->card->lock, flags);
./s390/net/qeth_core_main.c:2173:	atomic_set(&card->write.irq_pending, 0);
./s390/net/qeth_core_main.c:2175:	card->write.buf_no = (card->write.buf_no + 1) % QETH_CMD_BUFFER_NO;
./s390/net/qeth_core_main.c:2190:	memcpy(&card->token.cm_filter_r,
./s390/net/qeth_core_main.c:2204:	iob = qeth_wait_for_buffer(&card->write);
./s390/net/qeth_core_main.c:2207:	       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2209:	       &card->token.cm_filter_w, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2225:	memcpy(&card->token.cm_connection_r,
./s390/net/qeth_core_main.c:2239:	iob = qeth_wait_for_buffer(&card->write);
./s390/net/qeth_core_main.c:2242:	       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2244:	       &card->token.cm_connection_w, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2246:	       &card->token.cm_filter_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2255:	switch (card->info.type) {
./s390/net/qeth_core_main.c:2259:		return card->info.max_mtu;
./s390/net/qeth_core_main.c:2261:		switch (card->info.link_type) {
./s390/net/qeth_core_main.c:2266:			return card->options.layer2 ? 1500 : 1492;
./s390/net/qeth_core_main.c:2270:		return card->options.layer2 ? 1500 : 1492;
./s390/net/qeth_core_main.c:2294:	switch (card->info.type) {
./s390/net/qeth_core_main.c:2300:			(mtu <= card->info.max_mtu));
./s390/net/qeth_core_main.c:2320:	memcpy(&card->token.ulp_filter_r,
./s390/net/qeth_core_main.c:2323:	if (card->info.type == QETH_CARD_TYPE_IQD) {
./s390/net/qeth_core_main.c:2331:		if (card->info.initial_mtu && (card->info.initial_mtu != mtu)) {
./s390/net/qeth_core_main.c:2333:			if (card->dev &&
./s390/net/qeth_core_main.c:2334:			    ((card->dev->mtu == card->info.initial_mtu) ||
./s390/net/qeth_core_main.c:2335:			     (card->dev->mtu > mtu)))
./s390/net/qeth_core_main.c:2336:				card->dev->mtu = mtu;
./s390/net/qeth_core_main.c:2339:		card->info.initial_mtu = mtu;
./s390/net/qeth_core_main.c:2340:		card->info.max_mtu = mtu;
./s390/net/qeth_core_main.c:2341:		card->qdio.in_buf_size = mtu + 2 * PAGE_SIZE;
./s390/net/qeth_core_main.c:2343:		card->info.max_mtu = *(__u16 *)QETH_ULP_ENABLE_RESP_MAX_MTU(
./s390/net/qeth_core_main.c:2345:		card->info.initial_mtu = min(card->info.max_mtu,
./s390/net/qeth_core_main.c:2347:		card->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;
./s390/net/qeth_core_main.c:2354:		card->info.link_type = link_type;
./s390/net/qeth_core_main.c:2356:		card->info.link_type = 0;
./s390/net/qeth_core_main.c:2357:	QETH_DBF_TEXT_(SETUP, 2, "link%d", card->info.link_type);
./s390/net/qeth_core_main.c:2371:	iob = qeth_wait_for_buffer(&card->write);
./s390/net/qeth_core_main.c:2375:		(__u8) card->info.portno;
./s390/net/qeth_core_main.c:2376:	if (card->options.layer2)
./s390/net/qeth_core_main.c:2377:		if (card->info.type == QETH_CARD_TYPE_OSN)
./s390/net/qeth_core_main.c:2386:	       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2388:	       &card->token.ulp_filter_w, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2403:	memcpy(&card->token.ulp_connection_r,
./s390/net/qeth_core_main.c:2409:		dev_err(&card->gdev->dev, "A connection could not be "
./s390/net/qeth_core_main.c:2426:	iob = qeth_wait_for_buffer(&card->write);
./s390/net/qeth_core_main.c:2430:	       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2432:	       &card->token.ulp_connection_w, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2434:	       &card->token.ulp_filter_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2438:	temp = (card->info.cula << 8) + card->info.unit_addr2;
./s390/net/qeth_core_main.c:2504:	if (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED,
./s390/net/qeth_core_main.c:2509:	card->qdio.in_q = qeth_alloc_qdio_queue();
./s390/net/qeth_core_main.c:2510:	if (!card->qdio.in_q)
./s390/net/qeth_core_main.c:2518:	card->qdio.out_qs =
./s390/net/qeth_core_main.c:2519:		kzalloc(card->qdio.no_out_queues *
./s390/net/qeth_core_main.c:2521:	if (!card->qdio.out_qs)
./s390/net/qeth_core_main.c:2523:	for (i = 0; i < card->qdio.no_out_queues; ++i) {
./s390/net/qeth_core_main.c:2524:		card->qdio.out_qs[i] = qeth_alloc_qdio_out_buf();
./s390/net/qeth_core_main.c:2525:		if (!card->qdio.out_qs[i])
./s390/net/qeth_core_main.c:2528:		QETH_DBF_HEX(SETUP, 2, &card->qdio.out_qs[i], sizeof(void *));
./s390/net/qeth_core_main.c:2529:		card->qdio.out_qs[i]->queue_no = i;
./s390/net/qeth_core_main.c:2532:			WARN_ON(card->qdio.out_qs[i]->bufs[j] != NULL);
./s390/net/qeth_core_main.c:2533:			if (qeth_init_qdio_out_buf(card->qdio.out_qs[i], j))
./s390/net/qeth_core_main.c:2548:				card->qdio.out_qs[i]->bufs[j]);
./s390/net/qeth_core_main.c:2549:		card->qdio.out_qs[i]->bufs[j] = NULL;
./s390/net/qeth_core_main.c:2553:		qeth_free_qdio_out_buf(card->qdio.out_qs[--i]);
./s390/net/qeth_core_main.c:2554:		qeth_clear_outq_buffers(card->qdio.out_qs[i], 1);
./s390/net/qeth_core_main.c:2556:	kfree(card->qdio.out_qs);
./s390/net/qeth_core_main.c:2557:	card->qdio.out_qs = NULL;
./s390/net/qeth_core_main.c:2561:	qeth_free_qdio_queue(card->qdio.in_q);
./s390/net/qeth_core_main.c:2562:	card->qdio.in_q = NULL;
./s390/net/qeth_core_main.c:2564:	atomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);
./s390/net/qeth_core_main.c:2572:	if (atomic_xchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED) ==
./s390/net/qeth_core_main.c:2577:	cancel_delayed_work_sync(&card->buffer_reclaim_work);
./s390/net/qeth_core_main.c:2579:		if (card->qdio.in_q->bufs[j].rx_skb)
./s390/net/qeth_core_main.c:2580:			dev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb);
./s390/net/qeth_core_main.c:2582:	qeth_free_qdio_queue(card->qdio.in_q);
./s390/net/qeth_core_main.c:2583:	card->qdio.in_q = NULL;
./s390/net/qeth_core_main.c:2587:	if (card->qdio.out_qs) {
./s390/net/qeth_core_main.c:2588:		for (i = 0; i < card->qdio.no_out_queues; ++i) {
./s390/net/qeth_core_main.c:2589:			qeth_clear_outq_buffers(card->qdio.out_qs[i], 1);
./s390/net/qeth_core_main.c:2590:			qeth_free_qdio_out_buf(card->qdio.out_qs[i]);
./s390/net/qeth_core_main.c:2592:		kfree(card->qdio.out_qs);
./s390/net/qeth_core_main.c:2593:		card->qdio.out_qs = NULL;
./s390/net/qeth_core_main.c:2617:	*((unsigned int *) (&param_field[20])) = card->info.blkt.time_total;
./s390/net/qeth_core_main.c:2618:	*((unsigned int *) (&param_field[24])) = card->info.blkt.inter_packet;
./s390/net/qeth_core_main.c:2620:		card->info.blkt.inter_packet_jumbo;
./s390/net/qeth_core_main.c:2636:	iob = qeth_wait_for_buffer(&card->write);
./s390/net/qeth_core_main.c:2640:	       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2642:	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2702:	qeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);
./s390/net/qeth_core_main.c:2709:	switch (card->info.type) {
./s390/net/qeth_core_main.c:2717:		if (!card->info.mcl_level[0]) {
./s390/net/qeth_core_main.c:2718:			sprintf(card->info.mcl_level, "%02x%02x",
./s390/net/qeth_core_main.c:2719:				card->info.mcl_level[2],
./s390/net/qeth_core_main.c:2720:				card->info.mcl_level[3]);
./s390/net/qeth_core_main.c:2725:		if ((card->info.guestlan) ||
./s390/net/qeth_core_main.c:2726:		    (card->info.mcl_level[0] & 0x80)) {
./s390/net/qeth_core_main.c:2727:			card->info.mcl_level[0] = (char) _ebcasc[(__u8)
./s390/net/qeth_core_main.c:2728:				card->info.mcl_level[0]];
./s390/net/qeth_core_main.c:2729:			card->info.mcl_level[1] = (char) _ebcasc[(__u8)
./s390/net/qeth_core_main.c:2730:				card->info.mcl_level[1]];
./s390/net/qeth_core_main.c:2731:			card->info.mcl_level[2] = (char) _ebcasc[(__u8)
./s390/net/qeth_core_main.c:2732:				card->info.mcl_level[2]];
./s390/net/qeth_core_main.c:2733:			card->info.mcl_level[3] = (char) _ebcasc[(__u8)
./s390/net/qeth_core_main.c:2734:				card->info.mcl_level[3]];
./s390/net/qeth_core_main.c:2735:			card->info.mcl_level[QETH_MCL_LENGTH] = 0;
./s390/net/qeth_core_main.c:2739:		memset(&card->info.mcl_level[0], 0, QETH_MCL_LENGTH + 1);
./s390/net/qeth_core_main.c:2741:	dev_info(&card->gdev->dev,
./s390/net/qeth_core_main.c:2744:		 (card->info.mcl_level[0]) ? " (level: " : "",
./s390/net/qeth_core_main.c:2745:		 (card->info.mcl_level[0]) ? card->info.mcl_level : "",
./s390/net/qeth_core_main.c:2746:		 (card->info.mcl_level[0]) ? ")" : "",
./s390/net/qeth_core_main.c:2758:			    &card->qdio.init_pool.entry_list, init_list) {
./s390/net/qeth_core_main.c:2771:	if (list_empty(&card->qdio.in_buf_pool.entry_list))
./s390/net/qeth_core_main.c:2774:	list_for_each(plh, &card->qdio.in_buf_pool.entry_list) {
./s390/net/qeth_core_main.c:2790:	entry = list_entry(card->qdio.in_buf_pool.entry_list.next,
./s390/net/qeth_core_main.c:2800:				if (card->options.performance_stats)
./s390/net/qeth_core_main.c:2801:					card->perf_stats.sg_alloc_page_rx++;
./s390/net/qeth_core_main.c:2815:	if ((card->options.cq == QETH_CQ_ENABLED) && (!buf->rx_skb)) {
./s390/net/qeth_core_main.c:2853:	qdio_reset_buffers(card->qdio.in_q->qdio_bufs,
./s390/net/qeth_core_main.c:2857:	for (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)
./s390/net/qeth_core_main.c:2858:		qeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);
./s390/net/qeth_core_main.c:2859:	card->qdio.in_q->next_buf_to_init =
./s390/net/qeth_core_main.c:2860:		card->qdio.in_buf_pool.buf_count - 1;
./s390/net/qeth_core_main.c:2862:		     card->qdio.in_buf_pool.buf_count - 1);
./s390/net/qeth_core_main.c:2875:	for (i = 0; i < card->qdio.no_out_queues; ++i) {
./s390/net/qeth_core_main.c:2876:		qdio_reset_buffers(card->qdio.out_qs[i]->qdio_bufs,
./s390/net/qeth_core_main.c:2879:			qeth_clear_output_buffer(card->qdio.out_qs[i],
./s390/net/qeth_core_main.c:2880:					card->qdio.out_qs[i]->bufs[j],
./s390/net/qeth_core_main.c:2883:		card->qdio.out_qs[i]->card = card;
./s390/net/qeth_core_main.c:2884:		card->qdio.out_qs[i]->next_buf_to_fill = 0;
./s390/net/qeth_core_main.c:2885:		card->qdio.out_qs[i]->do_pack = 0;
./s390/net/qeth_core_main.c:2886:		atomic_set(&card->qdio.out_qs[i]->used_buffers, 0);
./s390/net/qeth_core_main.c:2887:		atomic_set(&card->qdio.out_qs[i]->set_pci_flags_count, 0);
./s390/net/qeth_core_main.c:2888:		atomic_set(&card->qdio.out_qs[i]->state,
./s390/net/qeth_core_main.c:2913:	cmd->hdr.adapter_type = qeth_get_ipa_adp_type(card->info.link_type);
./s390/net/qeth_core_main.c:2914:	cmd->hdr.rel_adapter_no = (__u8) card->info.portno;
./s390/net/qeth_core_main.c:2915:	if (card->options.layer2)
./s390/net/qeth_core_main.c:2931:	iob = qeth_get_buffer(&card->write);
./s390/net/qeth_core_main.c:2936:		dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:2939:				 dev_name(&card->gdev->dev));
./s390/net/qeth_core_main.c:2952:	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:2972:	if (card->options.layer2)
./s390/net/qeth_core_main.c:2973:		if (card->info.type == QETH_CARD_TYPE_OSN)
./s390/net/qeth_core_main.c:3022:		card->info.link_type =
./s390/net/qeth_core_main.c:3024:		QETH_DBF_TEXT_(SETUP, 2, "lnk %d", card->info.link_type);
./s390/net/qeth_core_main.c:3026:	card->options.adp.supported_funcs =
./s390/net/qeth_core_main.c:3078:		card->options.ipa4.supported_funcs |= IPA_SETADAPTERPARMS;
./s390/net/qeth_core_main.c:3079:		card->options.ipa6.supported_funcs |= IPA_SETADAPTERPARMS;
./s390/net/qeth_core_main.c:3085:						dev_name(&card->gdev->dev),
./s390/net/qeth_core_main.c:3092:		card->options.ipa4.supported_funcs = cmd->hdr.ipa_supported;
./s390/net/qeth_core_main.c:3093:		card->options.ipa4.enabled_funcs = cmd->hdr.ipa_enabled;
./s390/net/qeth_core_main.c:3095:		card->options.ipa6.supported_funcs = cmd->hdr.ipa_supported;
./s390/net/qeth_core_main.c:3096:		card->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;
./s390/net/qeth_core_main.c:3099:					"\n", dev_name(&card->gdev->dev));
./s390/net/qeth_core_main.c:3145:	if (!netif_carrier_ok(card->dev))
./s390/net/qeth_core_main.c:3167:		card->info.diagass_support = cmd->data.diagass.ext;
./s390/net/qeth_core_main.c:3194:	tid->chpid = card->info.chpid;
./s390/net/qeth_core_main.c:3269:			card->stats.rx_dropped++;
./s390/net/qeth_core_main.c:3279:	struct qeth_qdio_q *queue = card->qdio.in_q;
./s390/net/qeth_core_main.c:3287:		card->qdio.in_buf_pool.buf_count -
./s390/net/qeth_core_main.c:3289:		card->qdio.in_buf_pool.buf_count -
./s390/net/qeth_core_main.c:3306:			atomic_set(&card->force_alloc_skb, 3);
./s390/net/qeth_core_main.c:3309:			atomic_add_unless(&card->force_alloc_skb, -1, 0);
./s390/net/qeth_core_main.c:3314:			list_for_each(lh, &card->qdio.in_buf_pool.entry_list)
./s390/net/qeth_core_main.c:3316:			if (i == card->qdio.in_buf_pool.buf_count) {
./s390/net/qeth_core_main.c:3318:				card->reclaim_index = index;
./s390/net/qeth_core_main.c:3320:					&card->buffer_reclaim_work,
./s390/net/qeth_core_main.c:3333:		if (card->options.performance_stats) {
./s390/net/qeth_core_main.c:3334:			card->perf_stats.inbound_do_qdio_cnt++;
./s390/net/qeth_core_main.c:3335:			card->perf_stats.inbound_do_qdio_start_time =
./s390/net/qeth_core_main.c:3340:		if (card->options.performance_stats)
./s390/net/qeth_core_main.c:3341:			card->perf_stats.inbound_do_qdio_time +=
./s390/net/qeth_core_main.c:3343:				card->perf_stats.inbound_do_qdio_start_time;
./s390/net/qeth_core_main.c:3357:	QETH_CARD_TEXT_(card, 2, "brw:%x", card->reclaim_index);
./s390/net/qeth_core_main.c:3358:	qeth_queue_input_buffer(card, card->reclaim_index);
./s390/net/qeth_core_main.c:3367:	if (card->info.type == QETH_CARD_TYPE_IQD) {
./s390/net/qeth_core_main.c:3420:			if (queue->card->options.performance_stats)
./s390/net/qeth_core_main.c:3421:				queue->card->perf_stats.sc_dp_p++;
./s390/net/qeth_core_main.c:3440:			if (queue->card->options.performance_stats)
./s390/net/qeth_core_main.c:3441:				queue->card->perf_stats.sc_p_dp++;
./s390/net/qeth_core_main.c:3466:		if (queue->card->info.type == QETH_CARD_TYPE_IQD)
./s390/net/qeth_core_main.c:3495:	netif_trans_update(queue->card->dev);
./s390/net/qeth_core_main.c:3496:	if (queue->card->options.performance_stats) {
./s390/net/qeth_core_main.c:3497:		queue->card->perf_stats.outbound_do_qdio_cnt++;
./s390/net/qeth_core_main.c:3498:		queue->card->perf_stats.outbound_do_qdio_start_time =
./s390/net/qeth_core_main.c:3508:	if (queue->card->options.performance_stats)
./s390/net/qeth_core_main.c:3509:		queue->card->perf_stats.outbound_do_qdio_time +=
./s390/net/qeth_core_main.c:3511:			queue->card->perf_stats.outbound_do_qdio_start_time;
./s390/net/qeth_core_main.c:3513:		queue->card->stats.tx_errors += count;
./s390/net/qeth_core_main.c:3528:	if (queue->card->options.performance_stats)
./s390/net/qeth_core_main.c:3529:		queue->card->perf_stats.bufs_sent += count;
./s390/net/qeth_core_main.c:3551:			netif_stop_queue(queue->card->dev);
./s390/net/qeth_core_main.c:3560:			if (queue->card->options.performance_stats &&
./s390/net/qeth_core_main.c:3562:				queue->card->perf_stats.bufs_sent_pack +=
./s390/net/qeth_core_main.c:3576:	if (card->dev && (card->dev->flags & IFF_UP))
./s390/net/qeth_core_main.c:3577:		napi_schedule(&card->napi);
./s390/net/qeth_core_main.c:3585:	if (card->options.cq ==  QETH_CQ_NOTAVAILABLE) {
./s390/net/qeth_core_main.c:3589:		if (card->options.cq == cq) {
./s390/net/qeth_core_main.c:3594:		if (card->state != CARD_STATE_DOWN &&
./s390/net/qeth_core_main.c:3595:		    card->state != CARD_STATE_RECOVER) {
./s390/net/qeth_core_main.c:3601:		card->options.cq = cq;
./s390/net/qeth_core_main.c:3614:	struct qeth_qdio_q *cq = card->qdio.c_q;
./s390/net/qeth_core_main.c:3626:		netif_stop_queue(card->dev);
./s390/net/qeth_core_main.c:3631:	if (card->options.performance_stats) {
./s390/net/qeth_core_main.c:3632:		card->perf_stats.cq_cnt++;
./s390/net/qeth_core_main.c:3633:		card->perf_stats.cq_start_time = qeth_get_micros();
./s390/net/qeth_core_main.c:3660:		    card->qdio.c_q->next_buf_to_init,
./s390/net/qeth_core_main.c:3663:		dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:3667:	card->qdio.c_q->next_buf_to_init = (card->qdio.c_q->next_buf_to_init
./s390/net/qeth_core_main.c:3670:	netif_wake_queue(card->dev);
./s390/net/qeth_core_main.c:3672:	if (card->options.performance_stats) {
./s390/net/qeth_core_main.c:3674:		delta_t -= card->perf_stats.cq_start_time;
./s390/net/qeth_core_main.c:3675:		card->perf_stats.cq_time += delta_t;
./s390/net/qeth_core_main.c:3704:	struct qeth_qdio_out_q *queue = card->qdio.out_qs[__queue];
./s390/net/qeth_core_main.c:3711:		netif_stop_queue(card->dev);
./s390/net/qeth_core_main.c:3715:	if (card->options.performance_stats) {
./s390/net/qeth_core_main.c:3716:		card->perf_stats.outbound_handler_cnt++;
./s390/net/qeth_core_main.c:3717:		card->perf_stats.outbound_handler_start_time =
./s390/net/qeth_core_main.c:3728:			WARN_ON_ONCE(card->options.cq != QETH_CQ_ENABLED);
./s390/net/qeth_core_main.c:3747:			if (card->options.cq == QETH_CQ_ENABLED) {
./s390/net/qeth_core_main.c:3762:	if (card->info.type != QETH_CARD_TYPE_IQD)
./s390/net/qeth_core_main.c:3765:	netif_wake_queue(queue->card->dev);
./s390/net/qeth_core_main.c:3766:	if (card->options.performance_stats)
./s390/net/qeth_core_main.c:3767:		card->perf_stats.outbound_handler_time += qeth_get_micros() -
./s390/net/qeth_core_main.c:3768:			card->perf_stats.outbound_handler_start_time;
./s390/net/qeth_core_main.c:3775:	if ((card->info.type == QETH_CARD_TYPE_IQD) && (queue_num == 3))
./s390/net/qeth_core_main.c:3789:	if (cast_type && card->info.is_multicast_different)
./s390/net/qeth_core_main.c:3790:		return card->info.is_multicast_different &
./s390/net/qeth_core_main.c:3791:			(card->qdio.no_out_queues - 1);
./s390/net/qeth_core_main.c:3793:	switch (card->qdio.do_prio_queueing) {
./s390/net/qeth_core_main.c:3804:			return card->qdio.default_out_queue;
./s390/net/qeth_core_main.c:3806:		if (card->qdio.do_prio_queueing == QETH_PRIO_Q_ING_PREC)
./s390/net/qeth_core_main.c:3830:	return card->qdio.default_out_queue;
./s390/net/qeth_core_main.c:4044:		if (queue->card->options.performance_stats)
./s390/net/qeth_core_main.c:4045:			queue->card->perf_stats.skbs_sent_pack++;
./s390/net/qeth_core_main.c:4174:	if (queue->card->options.performance_stats && do_pack)
./s390/net/qeth_core_main.c:4175:		queue->card->perf_stats.bufs_sent_pack += flush_count;
./s390/net/qeth_core_main.c:4194:	card->info.promisc_mode = setparms->data.mode;
./s390/net/qeth_core_main.c:4201:	struct net_device *dev = card->dev;
./s390/net/qeth_core_main.c:4208:	     (card->info.promisc_mode == SET_PROMISC_MODE_ON)) ||
./s390/net/qeth_core_main.c:4210:	     (card->info.promisc_mode == SET_PROMISC_MODE_OFF)))
./s390/net/qeth_core_main.c:4253:	return &card->stats;
./s390/net/qeth_core_main.c:4266:	if (!card->options.layer2 ||
./s390/net/qeth_core_main.c:4267:	    !(card->info.mac_bits & QETH_LAYER2_MAC_READ)) {
./s390/net/qeth_core_main.c:4268:		memcpy(card->dev->dev_addr,
./s390/net/qeth_core_main.c:4271:		card->info.mac_bits |= QETH_LAYER2_MAC_READ;
./s390/net/qeth_core_main.c:4293:	       card->dev->dev_addr, OSA_ADDR_LEN);
./s390/net/qeth_core_main.c:4314:	QETH_DBF_TEXT_(SETUP, 2, "%s", card->gdev->dev.kobj.name);
./s390/net/qeth_core_main.c:4320:				card->gdev->dev.kobj.name,
./s390/net/qeth_core_main.c:4325:		if (card->options.isolation == ISOLATION_MODE_NONE) {
./s390/net/qeth_core_main.c:4326:			dev_info(&card->gdev->dev,
./s390/net/qeth_core_main.c:4329:			dev_info(&card->gdev->dev,
./s390/net/qeth_core_main.c:4335:				"deactivated\n", dev_name(&card->gdev->dev));
./s390/net/qeth_core_main.c:4337:			card->options.isolation = card->options.prev_isolation;
./s390/net/qeth_core_main.c:4341:				" activated\n", dev_name(&card->gdev->dev));
./s390/net/qeth_core_main.c:4343:			card->options.isolation = card->options.prev_isolation;
./s390/net/qeth_core_main.c:4346:		dev_err(&card->gdev->dev, "Adapter does not "
./s390/net/qeth_core_main.c:4350:		dev_err(&card->gdev->dev,
./s390/net/qeth_core_main.c:4354:			card->options.isolation = card->options.prev_isolation;
./s390/net/qeth_core_main.c:4357:		dev_err(&card->gdev->dev,
./s390/net/qeth_core_main.c:4360:			card->options.isolation = card->options.prev_isolation;
./s390/net/qeth_core_main.c:4363:		dev_err(&card->gdev->dev, "The adjacent switch port does not "
./s390/net/qeth_core_main.c:4366:			card->options.isolation = card->options.prev_isolation;
./s390/net/qeth_core_main.c:4369:		dev_err(&card->gdev->dev, "The reflective relay mode cannot be "
./s390/net/qeth_core_main.c:4372:			card->options.isolation = card->options.prev_isolation;
./s390/net/qeth_core_main.c:4375:		dev_warn(&card->gdev->dev, "Turning off reflective relay mode "
./s390/net/qeth_core_main.c:4381:			card->options.isolation = card->options.prev_isolation;
./s390/net/qeth_core_main.c:4398:	QETH_DBF_TEXT_(SETUP, 2, "%s", card->gdev->dev.kobj.name);
./s390/net/qeth_core_main.c:4421:	if ((card->info.type == QETH_CARD_TYPE_OSD ||
./s390/net/qeth_core_main.c:4422:	     card->info.type == QETH_CARD_TYPE_OSX) &&
./s390/net/qeth_core_main.c:4425:			card->options.isolation, fallback);
./s390/net/qeth_core_main.c:4429:				card->gdev->dev.kobj.name,
./s390/net/qeth_core_main.c:4433:	} else if (card->options.isolation != ISOLATION_MODE_NONE) {
./s390/net/qeth_core_main.c:4434:		card->options.isolation = ISOLATION_MODE_NONE;
./s390/net/qeth_core_main.c:4436:		dev_err(&card->gdev->dev, "Adapter does not "
./s390/net/qeth_core_main.c:4450:	card->stats.tx_errors++;
./s390/net/qeth_core_main.c:4463:		if ((card->info.link_type != QETH_LINK_TYPE_GBIT_ETH) &&
./s390/net/qeth_core_main.c:4464:		    (card->info.link_type != QETH_LINK_TYPE_OSN) &&
./s390/net/qeth_core_main.c:4465:		    (card->info.link_type != QETH_LINK_TYPE_10GBIT_ETH))
./s390/net/qeth_core_main.c:4497:		rc = card->stats.rx_errors;
./s390/net/qeth_core_main.c:4531:	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
./s390/net/qeth_core_main.c:4615:	if (card->info.guestlan)
./s390/net/qeth_core_main.c:4619:	    (!card->options.layer2)) {
./s390/net/qeth_core_main.c:4818:	if (!card->dev)
./s390/net/qeth_core_main.c:4849:		ether_addr_copy(card->dev->dev_addr, response->mac);
./s390/net/qeth_core_main.c:4861:	if (card->info.type == QETH_CARD_TYPE_IQD)
./s390/net/qeth_core_main.c:4889:			dev_name(&card->gdev->dev), rc);
./s390/net/qeth_core_main.c:4898:	rc = qdio_get_ssqd_desc(ddev, &card->ssqd);
./s390/net/qeth_core_main.c:4902:	QETH_DBF_TEXT_(SETUP, 2, "qfmt%d", card->ssqd.qfmt);
./s390/net/qeth_core_main.c:4903:	QETH_DBF_TEXT_(SETUP, 2, "ac1:%02x", card->ssqd.qdioac1);
./s390/net/qeth_core_main.c:4904:	QETH_DBF_TEXT_(SETUP, 2, "ac2:%04x", card->ssqd.qdioac2);
./s390/net/qeth_core_main.c:4905:	QETH_DBF_TEXT_(SETUP, 2, "ac3:%04x", card->ssqd.qdioac3);
./s390/net/qeth_core_main.c:4906:	QETH_DBF_TEXT_(SETUP, 2, "icnt%d", card->ssqd.icnt);
./s390/net/qeth_core_main.c:4907:	if (!((card->ssqd.qfmt != QDIO_IQDIO_QFMT) ||
./s390/net/qeth_core_main.c:4908:	    ((card->ssqd.qdioac1 & CHSC_AC1_INITIATE_INPUTQ) == 0) ||
./s390/net/qeth_core_main.c:4909:	    ((card->ssqd.qdioac3 & CHSC_AC3_FORMAT2_CQ_AVAILABLE) == 0))) {
./s390/net/qeth_core_main.c:4910:		dev_info(&card->gdev->dev,
./s390/net/qeth_core_main.c:4913:		card->options.cq = QETH_CQ_NOTAVAILABLE;
./s390/net/qeth_core_main.c:4932:	if (card->options.cq == QETH_CQ_ENABLED) {
./s390/net/qeth_core_main.c:4934:			     (card->qdio.no_in_queues - 1);
./s390/net/qeth_core_main.c:4935:		i = QDIO_MAX_BUFFERS_PER_Q * (card->qdio.no_in_queues - 1);
./s390/net/qeth_core_main.c:4938:				virt_to_phys(card->qdio.c_q->bufs[i].buffer);
./s390/net/qeth_core_main.c:4941:		queue_start_poll[card->qdio.no_in_queues - 1] = NULL;
./s390/net/qeth_core_main.c:4967:	in_sbal_ptrs = kzalloc(card->qdio.no_in_queues *
./s390/net/qeth_core_main.c:4976:			virt_to_phys(card->qdio.in_q->bufs[i].buffer);
./s390/net/qeth_core_main.c:4979:	queue_start_poll = kzalloc(sizeof(void *) * card->qdio.no_in_queues,
./s390/net/qeth_core_main.c:4985:	for (i = 0; i < card->qdio.no_in_queues; ++i)
./s390/net/qeth_core_main.c:4986:		queue_start_poll[i] = card->discipline->start_poll;
./s390/net/qeth_core_main.c:4991:		kzalloc(card->qdio.no_out_queues * QDIO_MAX_BUFFERS_PER_Q *
./s390/net/qeth_core_main.c:4997:	for (i = 0, k = 0; i < card->qdio.no_out_queues; ++i)
./s390/net/qeth_core_main.c:5000:				card->qdio.out_qs[i]->bufs[j]->buffer);
./s390/net/qeth_core_main.c:5008:	init_data.no_input_qs            = card->qdio.no_in_queues;
./s390/net/qeth_core_main.c:5009:	init_data.no_output_qs           = card->qdio.no_out_queues;
./s390/net/qeth_core_main.c:5010:	init_data.input_handler 	 = card->discipline->input_handler;
./s390/net/qeth_core_main.c:5011:	init_data.output_handler	 = card->discipline->output_handler;
./s390/net/qeth_core_main.c:5016:	init_data.output_sbal_state_array = card->qdio.out_bufstates;
./s390/net/qeth_core_main.c:5018:		(card->info.type == QETH_CARD_TYPE_IQD) ? 1 : 32;
./s390/net/qeth_core_main.c:5020:	if (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ALLOCATED,
./s390/net/qeth_core_main.c:5024:			atomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);
./s390/net/qeth_core_main.c:5029:			atomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);
./s390/net/qeth_core_main.c:5034:	switch (card->options.cq) {
./s390/net/qeth_core_main.c:5036:		dev_info(&card->gdev->dev, "Completion Queue support enabled");
./s390/net/qeth_core_main.c:5039:		dev_info(&card->gdev->dev, "Completion Queue support disabled");
./s390/net/qeth_core_main.c:5061:	qeth_clean_channel(&card->read);
./s390/net/qeth_core_main.c:5062:	qeth_clean_channel(&card->write);
./s390/net/qeth_core_main.c:5064:	unregister_service_level(&card->qeth_service_level);
./s390/net/qeth_core_main.c:5071:	QETH_CARD_HEX(card, 2, &card->options.ipa4, sizeof(card->options.ipa4));
./s390/net/qeth_core_main.c:5072:	QETH_CARD_HEX(card, 2, &card->options.ipa6, sizeof(card->options.ipa6));
./s390/net/qeth_core_main.c:5073:	QETH_CARD_HEX(card, 2, &card->options.adp, sizeof(card->options.adp));
./s390/net/qeth_core_main.c:5074:	QETH_CARD_HEX(card, 2, &card->info.diagass_support,
./s390/net/qeth_core_main.c:5075:		      sizeof(card->info.diagass_support));
./s390/net/qeth_core_main.c:5110:	atomic_set(&card->force_alloc_skb, 0);
./s390/net/qeth_core_main.c:5115:			dev_name(&card->gdev->dev));
./s390/net/qeth_core_main.c:5116:	rc = qeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);
./s390/net/qeth_core_main.c:5144:	rc = qeth_idx_activate_channel(&card->read, qeth_idx_read_cb);
./s390/net/qeth_core_main.c:5155:	rc = qeth_idx_activate_channel(&card->write, qeth_idx_write_cb);
./s390/net/qeth_core_main.c:5166:	card->read_or_write_problem = 0;
./s390/net/qeth_core_main.c:5177:			dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:5179:			card->lan_online = 0;
./s390/net/qeth_core_main.c:5185:		card->lan_online = 1;
./s390/net/qeth_core_main.c:5187:	card->options.ipa4.supported_funcs = 0;
./s390/net/qeth_core_main.c:5188:	card->options.ipa6.supported_funcs = 0;
./s390/net/qeth_core_main.c:5189:	card->options.adp.supported_funcs = 0;
./s390/net/qeth_core_main.c:5190:	card->options.sbp.supported_funcs = 0;
./s390/net/qeth_core_main.c:5191:	card->info.diagass_support = 0;
./s390/net/qeth_core_main.c:5211:	dev_warn(&card->gdev->dev, "The qeth device driver failed to recover "
./s390/net/qeth_core_main.c:5214:		dev_name(&card->gdev->dev), rc);
./s390/net/qeth_core_main.c:5316:	if (((skb_len >= card->options.rx_sg_cb) &&
./s390/net/qeth_core_main.c:5317:	     (!(card->info.type == QETH_CARD_TYPE_OSN)) &&
./s390/net/qeth_core_main.c:5318:	     (!atomic_read(&card->force_alloc_skb))) ||
./s390/net/qeth_core_main.c:5319:	    (card->options.cq == QETH_CQ_ENABLED)) {
./s390/net/qeth_core_main.c:5347:				card->stats.rx_errors++;
./s390/net/qeth_core_main.c:5359:	if (use_rx_sg && card->options.performance_stats) {
./s390/net/qeth_core_main.c:5360:		card->perf_stats.sg_skbs_rx++;
./s390/net/qeth_core_main.c:5361:		card->perf_stats.sg_frags_rx += skb_shinfo(skb)->nr_frags;
./s390/net/qeth_core_main.c:5368:	card->stats.rx_dropped++;
./s390/net/qeth_core_main.c:5381:	if (card->options.performance_stats) {
./s390/net/qeth_core_main.c:5382:		card->perf_stats.inbound_cnt++;
./s390/net/qeth_core_main.c:5383:		card->perf_stats.inbound_start_time = qeth_get_micros();
./s390/net/qeth_core_main.c:5387:		if (!card->rx.b_count) {
./s390/net/qeth_core_main.c:5388:			card->rx.qdio_err = 0;
./s390/net/qeth_core_main.c:5389:			card->rx.b_count = qdio_get_next_buffers(
./s390/net/qeth_core_main.c:5390:				card->data.ccwdev, 0, &card->rx.b_index,
./s390/net/qeth_core_main.c:5391:				&card->rx.qdio_err);
./s390/net/qeth_core_main.c:5392:			if (card->rx.b_count <= 0) {
./s390/net/qeth_core_main.c:5393:				card->rx.b_count = 0;
./s390/net/qeth_core_main.c:5396:			card->rx.b_element =
./s390/net/qeth_core_main.c:5397:				&card->qdio.in_q->bufs[card->rx.b_index]
./s390/net/qeth_core_main.c:5399:			card->rx.e_offset = 0;
./s390/net/qeth_core_main.c:5402:		while (card->rx.b_count) {
./s390/net/qeth_core_main.c:5403:			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
./s390/net/qeth_core_main.c:5404:			if (!(card->rx.qdio_err &&
./s390/net/qeth_core_main.c:5406:			    card->rx.qdio_err, "qinerr")))
./s390/net/qeth_core_main.c:5408:					card->discipline->process_rx_buffer(
./s390/net/qeth_core_main.c:5414:				if (card->options.performance_stats)
./s390/net/qeth_core_main.c:5415:					card->perf_stats.bufs_rec++;
./s390/net/qeth_core_main.c:5418:				qeth_queue_input_buffer(card, card->rx.b_index);
./s390/net/qeth_core_main.c:5419:				card->rx.b_count--;
./s390/net/qeth_core_main.c:5420:				if (card->rx.b_count) {
./s390/net/qeth_core_main.c:5421:					card->rx.b_index =
./s390/net/qeth_core_main.c:5422:						(card->rx.b_index + 1) %
./s390/net/qeth_core_main.c:5424:					card->rx.b_element =
./s390/net/qeth_core_main.c:5425:						&card->qdio.in_q
./s390/net/qeth_core_main.c:5426:						->bufs[card->rx.b_index]
./s390/net/qeth_core_main.c:5428:					card->rx.e_offset = 0;
./s390/net/qeth_core_main.c:5440:	if (qdio_start_irq(card->data.ccwdev, 0))
./s390/net/qeth_core_main.c:5441:		napi_schedule(&card->napi);
./s390/net/qeth_core_main.c:5443:	if (card->options.performance_stats)
./s390/net/qeth_core_main.c:5444:		card->perf_stats.inbound_time += qeth_get_micros() -
./s390/net/qeth_core_main.c:5445:			card->perf_stats.inbound_start_time;
./s390/net/qeth_core_main.c:5468:			card->options.ipa4.enabled_funcs = cmd->hdr.ipa_enabled;
./s390/net/qeth_core_main.c:5470:			card->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;
./s390/net/qeth_core_main.c:5604:		card->discipline = try_then_request_module(
./s390/net/qeth_core_main.c:5608:		card->discipline = try_then_request_module(
./s390/net/qeth_core_main.c:5615:	if (!card->discipline) {
./s390/net/qeth_core_main.c:5616:		dev_err(&card->gdev->dev, "There is no kernel module to "
./s390/net/qeth_core_main.c:5626:	if (card->options.layer2)
./s390/net/qeth_core_main.c:5630:	card->discipline = NULL;
./s390/net/qeth_core_main.c:5675:	card->debug = debug_register(name, 2, 1, 8);
./s390/net/qeth_core_main.c:5676:	if (!card->debug) {
./s390/net/qeth_core_main.c:5680:	if (debug_register_view(card->debug, &debug_hex_ascii_view))
./s390/net/qeth_core_main.c:5686:	new_entry->dbf_info = card->debug;
./s390/net/qeth_core_main.c:5694:	debug_unregister(card->debug);
./s390/net/qeth_core_main.c:5738:	card->debug = qeth_get_dbf_entry(dbf_name);
./s390/net/qeth_core_main.c:5739:	if (!card->debug) {
./s390/net/qeth_core_main.c:5745:	card->read.ccwdev  = gdev->cdev[0];
./s390/net/qeth_core_main.c:5746:	card->write.ccwdev = gdev->cdev[1];
./s390/net/qeth_core_main.c:5747:	card->data.ccwdev  = gdev->cdev[2];
./s390/net/qeth_core_main.c:5749:	card->gdev = gdev;
./s390/net/qeth_core_main.c:5772:		card->info.layer_enforced = true;
./s390/net/qeth_core_main.c:5777:		gdev->dev.type = (card->info.type != QETH_CARD_TYPE_OSN)
./s390/net/qeth_core_main.c:5778:					? card->discipline->devtype
./s390/net/qeth_core_main.c:5780:		rc = card->discipline->setup(card->gdev);
./s390/net/qeth_core_main.c:5787:	list_add_tail(&card->list, &qeth_core_card_list.list);
./s390/net/qeth_core_main.c:5807:	if (card->discipline) {
./s390/net/qeth_core_main.c:5808:		card->discipline->remove(gdev);
./s390/net/qeth_core_main.c:5813:	list_del(&card->list);
./s390/net/qeth_core_main.c:5827:	if (!card->discipline) {
./s390/net/qeth_core_main.c:5828:		if (card->info.type == QETH_CARD_TYPE_IQD)
./s390/net/qeth_core_main.c:5835:		rc = card->discipline->setup(card->gdev);
./s390/net/qeth_core_main.c:5841:	rc = card->discipline->set_online(gdev);
./s390/net/qeth_core_main.c:5849:	return card->discipline->set_offline(gdev);
./s390/net/qeth_core_main.c:5856:	if ((gdev->state == CCWGROUP_ONLINE) && card->info.hwtrap)
./s390/net/qeth_core_main.c:5866:	if (card->discipline && card->discipline->freeze)
./s390/net/qeth_core_main.c:5867:		return card->discipline->freeze(gdev);
./s390/net/qeth_core_main.c:5874:	if (card->discipline && card->discipline->thaw)
./s390/net/qeth_core_main.c:5875:		return card->discipline->thaw(gdev);
./s390/net/qeth_core_main.c:5882:	if (card->discipline && card->discipline->restore)
./s390/net/qeth_core_main.c:5883:		return card->discipline->restore(gdev);
./s390/net/qeth_core_main.c:5940:	if (card->info.type == QETH_CARD_TYPE_OSN)
./s390/net/qeth_core_main.c:5948:		if ((card->info.type == QETH_CARD_TYPE_OSD ||
./s390/net/qeth_core_main.c:5949:		     card->info.type == QETH_CARD_TYPE_OSM ||
./s390/net/qeth_core_main.c:5950:		     card->info.type == QETH_CARD_TYPE_OSX) &&
./s390/net/qeth_core_main.c:5951:		    !card->info.guestlan)
./s390/net/qeth_core_main.c:5971:		if (card->discipline->do_ioctl)
./s390/net/qeth_core_main.c:5972:			rc = card->discipline->do_ioctl(dev, rq, cmd);
./s390/net/qeth_core_main.c:6040:	data[0] = card->stats.rx_packets -
./s390/net/qeth_core_main.c:6041:				card->perf_stats.initial_rx_packets;
./s390/net/qeth_core_main.c:6042:	data[1] = card->perf_stats.bufs_rec;
./s390/net/qeth_core_main.c:6043:	data[2] = card->stats.tx_packets -
./s390/net/qeth_core_main.c:6044:				card->perf_stats.initial_tx_packets;
./s390/net/qeth_core_main.c:6045:	data[3] = card->perf_stats.bufs_sent;
./s390/net/qeth_core_main.c:6046:	data[4] = card->stats.tx_packets - card->perf_stats.initial_tx_packets
./s390/net/qeth_core_main.c:6047:			- card->perf_stats.skbs_sent_pack;
./s390/net/qeth_core_main.c:6048:	data[5] = card->perf_stats.bufs_sent - card->perf_stats.bufs_sent_pack;
./s390/net/qeth_core_main.c:6049:	data[6] = card->perf_stats.skbs_sent_pack;
./s390/net/qeth_core_main.c:6050:	data[7] = card->perf_stats.bufs_sent_pack;
./s390/net/qeth_core_main.c:6051:	data[8] = card->perf_stats.sg_skbs_sent;
./s390/net/qeth_core_main.c:6052:	data[9] = card->perf_stats.sg_frags_sent;
./s390/net/qeth_core_main.c:6053:	data[10] = card->perf_stats.sg_skbs_rx;
./s390/net/qeth_core_main.c:6054:	data[11] = card->perf_stats.sg_frags_rx;
./s390/net/qeth_core_main.c:6055:	data[12] = card->perf_stats.sg_alloc_page_rx;
./s390/net/qeth_core_main.c:6056:	data[13] = (card->perf_stats.large_send_bytes >> 10);
./s390/net/qeth_core_main.c:6057:	data[14] = card->perf_stats.large_send_cnt;
./s390/net/qeth_core_main.c:6058:	data[15] = card->perf_stats.sc_dp_p;
./s390/net/qeth_core_main.c:6059:	data[16] = card->perf_stats.sc_p_dp;
./s390/net/qeth_core_main.c:6062:	data[19] = atomic_read(&card->qdio.out_qs[0]->used_buffers);
./s390/net/qeth_core_main.c:6063:	data[20] = (card->qdio.no_out_queues > 1) ?
./s390/net/qeth_core_main.c:6064:			atomic_read(&card->qdio.out_qs[1]->used_buffers) : 0;
./s390/net/qeth_core_main.c:6065:	data[21] = (card->qdio.no_out_queues > 2) ?
./s390/net/qeth_core_main.c:6066:			atomic_read(&card->qdio.out_qs[2]->used_buffers) : 0;
./s390/net/qeth_core_main.c:6067:	data[22] = (card->qdio.no_out_queues > 3) ?
./s390/net/qeth_core_main.c:6068:			atomic_read(&card->qdio.out_qs[3]->used_buffers) : 0;
./s390/net/qeth_core_main.c:6069:	data[23] = card->perf_stats.inbound_time;
./s390/net/qeth_core_main.c:6070:	data[24] = card->perf_stats.inbound_cnt;
./s390/net/qeth_core_main.c:6071:	data[25] = card->perf_stats.inbound_do_qdio_time;
./s390/net/qeth_core_main.c:6072:	data[26] = card->perf_stats.inbound_do_qdio_cnt;
./s390/net/qeth_core_main.c:6073:	data[27] = card->perf_stats.outbound_handler_time;
./s390/net/qeth_core_main.c:6074:	data[28] = card->perf_stats.outbound_handler_cnt;
./s390/net/qeth_core_main.c:6075:	data[29] = card->perf_stats.outbound_time;
./s390/net/qeth_core_main.c:6076:	data[30] = card->perf_stats.outbound_cnt;
./s390/net/qeth_core_main.c:6077:	data[31] = card->perf_stats.outbound_do_qdio_time;
./s390/net/qeth_core_main.c:6078:	data[32] = card->perf_stats.outbound_do_qdio_cnt;
./s390/net/qeth_core_main.c:6079:	data[33] = card->perf_stats.tx_csum;
./s390/net/qeth_core_main.c:6080:	data[34] = card->perf_stats.tx_lin;
./s390/net/qeth_core_main.c:6081:	data[35] = card->perf_stats.tx_linfail;
./s390/net/qeth_core_main.c:6082:	data[36] = card->perf_stats.cq_cnt;
./s390/net/qeth_core_main.c:6083:	data[37] = card->perf_stats.cq_time;
./s390/net/qeth_core_main.c:6106:	strlcpy(info->driver, card->options.layer2 ? "qeth_l2" : "qeth_l3",
./s390/net/qeth_core_main.c:6109:	strlcpy(info->fw_version, card->info.mcl_level,
./s390/net/qeth_core_main.c:6202:	if ((card->info.type == QETH_CARD_TYPE_IQD) || (card->info.guestlan))
./s390/net/qeth_core_main.c:6205:		link_type = card->info.link_type;
./s390/net/qeth_core_main.c:6371:			dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:6377:		dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:6391:		dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:6397:	dev_info(&card->gdev->dev, "HW Checksumming (%sbound) enabled\n",
./s390/net/qeth_core_main.c:6420:			dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:6425:		dev_info(&card->gdev->dev, "Outbound TSO enabled\n");
./s390/net/qeth_core_main.c:6455:	dev_warn(&card->gdev->dev,
./s390/net/qeth_core_main.c:6513:	if (card->state == CARD_STATE_DOWN ||
./s390/net/qeth_core_main.c:6514:	    card->state == CARD_STATE_RECOVER)
./s390/net/qeth_l2_sys.c:25:					card->options.sbp.supported_funcs)
./s390/net/qeth_l2_sys.c:27:			&card->options.sbp.role, &state);
./s390/net/qeth_l2_sys.c:41:			switch (card->options.sbp.role) {
./s390/net/qeth_l2_sys.c:53:				card->options.sbp.role, state);
./s390/net/qeth_l2_sys.c:85:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l2_sys.c:87:	if (card->options.sbp.reflect_promisc) /* Forbid direct manipulation */
./s390/net/qeth_l2_sys.c:92:			card->options.sbp.role = role;
./s390/net/qeth_l2_sys.c:94:		card->options.sbp.role = role;
./s390/net/qeth_l2_sys.c:96:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l2_sys.c:122:	enabled = card->options.sbp.hostnotification;
./s390/net/qeth_l2_sys.c:144:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l2_sys.c:149:			card->options.sbp.hostnotification = enable;
./s390/net/qeth_l2_sys.c:151:		card->options.sbp.hostnotification = enable;
./s390/net/qeth_l2_sys.c:153:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l2_sys.c:171:	if (card->options.sbp.reflect_promisc) {
./s390/net/qeth_l2_sys.c:172:		if (card->options.sbp.reflect_promisc_primary)
./s390/net/qeth_l2_sys.c:204:	mutex_lock(&card->conf_mutex);
./s390/net/qeth_l2_sys.c:206:	if (card->options.sbp.role != QETH_SBP_ROLE_NONE)
./s390/net/qeth_l2_sys.c:209:		card->options.sbp.reflect_promisc = enable;
./s390/net/qeth_l2_sys.c:210:		card->options.sbp.reflect_promisc_primary = primary;
./s390/net/qeth_l2_sys.c:214:	mutex_unlock(&card->conf_mutex);
./s390/net/qeth_l2_sys.c:257:	if (!card->options.sbp.supported_funcs)
./s390/net/qeth_l2_sys.c:259:	if (card->options.sbp.role != QETH_SBP_ROLE_NONE) {
./s390/net/qeth_l2_sys.c:261:		qeth_bridgeport_setrole(card, card->options.sbp.role);
./s390/net/qeth_l2_sys.c:264:			&card->options.sbp.role, NULL);
./s390/net/qeth_l2_sys.c:266:	if (card->options.sbp.hostnotification) {
./s390/net/qeth_l2_sys.c:269:			card->options.sbp.hostnotification = 0;
./s390/net/lcs.c:192:	card->lan_type = LCS_FRAME_TYPE_AUTO;
./s390/net/lcs.c:193:	card->pkt_seq = 0;
./s390/net/lcs.c:194:	card->lancmd_timeout = LCS_LANCMD_TIMEOUT_DEFAULT;
./s390/net/lcs.c:196:	rc = lcs_alloc_channel(&card->read);
./s390/net/lcs.c:203:	rc = lcs_alloc_channel(&card->write);
./s390/net/lcs.c:206:		lcs_cleanup_channel(&card->read);
./s390/net/lcs.c:212:	INIT_LIST_HEAD(&card->ipm_list);
./s390/net/lcs.c:228:	memset(card->read.ccws, 0, sizeof (struct ccw1) * (LCS_NUM_BUFFS + 1));
./s390/net/lcs.c:230:		card->read.ccws[cnt].cmd_code = LCS_CCW_READ;
./s390/net/lcs.c:231:		card->read.ccws[cnt].count = LCS_IOBUFFERSIZE;
./s390/net/lcs.c:232:		card->read.ccws[cnt].flags =
./s390/net/lcs.c:238:		card->read.ccws[cnt].cda =
./s390/net/lcs.c:239:			(__u32) __pa(card->read.iob[cnt].data);
./s390/net/lcs.c:241:		 card->read.iob[cnt].data)->offset = LCS_ILLEGAL_OFFSET;
./s390/net/lcs.c:242:		card->read.iob[cnt].callback = lcs_get_frames_cb;
./s390/net/lcs.c:243:		card->read.iob[cnt].state = LCS_BUF_STATE_READY;
./s390/net/lcs.c:244:		card->read.iob[cnt].count = LCS_IOBUFFERSIZE;
./s390/net/lcs.c:246:	card->read.ccws[0].flags &= ~CCW_FLAG_PCI;
./s390/net/lcs.c:247:	card->read.ccws[LCS_NUM_BUFFS - 1].flags &= ~CCW_FLAG_PCI;
./s390/net/lcs.c:248:	card->read.ccws[LCS_NUM_BUFFS - 1].flags |= CCW_FLAG_SUSPEND;
./s390/net/lcs.c:250:	card->read.ccws[LCS_NUM_BUFFS].cmd_code = LCS_CCW_TRANSFER;
./s390/net/lcs.c:251:	card->read.ccws[LCS_NUM_BUFFS].cda =
./s390/net/lcs.c:252:		(__u32) __pa(card->read.ccws);
./s390/net/lcs.c:254:	card->read.state = LCS_CH_STATE_INIT;
./s390/net/lcs.c:256:	card->read.io_idx = 0;
./s390/net/lcs.c:257:	card->read.buf_idx = 0;
./s390/net/lcs.c:267:	card->read.irq_tasklet.data = (unsigned long) &card->read;
./s390/net/lcs.c:268:	card->read.irq_tasklet.func = lcs_tasklet;
./s390/net/lcs.c:270:	init_waitqueue_head(&card->read.wait_q);
./s390/net/lcs.c:283:	memset(card->write.ccws, 0, sizeof(struct ccw1) * (LCS_NUM_BUFFS + 1));
./s390/net/lcs.c:285:		card->write.ccws[cnt].cmd_code = LCS_CCW_WRITE;
./s390/net/lcs.c:286:		card->write.ccws[cnt].count = 0;
./s390/net/lcs.c:287:		card->write.ccws[cnt].flags =
./s390/net/lcs.c:293:		card->write.ccws[cnt].cda =
./s390/net/lcs.c:294:			(__u32) __pa(card->write.iob[cnt].data);
./s390/net/lcs.c:297:	card->write.ccws[LCS_NUM_BUFFS].cmd_code = LCS_CCW_TRANSFER;
./s390/net/lcs.c:298:	card->write.ccws[LCS_NUM_BUFFS].cda =
./s390/net/lcs.c:299:		(__u32) __pa(card->write.ccws);
./s390/net/lcs.c:301:	card->read.state = LCS_CH_STATE_INIT;
./s390/net/lcs.c:303:	card->write.io_idx = 0;
./s390/net/lcs.c:304:	card->write.buf_idx = 0;
./s390/net/lcs.c:314:	card->write.irq_tasklet.data = (unsigned long) &card->write;
./s390/net/lcs.c:315:	card->write.irq_tasklet.func = lcs_tasklet;
./s390/net/lcs.c:317:	init_waitqueue_head(&card->write.wait_q);
./s390/net/lcs.c:325:	spin_lock_irqsave(&card->mask_lock, flags);
./s390/net/lcs.c:326:	card->thread_allowed_mask = threads;
./s390/net/lcs.c:327:	spin_unlock_irqrestore(&card->mask_lock, flags);
./s390/net/lcs.c:328:	wake_up(&card->wait_q);
./s390/net/lcs.c:335:	spin_lock_irqsave(&card->mask_lock, flags);
./s390/net/lcs.c:336:        rc = (card->thread_running_mask & threads);
./s390/net/lcs.c:337:	spin_unlock_irqrestore(&card->mask_lock, flags);
./s390/net/lcs.c:344:        return wait_event_interruptible(card->wait_q,
./s390/net/lcs.c:352:	spin_lock_irqsave(&card->mask_lock, flags);
./s390/net/lcs.c:353:        if ( !(card->thread_allowed_mask & thread) ||
./s390/net/lcs.c:354:              (card->thread_start_mask & thread) ) {
./s390/net/lcs.c:355:                spin_unlock_irqrestore(&card->mask_lock, flags);
./s390/net/lcs.c:358:        card->thread_start_mask |= thread;
./s390/net/lcs.c:359:	spin_unlock_irqrestore(&card->mask_lock, flags);
./s390/net/lcs.c:368:	spin_lock_irqsave(&card->mask_lock, flags);
./s390/net/lcs.c:369:        card->thread_running_mask &= ~thread;
./s390/net/lcs.c:370:	spin_unlock_irqrestore(&card->mask_lock, flags);
./s390/net/lcs.c:371:        wake_up(&card->wait_q);
./s390/net/lcs.c:379:	spin_lock_irqsave(&card->mask_lock, flags);
./s390/net/lcs.c:380:        if (card->thread_start_mask & thread){
./s390/net/lcs.c:381:                if ((card->thread_allowed_mask & thread) &&
./s390/net/lcs.c:382:                    !(card->thread_running_mask & thread)){
./s390/net/lcs.c:384:                        card->thread_start_mask &= ~thread;
./s390/net/lcs.c:385:                        card->thread_running_mask |= thread;
./s390/net/lcs.c:389:	spin_unlock_irqrestore(&card->mask_lock, flags);
./s390/net/lcs.c:397:        wait_event(card->wait_q,
./s390/net/lcs.c:408:	spin_lock_irqsave(&card->mask_lock, flags);
./s390/net/lcs.c:410:                        (u8) card->thread_start_mask,
./s390/net/lcs.c:411:                        (u8) card->thread_allowed_mask,
./s390/net/lcs.c:412:                        (u8) card->thread_running_mask);
./s390/net/lcs.c:413:        rc = (card->thread_start_mask & thread);
./s390/net/lcs.c:414:	spin_unlock_irqrestore(&card->mask_lock, flags);
./s390/net/lcs.c:430:	card->state = DEV_STATE_DOWN;
./s390/net/lcs.c:431:	card->tx_buffer = NULL;
./s390/net/lcs.c:432:	card->tx_emitted = 0;
./s390/net/lcs.c:434:	init_waitqueue_head(&card->wait_q);
./s390/net/lcs.c:435:	spin_lock_init(&card->lock);
./s390/net/lcs.c:436:	spin_lock_init(&card->ipm_lock);
./s390/net/lcs.c:437:	spin_lock_init(&card->mask_lock);
./s390/net/lcs.c:439:	INIT_LIST_HEAD(&card->ipm_list);
./s390/net/lcs.c:441:	INIT_LIST_HEAD(&card->lancmd_waiters);
./s390/net/lcs.c:452:	spin_lock_irqsave(&card->ipm_lock, flags);
./s390/net/lcs.c:453:	while (!list_empty(&card->ipm_list)){
./s390/net/lcs.c:454:		ipm = list_entry(card->ipm_list.next,
./s390/net/lcs.c:458:			spin_unlock_irqrestore(&card->ipm_lock, flags);
./s390/net/lcs.c:460:			spin_lock_irqsave(&card->ipm_lock, flags);
./s390/net/lcs.c:464:	spin_unlock_irqrestore(&card->ipm_lock, flags);
./s390/net/lcs.c:477:	if (card->dev != NULL)
./s390/net/lcs.c:478:		free_netdev(card->dev);
./s390/net/lcs.c:480:	lcs_cleanup_channel(&card->write);
./s390/net/lcs.c:481:	lcs_cleanup_channel(&card->read);
./s390/net/lcs.c:571:	rc = lcs_start_channel(&card->read);
./s390/net/lcs.c:575:	rc = lcs_start_channel(&card->write);
./s390/net/lcs.c:577:		lcs_stop_channel(&card->read);
./s390/net/lcs.c:588:	lcs_stop_channel(&card->read);
./s390/net/lcs.c:589:	lcs_stop_channel(&card->write);
./s390/net/lcs.c:755:	wait_event(card->write.wait_q,
./s390/net/lcs.c:756:		   ((buffer = lcs_get_buffer(&card->write)) != NULL));
./s390/net/lcs.c:815:	spin_lock(&card->lock);
./s390/net/lcs.c:816:	list_for_each_safe(l, n, &card->lancmd_waiters) {
./s390/net/lcs.c:830:	spin_unlock(&card->lock);
./s390/net/lcs.c:844:	spin_lock_irqsave(&reply->card->lock, flags);
./s390/net/lcs.c:846:				 &reply->card->lancmd_waiters,list) {
./s390/net/lcs.c:850:			spin_unlock_irqrestore(&reply->card->lock, flags);
./s390/net/lcs.c:858:	spin_unlock_irqrestore(&reply->card->lock, flags);
./s390/net/lcs.c:874:	cmd->sequence_no = card->sequence_no++;
./s390/net/lcs.c:880:	spin_lock_irqsave(&card->lock, flags);
./s390/net/lcs.c:881:	list_add_tail(&reply->list, &card->lancmd_waiters);
./s390/net/lcs.c:882:	spin_unlock_irqrestore(&card->lock, flags);
./s390/net/lcs.c:885:	rc = lcs_ready_buffer(&card->write, buffer);
./s390/net/lcs.c:891:	timer.expires = jiffies + HZ*card->lancmd_timeout;
./s390/net/lcs.c:944:	memcpy(card->mac, cmd->cmd.lcs_lanstat_cmd.mac_addr, LCS_MAC_LENGTH);
./s390/net/lcs.c:959:	cmd->cmd.lcs_std_cmd.lan_type = card->lan_type;
./s390/net/lcs.c:960:	cmd->cmd.lcs_std_cmd.portno = card->portno;
./s390/net/lcs.c:978:	cmd->cmd.lcs_std_cmd.lan_type = card->lan_type;
./s390/net/lcs.c:979:	cmd->cmd.lcs_std_cmd.portno = card->portno;
./s390/net/lcs.c:990:	card->lan_type = cmd->cmd.lcs_std_cmd.lan_type;
./s390/net/lcs.c:991:	card->portno = cmd->cmd.lcs_std_cmd.portno;
./s390/net/lcs.c:1005:	cmd->cmd.lcs_std_cmd.lan_type = card->lan_type;
./s390/net/lcs.c:1006:	cmd->cmd.lcs_std_cmd.portno = card->portno;
./s390/net/lcs.c:1025:	cmd->cmd.lcs_qipassist.lan_type = card->lan_type;
./s390/net/lcs.c:1026:	cmd->cmd.lcs_qipassist.portno = card->portno;
./s390/net/lcs.c:1049:	cmd->cmd.lcs_qipassist.lan_type = card->lan_type;
./s390/net/lcs.c:1050:	cmd->cmd.lcs_qipassist.portno = card->portno;
./s390/net/lcs.c:1066:	card->ip_assists_supported =
./s390/net/lcs.c:1068:	card->ip_assists_enabled =
./s390/net/lcs.c:1085:	cmd->cmd.lcs_qipassist.lan_type = card->lan_type;
./s390/net/lcs.c:1086:	cmd->cmd.lcs_qipassist.portno = card->portno;
./s390/net/lcs.c:1094:	if (card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT)
./s390/net/lcs.c:1112:	spin_lock_irqsave(&card->ipm_lock, flags);
./s390/net/lcs.c:1114:	list_for_each_entry_safe(ipm, tmp, &card->ipm_list, list){
./s390/net/lcs.c:1120:			spin_unlock_irqrestore(&card->ipm_lock, flags);
./s390/net/lcs.c:1122:			spin_lock_irqsave(&card->ipm_lock, flags);
./s390/net/lcs.c:1133:				list_add_tail(&ipm->list, &card->ipm_list);
./s390/net/lcs.c:1138:			spin_unlock_irqrestore(&card->ipm_lock, flags);
./s390/net/lcs.c:1140:			spin_lock_irqsave(&card->ipm_lock, flags);
./s390/net/lcs.c:1149:		list_move_tail(&ipm->list, &card->ipm_list);
./s390/net/lcs.c:1151:	spin_unlock_irqrestore(&card->ipm_lock, flags);
./s390/net/lcs.c:1177:	spin_lock_irqsave(&card->ipm_lock, flags);
./s390/net/lcs.c:1178:	list_for_each(l, &card->ipm_list) {
./s390/net/lcs.c:1182:			lcs_get_mac_for_ipm(im4->multiaddr, buf, card->dev);
./s390/net/lcs.c:1191:	spin_unlock_irqrestore(&card->ipm_lock, flags);
./s390/net/lcs.c:1203:	spin_lock_irqsave(&card->ipm_lock, flags);
./s390/net/lcs.c:1204:	list_for_each(l, &card->ipm_list) {
./s390/net/lcs.c:1213:	spin_unlock_irqrestore(&card->ipm_lock, flags);
./s390/net/lcs.c:1229:		lcs_get_mac_for_ipm(im4->multiaddr, buf, card->dev);
./s390/net/lcs.c:1242:		spin_lock_irqsave(&card->ipm_lock, flags);
./s390/net/lcs.c:1244:		list_add(&ipm->list, &card->ipm_list);
./s390/net/lcs.c:1245:		spin_unlock_irqrestore(&card->ipm_lock, flags);
./s390/net/lcs.c:1261:	in4_dev = in_dev_get(card->dev);
./s390/net/lcs.c:1270:	netif_carrier_off(card->dev);
./s390/net/lcs.c:1271:	netif_tx_disable(card->dev);
./s390/net/lcs.c:1272:	wait_event(card->write.wait_q,
./s390/net/lcs.c:1273:			(card->write.state != LCS_CH_STATE_RUNNING));
./s390/net/lcs.c:1275:	if (card->state == DEV_STATE_UP) {
./s390/net/lcs.c:1276:		netif_carrier_on(card->dev);
./s390/net/lcs.c:1277:		netif_wake_queue(card->dev);
./s390/net/lcs.c:1299:		schedule_work(&card->kernel_thread_starter);
./s390/net/lcs.c:1377:		schedule_work(&card->kernel_thread_starter);
./s390/net/lcs.c:1395:	if (card->read.ccwdev == cdev)
./s390/net/lcs.c:1396:		channel = &card->read;
./s390/net/lcs.c:1398:		channel = &card->write;
./s390/net/lcs.c:1421:		wake_up(&card->wait_q);
./s390/net/lcs.c:1508:	*(__u16 *)(card->tx_buffer->data + card->tx_buffer->count) = 0;
./s390/net/lcs.c:1509:	card->tx_buffer->count += 2;
./s390/net/lcs.c:1510:	lcs_ready_buffer(&card->write, card->tx_buffer);
./s390/net/lcs.c:1511:	card->tx_buffer = NULL;
./s390/net/lcs.c:1512:	card->tx_emitted++;
./s390/net/lcs.c:1527:	if (netif_queue_stopped(card->dev) && netif_carrier_ok(card->dev))
./s390/net/lcs.c:1528:		netif_wake_queue(card->dev);
./s390/net/lcs.c:1529:	spin_lock(&card->lock);
./s390/net/lcs.c:1530:	card->tx_emitted--;
./s390/net/lcs.c:1531:	if (card->tx_emitted <= 0 && card->tx_buffer != NULL)
./s390/net/lcs.c:1537:	spin_unlock(&card->lock);
./s390/net/lcs.c:1552:		card->stats.tx_dropped++;
./s390/net/lcs.c:1553:		card->stats.tx_errors++;
./s390/net/lcs.c:1556:	if (card->state != DEV_STATE_UP) {
./s390/net/lcs.c:1558:		card->stats.tx_dropped++;
./s390/net/lcs.c:1559:		card->stats.tx_errors++;
./s390/net/lcs.c:1560:		card->stats.tx_carrier_errors++;
./s390/net/lcs.c:1567:	netif_stop_queue(card->dev);
./s390/net/lcs.c:1568:	spin_lock(&card->lock);
./s390/net/lcs.c:1569:	if (card->tx_buffer != NULL &&
./s390/net/lcs.c:1570:	    card->tx_buffer->count + sizeof(struct lcs_header) +
./s390/net/lcs.c:1574:	if (card->tx_buffer == NULL) {
./s390/net/lcs.c:1576:		card->tx_buffer = lcs_get_buffer(&card->write);
./s390/net/lcs.c:1577:		if (card->tx_buffer == NULL) {
./s390/net/lcs.c:1578:			card->stats.tx_dropped++;
./s390/net/lcs.c:1582:		card->tx_buffer->callback = lcs_txbuffer_cb;
./s390/net/lcs.c:1583:		card->tx_buffer->count = 0;
./s390/net/lcs.c:1586:		(card->tx_buffer->data + card->tx_buffer->count);
./s390/net/lcs.c:1587:	card->tx_buffer->count += skb->len + sizeof(struct lcs_header);
./s390/net/lcs.c:1588:	header->offset = card->tx_buffer->count;
./s390/net/lcs.c:1589:	header->type = card->lan_type;
./s390/net/lcs.c:1590:	header->slot = card->portno;
./s390/net/lcs.c:1592:	spin_unlock(&card->lock);
./s390/net/lcs.c:1593:	card->stats.tx_bytes += skb->len;
./s390/net/lcs.c:1594:	card->stats.tx_packets++;
./s390/net/lcs.c:1596:	netif_wake_queue(card->dev);
./s390/net/lcs.c:1597:	spin_lock(&card->lock);
./s390/net/lcs.c:1598:	if (card->tx_emitted <= 0 && card->tx_buffer != NULL)
./s390/net/lcs.c:1602:	spin_unlock(&card->lock);
./s390/net/lcs.c:1628:	card->lan_type = LCS_FRAME_TYPE_ENET;
./s390/net/lcs.c:1635:	card->lan_type = LCS_FRAME_TYPE_FDDI;
./s390/net/lcs.c:1650:	if (card->portno != LCS_INVALID_PORT_NO) {
./s390/net/lcs.c:1651:		if (card->lan_type == LCS_FRAME_TYPE_AUTO)
./s390/net/lcs.c:1657:                        card->portno = i;
./s390/net/lcs.c:1658:                        if (card->lan_type != LCS_FRAME_TYPE_AUTO)
./s390/net/lcs.c:1684:	if (card->dev)
./s390/net/lcs.c:1685:		netif_stop_queue(card->dev);
./s390/net/lcs.c:1696:		card->state = DEV_STATE_UP;
./s390/net/lcs.c:1698:		card->state = DEV_STATE_DOWN;
./s390/net/lcs.c:1699:		card->write.state = LCS_CH_STATE_INIT;
./s390/net/lcs.c:1700:		card->read.state =  LCS_CH_STATE_INIT;
./s390/net/lcs.c:1715:	if (card->read.state != LCS_CH_STATE_STOPPED &&
./s390/net/lcs.c:1716:	    card->write.state != LCS_CH_STATE_STOPPED &&
./s390/net/lcs.c:1717:	    card->read.state != LCS_CH_STATE_ERROR &&
./s390/net/lcs.c:1718:	    card->write.state != LCS_CH_STATE_ERROR &&
./s390/net/lcs.c:1719:	    card->state == DEV_STATE_UP) {
./s390/net/lcs.c:1725:	card->state = DEV_STATE_DOWN;
./s390/net/lcs.c:1761:				card->dev->name);
./s390/net/lcs.c:1762:			if (card->dev)
./s390/net/lcs.c:1763:				netif_carrier_off(card->dev);
./s390/net/lcs.c:1782:	if (card->dev == NULL ||
./s390/net/lcs.c:1783:	    card->state != DEV_STATE_UP)
./s390/net/lcs.c:1789:		dev_err(&card->dev->dev,
./s390/net/lcs.c:1791:			  card->dev->name);
./s390/net/lcs.c:1792:		card->stats.rx_dropped++;
./s390/net/lcs.c:1796:	skb->protocol =	card->lan_type_trans(skb, card->dev);
./s390/net/lcs.c:1797:	card->stats.rx_bytes += skb_len;
./s390/net/lcs.c:1798:	card->stats.rx_packets++;
./s390/net/lcs.c:1800:		*((__u32 *)skb->cb) = ++card->pkt_seq;
./s390/net/lcs.c:1827:			card->stats.rx_length_errors++;
./s390/net/lcs.c:1828:			card->stats.rx_errors++;
./s390/net/lcs.c:1851:	lcs_ready_buffer(&card->read, buffer);
./s390/net/lcs.c:1864:	return &card->stats;
./s390/net/lcs.c:1882:	wait_event(card->write.wait_q,
./s390/net/lcs.c:1883:		(card->write.state != LCS_CH_STATE_RUNNING));
./s390/net/lcs.c:1886:		dev_err(&card->dev->dev,
./s390/net/lcs.c:1912:		card->state = DEV_STATE_UP;
./s390/net/lcs.c:1930:        return sprintf(buf, "%d\n", card->portno);
./s390/net/lcs.c:1952:        card->portno = value;
./s390/net/lcs.c:1990:	return card ? sprintf(buf, "%u\n", card->lancmd_timeout) : 0;
./s390/net/lcs.c:2009:        card->lancmd_timeout = value;
./s390/net/lcs.c:2027:	if (card->state != DEV_STATE_UP)
./s390/net/lcs.c:2077:	card->gdev = ccwgdev;
./s390/net/lcs.c:2078:	INIT_WORK(&card->kernel_thread_starter, lcs_start_kernel_thread);
./s390/net/lcs.c:2079:	card->thread_start_mask = 0;
./s390/net/lcs.c:2080:	card->thread_allowed_mask = 0;
./s390/net/lcs.c:2081:	card->thread_running_mask = 0;
./s390/net/lcs.c:2094:	if (card->dev->reg_state != NETREG_UNINITIALIZED)
./s390/net/lcs.c:2096:	SET_NETDEV_DEV(card->dev, &ccwgdev->dev);
./s390/net/lcs.c:2097:	return register_netdev(card->dev);
./s390/net/lcs.c:2132:	card->read.ccwdev  = ccwgdev->cdev[0];
./s390/net/lcs.c:2133:	card->write.ccwdev = ccwgdev->cdev[1];
./s390/net/lcs.c:2135:	recover_state = card->state;
./s390/net/lcs.c:2136:	rc = ccw_device_set_online(card->read.ccwdev);
./s390/net/lcs.c:2139:	rc = ccw_device_set_online(card->write.ccwdev);
./s390/net/lcs.c:2155:	if (card->dev) {
./s390/net/lcs.c:2160:	switch (card->lan_type) {
./s390/net/lcs.c:2163:		card->lan_type_trans = eth_type_trans;
./s390/net/lcs.c:2169:		card->lan_type_trans = fddi_type_trans;
./s390/net/lcs.c:2180:	card->dev = dev;
./s390/net/lcs.c:2181:	card->dev->ml_priv = card;
./s390/net/lcs.c:2182:	card->dev->netdev_ops = &lcs_netdev_ops;
./s390/net/lcs.c:2183:	memcpy(card->dev->dev_addr, card->mac, LCS_MAC_LENGTH);
./s390/net/lcs.c:2186:		card->dev->netdev_ops = &lcs_mc_netdev_ops;
./s390/net/lcs.c:2191:		lcs_set_multicast_list(card->dev);
./s390/net/lcs.c:2192:		card->dev->flags |= IFF_UP;
./s390/net/lcs.c:2193:		netif_carrier_on(card->dev);
./s390/net/lcs.c:2194:		netif_wake_queue(card->dev);
./s390/net/lcs.c:2195:		card->state = DEV_STATE_UP;
./s390/net/lcs.c:2204:	pr_info("LCS device %s %s IPv6 support\n", card->dev->name,
./s390/net/lcs.c:2205:		(card->ip_assists_supported & LCS_IPASS_IPV6_SUPPORT) ?
./s390/net/lcs.c:2208:	pr_info("LCS device %s %s Multicast support\n", card->dev->name,
./s390/net/lcs.c:2209:		(card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT) ?
./s390/net/lcs.c:2214:	ccw_device_set_offline(card->write.ccwdev);
./s390/net/lcs.c:2216:	ccw_device_set_offline(card->read.ccwdev);
./s390/net/lcs.c:2241:	recover_state = card->state;
./s390/net/lcs.c:2243:	ret = lcs_stop_device(card->dev);
./s390/net/lcs.c:2244:	ret2 = ccw_device_set_offline(card->read.ccwdev);
./s390/net/lcs.c:2245:	ret3 = ccw_device_set_offline(card->write.ccwdev);
./s390/net/lcs.c:2251:		card->state = DEV_STATE_RECOVER;
./s390/net/lcs.c:2278:	gdev = card->gdev;
./s390/net/lcs.c:2285:			card->dev->name);
./s390/net/lcs.c:2288:			card->dev->name);
./s390/net/lcs.c:2310:	if (card->dev)
./s390/net/lcs.c:2311:		unregister_netdev(card->dev);
./s390/net/lcs.c:2320:	if (card->dev)
./s390/net/lcs.c:2321:		netif_device_detach(card->dev);
./s390/net/lcs.c:2324:	if (card->state != DEV_STATE_DOWN)
./s390/net/lcs.c:2325:		__lcs_shutdown_device(card->gdev, 1);
./s390/net/lcs.c:2333:	if (card->state == DEV_STATE_RECOVER)
./s390/net/lcs.c:2334:		rc = lcs_new_device(card->gdev);
./s390/net/lcs.c:2335:	if (card->dev)
./s390/net/lcs.c:2336:		netif_device_attach(card->dev);
./s390/net/lcs.c:2338:		dev_warn(&card->gdev->dev, "The lcs device driver "
./net/ethernet/dec/tulip/xircom_cb.c:316:	pci_iounmap(pdev, card->ioaddr);
./net/ethernet/dec/tulip/xircom_cb.c:317:	dma_free_coherent(d, 8192, card->tx_buffer, card->tx_dma_handle);
./net/ethernet/dec/tulip/xircom_cb.c:318:	dma_free_coherent(d, 8192, card->rx_buffer, card->rx_dma_handle);
./net/ethernet/dec/tulip/xircom_cb.c:328:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:332:	spin_lock(&card->lock);
./net/ethernet/dec/tulip/xircom_cb.c:338:		 card->tx_buffer[0], card->tx_buffer[4]);
./net/ethernet/dec/tulip/xircom_cb.c:340:		 card->rx_buffer[0], card->rx_buffer[4]);
./net/ethernet/dec/tulip/xircom_cb.c:344:		spin_unlock(&card->lock);
./net/ethernet/dec/tulip/xircom_cb.c:371:	spin_unlock(&card->lock);
./net/ethernet/dec/tulip/xircom_cb.c:384:	spin_lock_irqsave(&card->lock,flags);
./net/ethernet/dec/tulip/xircom_cb.c:391:	nextdescriptor = (card->transmit_used +1) % (NUMDESCRIPTORS);
./net/ethernet/dec/tulip/xircom_cb.c:392:	desc = card->transmit_used;
./net/ethernet/dec/tulip/xircom_cb.c:395:	if (card->tx_buffer[4*desc]==0) {
./net/ethernet/dec/tulip/xircom_cb.c:399:			memset(&card->tx_buffer[bufferoffsets[desc]/4],0,1536);
./net/ethernet/dec/tulip/xircom_cb.c:401:				  &(card->tx_buffer[bufferoffsets[desc] / 4]),
./net/ethernet/dec/tulip/xircom_cb.c:406:			card->tx_buffer[4*desc+1] = cpu_to_le32(skb->len);
./net/ethernet/dec/tulip/xircom_cb.c:408:				card->tx_buffer[4*desc+1] |= cpu_to_le32(1<<25);  
./net/ethernet/dec/tulip/xircom_cb.c:410:			card->tx_buffer[4*desc+1] |= cpu_to_le32(0xF0000000);
./net/ethernet/dec/tulip/xircom_cb.c:412:			card->tx_skb[desc] = skb;
./net/ethernet/dec/tulip/xircom_cb.c:416:			card->tx_buffer[4*desc] = cpu_to_le32(0x80000000);
./net/ethernet/dec/tulip/xircom_cb.c:418:			if (card->tx_buffer[nextdescriptor*4] & cpu_to_le32(0x8000000)) {
./net/ethernet/dec/tulip/xircom_cb.c:422:			card->transmit_used = nextdescriptor;
./net/ethernet/dec/tulip/xircom_cb.c:423:			spin_unlock_irqrestore(&card->lock,flags);
./net/ethernet/dec/tulip/xircom_cb.c:429:	spin_unlock_irqrestore(&card->lock,flags);
./net/ethernet/dec/tulip/xircom_cb.c:464:	spin_lock_irqsave(&card->lock,flags);
./net/ethernet/dec/tulip/xircom_cb.c:474:	spin_unlock_irqrestore(&card->lock,flags);
./net/ethernet/dec/tulip/xircom_cb.c:476:	card->open = 0;
./net/ethernet/dec/tulip/xircom_cb.c:477:	free_irq(card->pdev->irq, dev);
./net/ethernet/dec/tulip/xircom_cb.c:499:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:503:	spin_lock_irqsave(&card->lock, flags);
./net/ethernet/dec/tulip/xircom_cb.c:526:	spin_unlock_irqrestore(&card->lock, flags);
./net/ethernet/dec/tulip/xircom_cb.c:537:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:551:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:562:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:566:	BUG_ON(card->rx_buffer == NULL);
./net/ethernet/dec/tulip/xircom_cb.c:567:	BUG_ON(card->tx_buffer == NULL);
./net/ethernet/dec/tulip/xircom_cb.c:570:	memset(card->rx_buffer, 0, 128);	/* clear the descriptors */
./net/ethernet/dec/tulip/xircom_cb.c:574:		card->rx_buffer[i*4 + 0] = cpu_to_le32(0x80000000);
./net/ethernet/dec/tulip/xircom_cb.c:576:		card->rx_buffer[i*4 + 1] = cpu_to_le32(1536);
./net/ethernet/dec/tulip/xircom_cb.c:578:			card->rx_buffer[i*4 + 1] |= cpu_to_le32(1 << 25);
./net/ethernet/dec/tulip/xircom_cb.c:583:		address = card->rx_dma_handle;
./net/ethernet/dec/tulip/xircom_cb.c:584:		card->rx_buffer[i*4 + 2] = cpu_to_le32(address + bufferoffsets[i]);
./net/ethernet/dec/tulip/xircom_cb.c:586:		card->rx_buffer[i*4 + 3] = 0;
./net/ethernet/dec/tulip/xircom_cb.c:591:	address = card->rx_dma_handle;
./net/ethernet/dec/tulip/xircom_cb.c:596:	memset(card->tx_buffer, 0, 128);	/* clear the descriptors */
./net/ethernet/dec/tulip/xircom_cb.c:600:		card->tx_buffer[i*4 + 0] = 0x00000000;
./net/ethernet/dec/tulip/xircom_cb.c:602:		card->tx_buffer[i*4 + 1] = cpu_to_le32(1536);
./net/ethernet/dec/tulip/xircom_cb.c:604:			card->tx_buffer[i*4 + 1] |= cpu_to_le32(1 << 25);
./net/ethernet/dec/tulip/xircom_cb.c:608:		address = card->tx_dma_handle;
./net/ethernet/dec/tulip/xircom_cb.c:609:		card->tx_buffer[i*4 + 2] = cpu_to_le32(address + bufferoffsets[i]);
./net/ethernet/dec/tulip/xircom_cb.c:611:		card->tx_buffer[i*4 + 3] = 0;
./net/ethernet/dec/tulip/xircom_cb.c:616:	address = card->tx_dma_handle;
./net/ethernet/dec/tulip/xircom_cb.c:626:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:642:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:664:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:678:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:698:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:721:			netdev_err(card->dev, "Receiver failed to deactivate\n");
./net/ethernet/dec/tulip/xircom_cb.c:738:			netdev_err(card->dev,
./net/ethernet/dec/tulip/xircom_cb.c:752:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:768:			netdev_err(card->dev, "Receiver failed to deactivate\n");
./net/ethernet/dec/tulip/xircom_cb.c:785:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:807:			netdev_err(card->dev,
./net/ethernet/dec/tulip/xircom_cb.c:825:			netdev_err(card->dev,
./net/ethernet/dec/tulip/xircom_cb.c:839:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:855:			netdev_err(card->dev,
./net/ethernet/dec/tulip/xircom_cb.c:868:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:884:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:899:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:916:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:928:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:950:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:970:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:998:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:1003:	spin_lock_irqsave(&card->lock, flags);
./net/ethernet/dec/tulip/xircom_cb.c:1022:				card->dev->dev_addr[j] = xr32(CSR9) & 0xff;
./net/ethernet/dec/tulip/xircom_cb.c:1029:	spin_unlock_irqrestore(&card->lock, flags);
./net/ethernet/dec/tulip/xircom_cb.c:1030:	pr_debug(" %pM\n", card->dev->dev_addr);
./net/ethernet/dec/tulip/xircom_cb.c:1041:	void __iomem *ioaddr = card->ioaddr;
./net/ethernet/dec/tulip/xircom_cb.c:1045:	pci_write_config_dword(card->pdev, PCI_POWERMGMT, 0x0000);
./net/ethernet/dec/tulip/xircom_cb.c:1049:	spin_lock_irqsave(&card->lock, flags);
./net/ethernet/dec/tulip/xircom_cb.c:1058:	spin_unlock_irqrestore(&card->lock, flags);
./net/ethernet/dec/tulip/xircom_cb.c:1060:	netif_start_queue(card->dev);
./net/ethernet/dec/tulip/xircom_cb.c:1070:	pci_write_config_dword(card->pdev, PCI_POWERMGMT, 0x0000);
./net/ethernet/dec/tulip/xircom_cb.c:1074:	spin_lock_irqsave(&card->lock, flags);
./net/ethernet/dec/tulip/xircom_cb.c:1085:		investigate_read_descriptor(card->dev,card,i,bufferoffsets[i]);
./net/ethernet/dec/tulip/xircom_cb.c:1088:	spin_unlock_irqrestore(&card->lock, flags);
./net/ethernet/dec/tulip/xircom_cb.c:1091:	netif_start_queue(card->dev);
./net/ethernet/dec/tulip/xircom_cb.c:1101:	status = le32_to_cpu(card->rx_buffer[4*descnr]);
./net/ethernet/dec/tulip/xircom_cb.c:1123:					&card->rx_buffer[bufferoffset / 4],
./net/ethernet/dec/tulip/xircom_cb.c:1133:		card->rx_buffer[4*descnr] = cpu_to_le32(0x80000000);
./net/ethernet/dec/tulip/xircom_cb.c:1147:	status = le32_to_cpu(card->tx_buffer[4*descnr]);
./net/ethernet/dec/tulip/xircom_cb.c:1151:		card->tx_buffer[4*descnr] = 0;
./net/ethernet/dec/tulip/xircom_cb.c:1156:		if (card->tx_skb[descnr]!=NULL) {
./net/ethernet/dec/tulip/xircom_cb.c:1157:			dev->stats.tx_bytes += card->tx_skb[descnr]->len;
./net/ethernet/dec/tulip/xircom_cb.c:1158:			dev_kfree_skb_irq(card->tx_skb[descnr]);
./net/ethernet/dec/tulip/xircom_cb.c:1160:		card->tx_skb[descnr] = NULL;
./net/ethernet/dec/tulip/xircom_cb.c:1164:		card->tx_buffer[4*descnr] = 0; /* descriptor is free again */
./net/ethernet/8390/smc-ultra.c:26:		ultra_open()		The card-specific details of starting, stopping
./net/ethernet/packetengines/hamachi.c:133: * RX_CHECKSUM turns on card-generated receive checksum generation for
./net/ethernet/toshiba/spider_net_ethtool.c:65:	cmd->base.speed = card->phy.speed;
./net/ethernet/toshiba/spider_net_ethtool.c:84:	strlcpy(drvinfo->bus_info, pci_name(card->pdev),
./net/ethernet/toshiba/spider_net_ethtool.c:102:	return card->msg_enable;
./net/ethernet/toshiba/spider_net_ethtool.c:111:	card->msg_enable = level;
./net/ethernet/toshiba/spider_net_ethtool.c:131:	ering->tx_pending = card->tx_chain.num_desc;
./net/ethernet/toshiba/spider_net_ethtool.c:133:	ering->rx_pending = card->rx_chain.num_desc;
./net/ethernet/toshiba/spider_net_ethtool.c:158:	data[7] = card->spider_stats.rx_desc_error;
./net/ethernet/toshiba/spider_net_ethtool.c:159:	data[8] = card->spider_stats.tx_timeouts;
./net/ethernet/toshiba/spider_net_ethtool.c:160:	data[9] = card->spider_stats.alloc_rx_skb_error;
./net/ethernet/toshiba/spider_net_ethtool.c:161:	data[10] = card->spider_stats.rx_iommu_map_error;
./net/ethernet/toshiba/spider_net_ethtool.c:162:	data[11] = card->spider_stats.tx_iommu_map_error;
./net/ethernet/toshiba/spider_net_ethtool.c:163:	data[12] = card->spider_stats.rx_desc_unk_state;
./net/ethernet/toshiba/ps3_gelic_net.h:345:	return &card->dev->core;
./net/ethernet/toshiba/ps3_gelic_net.h:349:	return card->dev->bus_id;
./net/ethernet/toshiba/ps3_gelic_net.h:353:	return card->dev->dev_id;
./net/ethernet/toshiba/ps3_gelic_wireless.c:2599:	if (!card->vlan[GELIC_PORT_WIRELESS].tx)
./net/ethernet/toshiba/ps3_gelic_wireless.c:2608:	SET_NETDEV_DEV(netdev, &card->dev->core);
./net/ethernet/toshiba/ps3_gelic_wireless.c:2615:	card->netdev[GELIC_PORT_WIRELESS] = netdev;
./net/ethernet/toshiba/ps3_gelic_wireless.c:2618:	card->irq_mask |= GELIC_CARD_WLAN_EVENT_RECEIVED |
./net/ethernet/toshiba/ps3_gelic_wireless.c:2641:	if (!card->vlan[GELIC_PORT_WIRELESS].tx)
./net/ethernet/toshiba/ps3_gelic_wireless.c:2644:	netdev = card->netdev[GELIC_PORT_WIRELESS];
./net/ethernet/toshiba/ps3_gelic_wireless.c:2663:	card->irq_mask &= ~(GELIC_CARD_WLAN_EVENT_RECEIVED |
./net/ethernet/toshiba/ps3_gelic_net.c:76:	card->irq_mask |= GELIC_CARD_RXINT;
./net/ethernet/toshiba/ps3_gelic_net.c:77:	gelic_card_set_irq_mask(card, card->irq_mask);
./net/ethernet/toshiba/ps3_gelic_net.c:81:	card->irq_mask &= ~GELIC_CARD_RXINT;
./net/ethernet/toshiba/ps3_gelic_net.c:82:	gelic_card_set_irq_mask(card, card->irq_mask);
./net/ethernet/toshiba/ps3_gelic_net.c:94:			&card->ether_port_status, &v2);
./net/ethernet/toshiba/ps3_gelic_net.c:97:		ether_netdev = card->netdev[GELIC_PORT_ETHERNET_0];
./net/ethernet/toshiba/ps3_gelic_net.c:98:		if (card->ether_port_status & GELIC_LV1_ETHER_LINK_UP)
./net/ethernet/toshiba/ps3_gelic_net.c:131:	card->link_mode = mode;
./net/ethernet/toshiba/ps3_gelic_net.c:165:	if (gelic_descr_get_status(card->rx_chain.head) !=
./net/ethernet/toshiba/ps3_gelic_net.c:168:		       be32_to_cpu(card->rx_chain.head->dmac_cmd_status));
./net/ethernet/toshiba/ps3_gelic_net.c:170:		       be32_to_cpu(card->rx_chain.head->next_descr_addr));
./net/ethernet/toshiba/ps3_gelic_net.c:172:		       card->rx_chain.head);
./net/ethernet/toshiba/ps3_gelic_net.c:176:				card->rx_chain.head->bus_addr, 0);
./net/ethernet/toshiba/ps3_gelic_net.c:252:	mutex_lock(&card->updown_lock);
./net/ethernet/toshiba/ps3_gelic_net.c:253:	if (atomic_inc_return(&card->users) == 1) {
./net/ethernet/toshiba/ps3_gelic_net.c:256:		gelic_card_set_irq_mask(card, card->irq_mask);
./net/ethernet/toshiba/ps3_gelic_net.c:260:		napi_enable(&card->napi);
./net/ethernet/toshiba/ps3_gelic_net.c:262:	mutex_unlock(&card->updown_lock);
./net/ethernet/toshiba/ps3_gelic_net.c:270:	mutex_lock(&card->updown_lock);
./net/ethernet/toshiba/ps3_gelic_net.c:271:	if (atomic_dec_if_positive(&card->users) == 0) {
./net/ethernet/toshiba/ps3_gelic_net.c:273:		napi_disable(&card->napi);
./net/ethernet/toshiba/ps3_gelic_net.c:278:		mask = card->irq_mask & (GELIC_CARD_WLAN_EVENT_RECEIVED |
./net/ethernet/toshiba/ps3_gelic_net.c:283:		gelic_card_reset_chain(card, &card->rx_chain,
./net/ethernet/toshiba/ps3_gelic_net.c:284:				       card->descr + GELIC_NET_TX_DESCRIPTORS);
./net/ethernet/toshiba/ps3_gelic_net.c:288:	mutex_unlock(&card->updown_lock);
./net/ethernet/toshiba/ps3_gelic_net.c:437:	struct gelic_descr *descr = card->rx_chain.head;
./net/ethernet/toshiba/ps3_gelic_net.c:452:	} while (descr != card->rx_chain.head);
./net/ethernet/toshiba/ps3_gelic_net.c:465:	struct gelic_descr *descr = card->rx_chain.head;
./net/ethernet/toshiba/ps3_gelic_net.c:475:	} while (descr != card->rx_chain.head);
./net/ethernet/toshiba/ps3_gelic_net.c:493:	chain = &card->rx_chain;
./net/ethernet/toshiba/ps3_gelic_net.c:495:	chain->tail = card->rx_top->prev; /* point to the last */
./net/ethernet/toshiba/ps3_gelic_net.c:532:	netif_stop_queue(card->netdev[GELIC_PORT_ETHERNET_0]);
./net/ethernet/toshiba/ps3_gelic_net.c:534:	if (card->netdev[GELIC_PORT_WIRELESS])
./net/ethernet/toshiba/ps3_gelic_net.c:535:		netif_stop_queue(card->netdev[GELIC_PORT_WIRELESS]);
./net/ethernet/toshiba/ps3_gelic_net.c:539:	netif_wake_queue(card->netdev[GELIC_PORT_ETHERNET_0]);
./net/ethernet/toshiba/ps3_gelic_net.c:541:	if (card->netdev[GELIC_PORT_WIRELESS])
./net/ethernet/toshiba/ps3_gelic_net.c:542:		netif_wake_queue(card->netdev[GELIC_PORT_WIRELESS]);
./net/ethernet/toshiba/ps3_gelic_net.c:558:	for (tx_chain = &card->tx_chain;
./net/ethernet/toshiba/ps3_gelic_net.c:691:	if (!card->tx_chain.head)
./net/ethernet/toshiba/ps3_gelic_net.c:694:	if (card->tx_chain.tail != card->tx_chain.head->next &&
./net/ethernet/toshiba/ps3_gelic_net.c:695:	    gelic_descr_get_status(card->tx_chain.head) ==
./net/ethernet/toshiba/ps3_gelic_net.c:697:		return card->tx_chain.head;
./net/ethernet/toshiba/ps3_gelic_net.c:783:	if (card->vlan_required) {
./net/ethernet/toshiba/ps3_gelic_net.c:789:					     card->vlan[type].tx);
./net/ethernet/toshiba/ps3_gelic_net.c:812:	card->tx_chain.head = descr->next;
./net/ethernet/toshiba/ps3_gelic_net.c:827:	if (card->tx_dma_progress)
./net/ethernet/toshiba/ps3_gelic_net.c:831:		card->tx_dma_progress = 1;
./net/ethernet/toshiba/ps3_gelic_net.c:835:			card->tx_dma_progress = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:857:	spin_lock_irqsave(&card->tx_lock, flags);
./net/ethernet/toshiba/ps3_gelic_net.c:867:		spin_unlock_irqrestore(&card->tx_lock, flags);
./net/ethernet/toshiba/ps3_gelic_net.c:879:		spin_unlock_irqrestore(&card->tx_lock, flags);
./net/ethernet/toshiba/ps3_gelic_net.c:902:		card->tx_chain.head = descr;
./net/ethernet/toshiba/ps3_gelic_net.c:908:	spin_unlock_irqrestore(&card->tx_lock, flags);
./net/ethernet/toshiba/ps3_gelic_net.c:983:	struct gelic_descr_chain *chain = &card->rx_chain;
./net/ethernet/toshiba/ps3_gelic_net.c:999:	if (card->vlan_required) {
./net/ethernet/toshiba/ps3_gelic_net.c:1004:			if (card->vlan[i].rx == vid) {
./net/ethernet/toshiba/ps3_gelic_net.c:1005:				netdev = card->netdev[i];
./net/ethernet/toshiba/ps3_gelic_net.c:1014:		netdev = card->netdev[GELIC_PORT_ETHERNET_0];
./net/ethernet/toshiba/ps3_gelic_net.c:1127:	status = card->irq_status;
./net/ethernet/toshiba/ps3_gelic_net.c:1132:	status &= card->irq_mask;
./net/ethernet/toshiba/ps3_gelic_net.c:1136:		napi_schedule(&card->napi);
./net/ethernet/toshiba/ps3_gelic_net.c:1140:		spin_lock_irqsave(&card->tx_lock, flags);
./net/ethernet/toshiba/ps3_gelic_net.c:1141:		card->tx_dma_progress = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1144:		gelic_card_kick_txdma(card, card->tx_chain.tail);
./net/ethernet/toshiba/ps3_gelic_net.c:1145:		spin_unlock_irqrestore(&card->tx_lock, flags);
./net/ethernet/toshiba/ps3_gelic_net.c:1155:		gelic_wl_interrupt(card->netdev[GELIC_PORT_WIRELESS], status);
./net/ethernet/toshiba/ps3_gelic_net.c:1174:	gelic_card_set_irq_mask(card, card->irq_mask);
./net/ethernet/toshiba/ps3_gelic_net.c:1217:	if (card->ether_port_status & GELIC_LV1_ETHER_FULL_DUPLEX)
./net/ethernet/toshiba/ps3_gelic_net.c:1222:	switch (card->ether_port_status & GELIC_LV1_ETHER_SPEED_MASK) {
./net/ethernet/toshiba/ps3_gelic_net.c:1243:	if (card->link_mode & GELIC_LV1_ETHER_AUTO_NEG) {
./net/ethernet/toshiba/ps3_gelic_net.c:1398:	struct net_device *netdev = card->netdev[GELIC_PORT_ETHERNET_0];
./net/ethernet/toshiba/ps3_gelic_net.c:1412:	atomic_dec(&card->tx_timeout_task_counter);
./net/ethernet/toshiba/ps3_gelic_net.c:1426:	atomic_inc(&card->tx_timeout_task_counter);
./net/ethernet/toshiba/ps3_gelic_net.c:1428:		schedule_work(&card->tx_timeout_task);
./net/ethernet/toshiba/ps3_gelic_net.c:1430:		atomic_dec(&card->tx_timeout_task_counter);
./net/ethernet/toshiba/ps3_gelic_net.c:1495:	if (card->vlan_required) {
./net/ethernet/toshiba/ps3_gelic_net.c:1550:	card->unalign = p;
./net/ethernet/toshiba/ps3_gelic_net.c:1557:		kfree(card->unalign);
./net/ethernet/toshiba/ps3_gelic_net.c:1568:	card->netdev[GELIC_PORT_ETHERNET_0] = *netdev;
./net/ethernet/toshiba/ps3_gelic_net.c:1570:	INIT_WORK(&card->tx_timeout_task, gelic_net_tx_timeout_task);
./net/ethernet/toshiba/ps3_gelic_net.c:1571:	init_waitqueue_head(&card->waitq);
./net/ethernet/toshiba/ps3_gelic_net.c:1572:	atomic_set(&card->tx_timeout_task_counter, 0);
./net/ethernet/toshiba/ps3_gelic_net.c:1573:	mutex_init(&card->updown_lock);
./net/ethernet/toshiba/ps3_gelic_net.c:1574:	atomic_set(&card->users, 0);
./net/ethernet/toshiba/ps3_gelic_net.c:1609:			card->vlan[i].tx = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1610:			card->vlan[i].rx = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1613:		card->vlan[i].tx = (u16)v1;
./net/ethernet/toshiba/ps3_gelic_net.c:1625:			card->vlan[i].tx = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1626:			card->vlan[i].rx = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1629:		card->vlan[i].rx = (u16)v1;
./net/ethernet/toshiba/ps3_gelic_net.c:1632:			i, card->vlan[i].tx, card->vlan[i].rx);
./net/ethernet/toshiba/ps3_gelic_net.c:1635:	if (card->vlan[GELIC_PORT_ETHERNET_0].tx) {
./net/ethernet/toshiba/ps3_gelic_net.c:1636:		BUG_ON(!card->vlan[GELIC_PORT_WIRELESS].tx);
./net/ethernet/toshiba/ps3_gelic_net.c:1637:		card->vlan_required = 1;
./net/ethernet/toshiba/ps3_gelic_net.c:1639:		card->vlan_required = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1643:		card->vlan[GELIC_PORT_WIRELESS].tx = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1644:		card->vlan[GELIC_PORT_WIRELESS].rx = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1648:		 card->vlan_required? "enabled" : "disabled");
./net/ethernet/toshiba/ps3_gelic_net.c:1689:	card->dev = dev;
./net/ethernet/toshiba/ps3_gelic_net.c:1694:	card->link_mode = GELIC_LV1_ETHER_AUTO_NEG;
./net/ethernet/toshiba/ps3_gelic_net.c:1699:		ps3_mm_phys_to_lpar(__pa(&card->irq_status)),
./net/ethernet/toshiba/ps3_gelic_net.c:1711:		&card->irq);
./net/ethernet/toshiba/ps3_gelic_net.c:1720:	result = request_irq(card->irq, gelic_card_interrupt,
./net/ethernet/toshiba/ps3_gelic_net.c:1730:	card->irq_mask = GELIC_CARD_RXINT | GELIC_CARD_TXINT |
./net/ethernet/toshiba/ps3_gelic_net.c:1734:	result = gelic_card_init_chain(card, &card->tx_chain,
./net/ethernet/toshiba/ps3_gelic_net.c:1735:				       card->descr, GELIC_NET_TX_DESCRIPTORS);
./net/ethernet/toshiba/ps3_gelic_net.c:1738:	result = gelic_card_init_chain(card, &card->rx_chain,
./net/ethernet/toshiba/ps3_gelic_net.c:1739:				       card->descr + GELIC_NET_TX_DESCRIPTORS,
./net/ethernet/toshiba/ps3_gelic_net.c:1745:	card->tx_top = card->tx_chain.head;
./net/ethernet/toshiba/ps3_gelic_net.c:1746:	card->rx_top = card->rx_chain.head;
./net/ethernet/toshiba/ps3_gelic_net.c:1748:		card->rx_top, card->tx_top, sizeof(struct gelic_descr),
./net/ethernet/toshiba/ps3_gelic_net.c:1755:	spin_lock_init(&card->tx_lock);
./net/ethernet/toshiba/ps3_gelic_net.c:1756:	card->tx_dma_progress = 0;
./net/ethernet/toshiba/ps3_gelic_net.c:1759:	netdev->irq = card->irq;
./net/ethernet/toshiba/ps3_gelic_net.c:1760:	SET_NETDEV_DEV(netdev, &card->dev->core);
./net/ethernet/toshiba/ps3_gelic_net.c:1761:	gelic_ether_setup_netdev_ops(netdev, &card->napi);
./net/ethernet/toshiba/ps3_gelic_net.c:1781:	gelic_card_free_chain(card, card->rx_chain.head);
./net/ethernet/toshiba/ps3_gelic_net.c:1783:	gelic_card_free_chain(card, card->tx_chain.head);
./net/ethernet/toshiba/ps3_gelic_net.c:1785:	free_irq(card->irq, card);
./net/ethernet/toshiba/ps3_gelic_net.c:1788:	ps3_sb_event_receive_port_destroy(dev, card->irq);
./net/ethernet/toshiba/ps3_gelic_net.c:1832:	gelic_card_free_chain(card, card->tx_top);
./net/ethernet/toshiba/ps3_gelic_net.c:1833:	gelic_card_free_chain(card, card->rx_top);
./net/ethernet/toshiba/ps3_gelic_net.c:1835:	netdev0 = card->netdev[GELIC_PORT_ETHERNET_0];
./net/ethernet/toshiba/ps3_gelic_net.c:1837:	free_irq(card->irq, card);
./net/ethernet/toshiba/ps3_gelic_net.c:1839:	ps3_sb_event_receive_port_destroy(card->dev, card->irq);
./net/ethernet/toshiba/ps3_gelic_net.c:1841:	wait_event(card->waitq,
./net/ethernet/toshiba/ps3_gelic_net.c:1842:		   atomic_read(&card->tx_timeout_task_counter) == 0);
./net/ethernet/toshiba/spider_net.c:97:	return in_be32(card->regs + reg);
./net/ethernet/toshiba/spider_net.c:113:	out_be32(card->regs + reg, value);
./net/ethernet/toshiba/spider_net.c:179:	struct mii_phy *phy = &card->phy;
./net/ethernet/toshiba/spider_net.c:183:	bmsr  = spider_net_read_phy(card->netdev, phy->mii_id, MII_BMSR);
./net/ethernet/toshiba/spider_net.c:184:	estat = spider_net_read_phy(card->netdev, phy->mii_id, MII_ESTATUS);
./net/ethernet/toshiba/spider_net.c:246:	struct net_device *netdev = card->netdev;
./net/ethernet/toshiba/spider_net.c:299:	dma_free_coherent(&card->pdev->dev, chain->num_desc,
./net/ethernet/toshiba/spider_net.c:325:	chain->hwring = dma_alloc_coherent(&card->pdev->dev, alloc_size,
./net/ethernet/toshiba/spider_net.c:368:	descr = card->rx_chain.head;
./net/ethernet/toshiba/spider_net.c:371:			pci_unmap_single(card->pdev, descr->hwdescr->buf_addr,
./net/ethernet/toshiba/spider_net.c:378:	} while (descr != card->rx_chain.head);
./net/ethernet/toshiba/spider_net.c:407:	descr->skb = netdev_alloc_skb(card->netdev,
./net/ethernet/toshiba/spider_net.c:411:			dev_err(&card->netdev->dev,
./net/ethernet/toshiba/spider_net.c:413:		card->spider_stats.alloc_rx_skb_error++;
./net/ethernet/toshiba/spider_net.c:427:	buf = pci_map_single(card->pdev, descr->skb->data,
./net/ethernet/toshiba/spider_net.c:429:	if (pci_dma_mapping_error(card->pdev, buf)) {
./net/ethernet/toshiba/spider_net.c:433:			dev_err(&card->netdev->dev, "Could not iommu-map rx buffer\n");
./net/ethernet/toshiba/spider_net.c:434:		card->spider_stats.rx_iommu_map_error++;
./net/ethernet/toshiba/spider_net.c:459:			     card->rx_chain.tail->bus_addr);
./net/ethernet/toshiba/spider_net.c:500:	struct spider_net_descr_chain *chain = &card->rx_chain;
./net/ethernet/toshiba/spider_net.c:529:	struct spider_net_descr_chain *chain = &card->rx_chain;
./net/ethernet/toshiba/spider_net.c:659:	struct spider_net_descr_chain *chain = &card->tx_chain;
./net/ethernet/toshiba/spider_net.c:665:	buf = pci_map_single(card->pdev, skb->data, skb->len, PCI_DMA_TODEVICE);
./net/ethernet/toshiba/spider_net.c:666:	if (pci_dma_mapping_error(card->pdev, buf)) {
./net/ethernet/toshiba/spider_net.c:668:			dev_err(&card->netdev->dev, "could not iommu-map packet (%p, %i). "
./net/ethernet/toshiba/spider_net.c:670:		card->spider_stats.tx_iommu_map_error++;
./net/ethernet/toshiba/spider_net.c:675:	descr = card->tx_chain.head;
./net/ethernet/toshiba/spider_net.c:678:		pci_unmap_single(card->pdev, buf, skb->len, PCI_DMA_TODEVICE);
./net/ethernet/toshiba/spider_net.c:708:	netif_trans_update(card->netdev); /* set netdev watchdog timer */
./net/ethernet/toshiba/spider_net.c:715:	struct spider_net_descr *descr = card->tx_chain.tail;
./net/ethernet/toshiba/spider_net.c:724:	while (descr != card->tx_chain.head) {
./net/ethernet/toshiba/spider_net.c:733:	if (cnt < card->tx_chain.num_desc/4)
./net/ethernet/toshiba/spider_net.c:737:	descr = card->tx_chain.tail;
./net/ethernet/toshiba/spider_net.c:743:	spin_lock_irqsave(&card->tx_chain.lock, flags);
./net/ethernet/toshiba/spider_net.c:745:	if (card->low_watermark && card->low_watermark != descr) {
./net/ethernet/toshiba/spider_net.c:746:		hwdescr = card->low_watermark->hwdescr;
./net/ethernet/toshiba/spider_net.c:750:	card->low_watermark = descr;
./net/ethernet/toshiba/spider_net.c:751:	spin_unlock_irqrestore(&card->tx_chain.lock, flags);
./net/ethernet/toshiba/spider_net.c:770:	struct net_device *dev = card->netdev;
./net/ethernet/toshiba/spider_net.c:771:	struct spider_net_descr_chain *chain = &card->tx_chain;
./net/ethernet/toshiba/spider_net.c:809:				dev_err(&card->netdev->dev, "forcing end of tx descriptor "
./net/ethernet/toshiba/spider_net.c:831:			pci_unmap_single(card->pdev, buf_addr, skb->len,
./net/ethernet/toshiba/spider_net.c:859:	descr = card->tx_chain.tail;
./net/ethernet/toshiba/spider_net.c:869:		if (descr == card->tx_chain.head)
./net/ethernet/toshiba/spider_net.c:875:	mod_timer(&card->tx_timer, jiffies + SPIDER_NET_TX_TIMER);
./net/ethernet/toshiba/spider_net.c:918:	    (card->netdev->flags & IFF_UP)) {
./net/ethernet/toshiba/spider_net.c:920:		netif_wake_queue(card->netdev);
./net/ethernet/toshiba/spider_net.c:956:	struct net_device *netdev = card->netdev;
./net/ethernet/toshiba/spider_net.c:991:	struct spider_net_descr_chain *chain = &card->rx_chain;
./net/ethernet/toshiba/spider_net.c:995:	struct device *dev = &card->netdev->dev;
./net/ethernet/toshiba/spider_net.c:1089:	struct spider_net_descr_chain *chain = &card->rx_chain;
./net/ethernet/toshiba/spider_net.c:1116:	struct spider_net_descr_chain *chain = &card->rx_chain;
./net/ethernet/toshiba/spider_net.c:1151:	struct net_device *dev = card->netdev;
./net/ethernet/toshiba/spider_net.c:1152:	struct spider_net_descr_chain *chain = &card->rx_chain;
./net/ethernet/toshiba/spider_net.c:1171:	pci_unmap_single(card->pdev, hw_buf_addr,
./net/ethernet/toshiba/spider_net.c:1187:			dev_err(&card->netdev->dev,
./net/ethernet/toshiba/spider_net.c:1189:		card->spider_stats.rx_desc_unk_state++;
./net/ethernet/toshiba/spider_net.c:1196:			dev_err(&card->netdev->dev,
./net/ethernet/toshiba/spider_net.c:1204:		dev_err(&card->netdev->dev, "bad status, cmd_status=x%08x\n",
./net/ethernet/toshiba/spider_net.c:1213:		pr_err("which=%ld\n", descr - card->rx_chain.ring);
./net/ethernet/toshiba/spider_net.c:1215:		card->spider_stats.rx_desc_error++;
./net/ethernet/toshiba/spider_net.c:1258:	if ((packets_done == 0) && (card->num_rx_ints != 0)) {
./net/ethernet/toshiba/spider_net.c:1263:	card->num_rx_ints = 0;
./net/ethernet/toshiba/spider_net.c:1275:		card->ignore_rx_ramfull = 0;
./net/ethernet/toshiba/spider_net.c:1337:	del_timer_sync(&card->aneg_timer);
./net/ethernet/toshiba/spider_net.c:1345:	card->aneg_count = 0;
./net/ethernet/toshiba/spider_net.c:1346:	card->medium = BCM54XX_COPPER;
./net/ethernet/toshiba/spider_net.c:1348:	mod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);
./net/ethernet/toshiba/spider_net.c:1400:			dev_err(&card->netdev->dev, "PHY write queue full\n");
./net/ethernet/toshiba/spider_net.c:1444:		if (card->tx_chain.tail != card->tx_chain.head)
./net/ethernet/toshiba/spider_net.c:1471:		if (card->ignore_rx_ramfull == 0) {
./net/ethernet/toshiba/spider_net.c:1472:			card->ignore_rx_ramfull = 1;
./net/ethernet/toshiba/spider_net.c:1476:			card->num_rx_ints ++;
./net/ethernet/toshiba/spider_net.c:1477:			napi_schedule(&card->napi);
./net/ethernet/toshiba/spider_net.c:1496:		card->num_rx_ints ++;
./net/ethernet/toshiba/spider_net.c:1497:		napi_schedule(&card->napi);
./net/ethernet/toshiba/spider_net.c:1510:		card->num_rx_ints ++;
./net/ethernet/toshiba/spider_net.c:1511:		napi_schedule(&card->napi);
./net/ethernet/toshiba/spider_net.c:1567:		dev_err(&card->netdev->dev, "Error interrupt, GHIINT0STS = 0x%08x, "
./net/ethernet/toshiba/spider_net.c:1605:		napi_schedule(&card->napi);
./net/ethernet/toshiba/spider_net.c:1606:		card->num_rx_ints ++;
./net/ethernet/toshiba/spider_net.c:1609:		napi_schedule(&card->napi);
./net/ethernet/toshiba/spider_net.c:1859:			     SPIDER_NET_FIRMWARE_NAME, &card->pdev->dev) == 0) {
./net/ethernet/toshiba/spider_net.c:1862:			dev_err(&card->netdev->dev,
./net/ethernet/toshiba/spider_net.c:1877:	dn = pci_device_to_OF_node(card->pdev);
./net/ethernet/toshiba/spider_net.c:1887:		dev_err(&card->netdev->dev,
./net/ethernet/toshiba/spider_net.c:1898:		dev_err(&card->netdev->dev,
./net/ethernet/toshiba/spider_net.c:1924:	card->aneg_count = 0;
./net/ethernet/toshiba/spider_net.c:1925:	card->medium = BCM54XX_COPPER;
./net/ethernet/toshiba/spider_net.c:1927:	if (card->phy.def->phy_id)
./net/ethernet/toshiba/spider_net.c:1928:		mod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);
./net/ethernet/toshiba/spider_net.c:1930:	result = spider_net_init_chain(card, &card->tx_chain);
./net/ethernet/toshiba/spider_net.c:1933:	card->low_watermark = NULL;
./net/ethernet/toshiba/spider_net.c:1935:	result = spider_net_init_chain(card, &card->rx_chain);
./net/ethernet/toshiba/spider_net.c:1957:	napi_enable(&card->napi);
./net/ethernet/toshiba/spider_net.c:1966:	spider_net_free_chain(card, &card->rx_chain);
./net/ethernet/toshiba/spider_net.c:1968:	spider_net_free_chain(card, &card->tx_chain);
./net/ethernet/toshiba/spider_net.c:1970:	del_timer_sync(&card->aneg_timer);
./net/ethernet/toshiba/spider_net.c:1983:	struct mii_phy *phy = &card->phy;
./net/ethernet/toshiba/spider_net.c:1986:	if (card->aneg_count > SPIDER_NET_ANEG_TIMEOUT) {
./net/ethernet/toshiba/spider_net.c:1989:			 card->netdev->name);
./net/ethernet/toshiba/spider_net.c:1991:		switch (card->medium) {
./net/ethernet/toshiba/spider_net.c:1996:			card->medium = BCM54XX_FIBER;
./net/ethernet/toshiba/spider_net.c:2003:			card->medium = BCM54XX_UNKNOWN;
./net/ethernet/toshiba/spider_net.c:2010:			card->medium = BCM54XX_COPPER;
./net/ethernet/toshiba/spider_net.c:2014:		card->aneg_count = 0;
./net/ethernet/toshiba/spider_net.c:2015:		mod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);
./net/ethernet/toshiba/spider_net.c:2021:		card->aneg_count++;
./net/ethernet/toshiba/spider_net.c:2022:		mod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);
./net/ethernet/toshiba/spider_net.c:2038:	card->aneg_count = 0;
./net/ethernet/toshiba/spider_net.c:2041:		card->netdev->name, phy->speed,
./net/ethernet/toshiba/spider_net.c:2057:	struct mii_phy *phy = &card->phy;
./net/ethernet/toshiba/spider_net.c:2064:	phy->dev = card->netdev;
./net/ethernet/toshiba/spider_net.c:2070:		id = spider_net_read_phy(card->netdev, phy->mii_id, MII_BMSR);
./net/ethernet/toshiba/spider_net.c:2127:	napi_disable(&card->napi);
./net/ethernet/toshiba/spider_net.c:2130:	del_timer_sync(&card->tx_timer);
./net/ethernet/toshiba/spider_net.c:2131:	del_timer_sync(&card->aneg_timer);
./net/ethernet/toshiba/spider_net.c:2147:	spider_net_free_chain(card, &card->tx_chain);
./net/ethernet/toshiba/spider_net.c:2148:	spider_net_free_chain(card, &card->rx_chain);
./net/ethernet/toshiba/spider_net.c:2165:	struct net_device *netdev = card->netdev;
./net/ethernet/toshiba/spider_net.c:2184:	atomic_dec(&card->tx_timeout_task_counter);
./net/ethernet/toshiba/spider_net.c:2199:	atomic_inc(&card->tx_timeout_task_counter);
./net/ethernet/toshiba/spider_net.c:2201:		schedule_work(&card->tx_timeout_task);
./net/ethernet/toshiba/spider_net.c:2203:		atomic_dec(&card->tx_timeout_task_counter);
./net/ethernet/toshiba/spider_net.c:2204:	card->spider_stats.tx_timeouts++;
./net/ethernet/toshiba/spider_net.c:2250:	struct net_device *netdev = card->netdev;
./net/ethernet/toshiba/spider_net.c:2255:	SET_NETDEV_DEV(netdev, &card->pdev->dev);
./net/ethernet/toshiba/spider_net.c:2257:	pci_set_drvdata(card->pdev, netdev);
./net/ethernet/toshiba/spider_net.c:2259:	init_timer(&card->tx_timer);
./net/ethernet/toshiba/spider_net.c:2260:	card->tx_timer.function =
./net/ethernet/toshiba/spider_net.c:2262:	card->tx_timer.data = (unsigned long) card;
./net/ethernet/toshiba/spider_net.c:2263:	netdev->irq = card->pdev->irq;
./net/ethernet/toshiba/spider_net.c:2265:	card->aneg_count = 0;
./net/ethernet/toshiba/spider_net.c:2266:	init_timer(&card->aneg_timer);
./net/ethernet/toshiba/spider_net.c:2267:	card->aneg_timer.function = spider_net_link_phy;
./net/ethernet/toshiba/spider_net.c:2268:	card->aneg_timer.data = (unsigned long) card;
./net/ethernet/toshiba/spider_net.c:2270:	netif_napi_add(netdev, &card->napi,
./net/ethernet/toshiba/spider_net.c:2286:	netdev->irq = card->pdev->irq;
./net/ethernet/toshiba/spider_net.c:2287:	card->num_rx_ints = 0;
./net/ethernet/toshiba/spider_net.c:2288:	card->ignore_rx_ramfull = 0;
./net/ethernet/toshiba/spider_net.c:2290:	dn = pci_device_to_OF_node(card->pdev);
./net/ethernet/toshiba/spider_net.c:2301:		dev_err(&card->netdev->dev,
./net/ethernet/toshiba/spider_net.c:2307:			dev_err(&card->netdev->dev,
./net/ethernet/toshiba/spider_net.c:2339:	card->netdev = netdev;
./net/ethernet/toshiba/spider_net.c:2340:	card->msg_enable = SPIDER_NET_DEFAULT_MSG;
./net/ethernet/toshiba/spider_net.c:2341:	INIT_WORK(&card->tx_timeout_task, spider_net_tx_timeout_task);
./net/ethernet/toshiba/spider_net.c:2342:	init_waitqueue_head(&card->waitq);
./net/ethernet/toshiba/spider_net.c:2343:	atomic_set(&card->tx_timeout_task_counter, 0);
./net/ethernet/toshiba/spider_net.c:2345:	card->rx_chain.num_desc = rx_descriptors;
./net/ethernet/toshiba/spider_net.c:2346:	card->rx_chain.ring = card->darray;
./net/ethernet/toshiba/spider_net.c:2347:	card->tx_chain.num_desc = tx_descriptors;
./net/ethernet/toshiba/spider_net.c:2348:	card->tx_chain.ring = card->darray + rx_descriptors;
./net/ethernet/toshiba/spider_net.c:2362:	iounmap(card->regs);
./net/ethernet/toshiba/spider_net.c:2363:	pci_release_regions(card->pdev);
./net/ethernet/toshiba/spider_net.c:2409:	card->pdev = pdev;
./net/ethernet/toshiba/spider_net.c:2415:	card->netdev->mem_start = mmio_start;
./net/ethernet/toshiba/spider_net.c:2416:	card->netdev->mem_end = mmio_start + mmio_len;
./net/ethernet/toshiba/spider_net.c:2417:	card->regs = ioremap(mmio_start, mmio_len);
./net/ethernet/toshiba/spider_net.c:2419:	if (!card->regs) {
./net/ethernet/toshiba/spider_net.c:2469:	free_netdev(card->netdev);
./net/ethernet/toshiba/spider_net.c:2492:	wait_event(card->waitq,
./net/ethernet/toshiba/spider_net.c:2493:		   atomic_read(&card->tx_timeout_task_counter) == 0);
./net/sb1000.c:166:	serial_number = pdev->card->serial;
./net/wireless/st/cw1200/cw1200_sdio.c:297:	func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
./net/wireless/rsi/rsi_91x_sdio.c:66:	return mmc_wait_for_cmd(card->host, &io_cmd, 0);
./net/wireless/rsi/rsi_91x_sdio.c:91:	err = mmc_wait_for_cmd(card->host, &io_cmd, 0);
./net/wireless/rsi/rsi_91x_sdio.c:117:	host = func->card->host;
./net/wireless/rsi/rsi_91x_sdio.c:163:	struct mmc_host *host = card->host;
./net/wireless/rsi/rsi_91x_sdio.c:228:	card->ocr = resp;
./net/wireless/rsi/rsi_91x_sdio.c:233:					    card->ocr,
./net/wireless/rsi/rsi_91x_sdio.c:278:	if (card->host->caps & MMC_CAP_SD_HIGHSPEED) {
./net/wireless/rsi/rsi_91x_sdio.c:303:		clock = card->cis.max_dtr;
./net/wireless/rsi/rsi_91x_sdio.c:311:	if (card->host->caps & MMC_CAP_4_BIT_DATA) {
./net/wireless/rsi/rsi_91x_sdio.c:338:	struct mmc_host *host = dev->pfunction->card->host;
./net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:621:		mmc_wait_for_req(sdiodev->func[fn]->card->host, &mmc_req);
./net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:894:	host = func->card->host;
./net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:1026:	pm_runtime_allow(sdiodev->func[1]->card->host->parent);
./net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:1080:	brcmf_sdiod_host_fixup(sdiodev->func[2]->card->host);
./net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c:1167:	sdiodev->func[1] = func->card->sdio_func[0];
./net/wireless/marvell/mwifiex/sdio.h:606:	if (card->curr_rd_port < card->mpa_rx.start_port) {
./net/wireless/marvell/mwifiex/sdio.h:607:		if (card->supports_sdio_new_mode)
./net/wireless/marvell/mwifiex/sdio.h:608:			tmp = card->mp_end_port >> 1;
./net/wireless/marvell/mwifiex/sdio.h:610:			tmp = card->mp_agg_pkt_limit;
./net/wireless/marvell/mwifiex/sdio.h:612:		if (((card->max_ports - card->mpa_rx.start_port) +
./net/wireless/marvell/mwifiex/sdio.h:613:		    card->curr_rd_port) >= tmp)
./net/wireless/marvell/mwifiex/sdio.h:617:	if (!card->supports_sdio_new_mode)
./net/wireless/marvell/mwifiex/sdio.h:620:	if ((card->curr_rd_port - card->mpa_rx.start_port) >=
./net/wireless/marvell/mwifiex/sdio.h:621:	    (card->mp_end_port >> 1))
./net/wireless/marvell/mwifiex/sdio.h:632:	if (card->curr_wr_port < card->mpa_tx.start_port) {
./net/wireless/marvell/mwifiex/sdio.h:633:		if (card->supports_sdio_new_mode)
./net/wireless/marvell/mwifiex/sdio.h:634:			tmp = card->mp_end_port >> 1;
./net/wireless/marvell/mwifiex/sdio.h:636:			tmp = card->mp_agg_pkt_limit;
./net/wireless/marvell/mwifiex/sdio.h:638:		if (((card->max_ports - card->mpa_tx.start_port) +
./net/wireless/marvell/mwifiex/sdio.h:639:		    card->curr_wr_port) >= tmp)
./net/wireless/marvell/mwifiex/sdio.h:643:	if (!card->supports_sdio_new_mode)
./net/wireless/marvell/mwifiex/sdio.h:646:	if ((card->curr_wr_port - card->mpa_tx.start_port) >=
./net/wireless/marvell/mwifiex/sdio.h:647:	    (card->mp_end_port >> 1))
./net/wireless/marvell/mwifiex/sdio.h:657:	card->mpa_rx.buf_len += rx_len;
./net/wireless/marvell/mwifiex/sdio.h:659:	if (!card->mpa_rx.pkt_cnt)
./net/wireless/marvell/mwifiex/sdio.h:660:		card->mpa_rx.start_port = port;
./net/wireless/marvell/mwifiex/sdio.h:662:	if (card->supports_sdio_new_mode) {
./net/wireless/marvell/mwifiex/sdio.h:663:		card->mpa_rx.ports |= (1 << port);
./net/wireless/marvell/mwifiex/sdio.h:665:		if (card->mpa_rx.start_port <= port)
./net/wireless/marvell/mwifiex/sdio.h:666:			card->mpa_rx.ports |= 1 << (card->mpa_rx.pkt_cnt);
./net/wireless/marvell/mwifiex/sdio.h:668:			card->mpa_rx.ports |= 1 << (card->mpa_rx.pkt_cnt + 1);
./net/wireless/marvell/mwifiex/sdio.h:670:	card->mpa_rx.skb_arr[card->mpa_rx.pkt_cnt] = NULL;
./net/wireless/marvell/mwifiex/sdio.h:671:	card->mpa_rx.len_arr[card->mpa_rx.pkt_cnt] = rx_len;
./net/wireless/marvell/mwifiex/sdio.h:672:	card->mpa_rx.pkt_cnt++;
./net/wireless/marvell/mwifiex/pcie.h:399:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.h:401:	switch (card->dev->device) {
./net/wireless/marvell/mwifiex/pcie.h:403:		if (((card->txbd_wrptr & reg->tx_mask) ==
./net/wireless/marvell/mwifiex/pcie.h:405:		    ((card->txbd_wrptr & reg->tx_rollover_ind) !=
./net/wireless/marvell/mwifiex/pcie.h:411:		if (((card->txbd_wrptr & reg->tx_mask) ==
./net/wireless/marvell/mwifiex/pcie.h:413:		    ((card->txbd_wrptr & reg->tx_rollover_ind) ==
./net/wireless/marvell/mwifiex/pcie.h:425:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.h:427:	switch (card->dev->device) {
./net/wireless/marvell/mwifiex/pcie.h:429:		if (((card->txbd_wrptr & reg->tx_mask) !=
./net/wireless/marvell/mwifiex/pcie.h:430:		     (card->txbd_rdptr & reg->tx_mask)) ||
./net/wireless/marvell/mwifiex/pcie.h:431:		    ((card->txbd_wrptr & reg->tx_rollover_ind) !=
./net/wireless/marvell/mwifiex/pcie.h:432:		     (card->txbd_rdptr & reg->tx_rollover_ind)))
./net/wireless/marvell/mwifiex/pcie.h:437:		if (((card->txbd_wrptr & reg->tx_mask) !=
./net/wireless/marvell/mwifiex/pcie.h:438:		     (card->txbd_rdptr & reg->tx_mask)) ||
./net/wireless/marvell/mwifiex/pcie.h:439:		    ((card->txbd_wrptr & reg->tx_rollover_ind) ==
./net/wireless/marvell/mwifiex/pcie.h:440:		     (card->txbd_rdptr & reg->tx_rollover_ind)))
./net/wireless/marvell/mwifiex/sta_cmd.c:1260:	host_spec->txbd_addr_lo = cpu_to_le32((u32)(card->txbd_ring_pbase));
./net/wireless/marvell/mwifiex/sta_cmd.c:1262:			cpu_to_le32((u32)(((u64)card->txbd_ring_pbase) >> 32));
./net/wireless/marvell/mwifiex/sta_cmd.c:1264:	host_spec->rxbd_addr_lo = cpu_to_le32((u32)(card->rxbd_ring_pbase));
./net/wireless/marvell/mwifiex/sta_cmd.c:1266:			cpu_to_le32((u32)(((u64)card->rxbd_ring_pbase) >> 32));
./net/wireless/marvell/mwifiex/sta_cmd.c:1268:	host_spec->evtbd_addr_lo = cpu_to_le32((u32)(card->evtbd_ring_pbase));
./net/wireless/marvell/mwifiex/sta_cmd.c:1270:			cpu_to_le32((u32)(((u64)card->evtbd_ring_pbase) >> 32));
./net/wireless/marvell/mwifiex/sta_cmd.c:1272:	if (card->sleep_cookie_vbase) {
./net/wireless/marvell/mwifiex/sta_cmd.c:1274:				cpu_to_le32((u32)(card->sleep_cookie_pbase));
./net/wireless/marvell/mwifiex/sta_cmd.c:1276:					(card->sleep_cookie_pbase)) >> 32));
./net/wireless/marvell/mwifiex/sdio.c:67: * The device node is saved in card->plt_of_node.
./net/wireless/marvell/mwifiex/sdio.c:102:	init_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/sdio.c:104:	card->func = func;
./net/wireless/marvell/mwifiex/sdio.c:106:	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
./net/wireless/marvell/mwifiex/sdio.c:111:		card->firmware = data->firmware;
./net/wireless/marvell/mwifiex/sdio.c:112:		card->reg = data->reg;
./net/wireless/marvell/mwifiex/sdio.c:113:		card->max_ports = data->max_ports;
./net/wireless/marvell/mwifiex/sdio.c:114:		card->mp_agg_pkt_limit = data->mp_agg_pkt_limit;
./net/wireless/marvell/mwifiex/sdio.c:115:		card->supports_sdio_new_mode = data->supports_sdio_new_mode;
./net/wireless/marvell/mwifiex/sdio.c:116:		card->has_control_mask = data->has_control_mask;
./net/wireless/marvell/mwifiex/sdio.c:117:		card->tx_buf_size = data->tx_buf_size;
./net/wireless/marvell/mwifiex/sdio.c:118:		card->mp_tx_agg_buf_size = data->mp_tx_agg_buf_size;
./net/wireless/marvell/mwifiex/sdio.c:119:		card->mp_rx_agg_buf_size = data->mp_rx_agg_buf_size;
./net/wireless/marvell/mwifiex/sdio.c:120:		card->can_dump_fw = data->can_dump_fw;
./net/wireless/marvell/mwifiex/sdio.c:121:		card->fw_dump_enh = data->fw_dump_enh;
./net/wireless/marvell/mwifiex/sdio.c:122:		card->can_auto_tdls = data->can_auto_tdls;
./net/wireless/marvell/mwifiex/sdio.c:123:		card->can_ext_scan = data->can_ext_scan;
./net/wireless/marvell/mwifiex/sdio.c:124:		INIT_WORK(&card->work, mwifiex_sdio_work);
./net/wireless/marvell/mwifiex/sdio.c:143:	ret = mwifiex_add_card(card, &card->fw_done, &sdio_ops,
./net/wireless/marvell/mwifiex/sdio.c:177:	if (!card || !card->adapter) {
./net/wireless/marvell/mwifiex/sdio.c:182:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/sdio.c:219:	sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:220:	ret = mwifiex_write_reg_locked(card->func, reg, data);
./net/wireless/marvell/mwifiex/sdio.c:221:	sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:235:	sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:236:	val = sdio_readb(card->func, reg, &ret);
./net/wireless/marvell/mwifiex/sdio.c:237:	sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:269:	sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:271:	ret = sdio_writesb(card->func, ioport, buffer, blk_cnt * blk_size);
./net/wireless/marvell/mwifiex/sdio.c:273:	sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:293:		sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:295:	ret = sdio_readsb(card->func, buffer, ioport, blk_cnt * blk_size);
./net/wireless/marvell/mwifiex/sdio.c:298:		sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:309:	const struct mwifiex_sdio_card_reg *reg = card->reg;
./net/wireless/marvell/mwifiex/sdio.c:355:	if (mwifiex_read_reg(adapter, card->reg->status_reg_0, &winner))
./net/wireless/marvell/mwifiex/sdio.c:384:	wait_for_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/sdio.c:386:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/sdio.c:439:	wait_for_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/sdio.c:441:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/sdio.c:555:	sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:557:	sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:574:	if (mwifiex_read_reg(adapter, card->reg->card_cfg_2_1_reg, &reg))
./net/wireless/marvell/mwifiex/sdio.c:576:	if (mwifiex_write_reg(adapter, card->reg->card_cfg_2_1_reg,
./net/wireless/marvell/mwifiex/sdio.c:581:	if (mwifiex_read_reg(adapter, card->reg->cmd_cfg_0, &reg))
./net/wireless/marvell/mwifiex/sdio.c:583:	if (mwifiex_write_reg(adapter, card->reg->cmd_cfg_0,
./net/wireless/marvell/mwifiex/sdio.c:590:	if (mwifiex_read_reg(adapter, card->reg->cmd_cfg_1, &reg))
./net/wireless/marvell/mwifiex/sdio.c:592:	if (mwifiex_write_reg(adapter, card->reg->cmd_cfg_1,
./net/wireless/marvell/mwifiex/sdio.c:613:	if (card->supports_sdio_new_mode) {
./net/wireless/marvell/mwifiex/sdio.c:620:	if (!mwifiex_read_reg(adapter, card->reg->io_port_0_reg, &reg))
./net/wireless/marvell/mwifiex/sdio.c:625:	if (!mwifiex_read_reg(adapter, card->reg->io_port_1_reg, &reg))
./net/wireless/marvell/mwifiex/sdio.c:630:	if (!mwifiex_read_reg(adapter, card->reg->io_port_2_reg, &reg))
./net/wireless/marvell/mwifiex/sdio.c:639:	if (!mwifiex_read_reg(adapter, card->reg->host_int_rsr_reg, &reg))
./net/wireless/marvell/mwifiex/sdio.c:640:		mwifiex_write_reg(adapter, card->reg->host_int_rsr_reg,
./net/wireless/marvell/mwifiex/sdio.c:641:				  reg | card->reg->sdio_int_mask);
./net/wireless/marvell/mwifiex/sdio.c:646:	if (!mwifiex_read_reg(adapter, card->reg->card_misc_cfg_reg, &reg))
./net/wireless/marvell/mwifiex/sdio.c:647:		mwifiex_write_reg(adapter, card->reg->card_misc_cfg_reg,
./net/wireless/marvell/mwifiex/sdio.c:695:	const struct mwifiex_sdio_card_reg *reg = card->reg;
./net/wireless/marvell/mwifiex/sdio.c:696:	u32 rd_bitmap = card->mp_rd_bitmap;
./net/wireless/marvell/mwifiex/sdio.c:701:	if (card->supports_sdio_new_mode) {
./net/wireless/marvell/mwifiex/sdio.c:709:	if ((card->has_control_mask) &&
./net/wireless/marvell/mwifiex/sdio.c:710:	    (card->mp_rd_bitmap & CTRL_PORT_MASK)) {
./net/wireless/marvell/mwifiex/sdio.c:711:		card->mp_rd_bitmap &= (u32) (~CTRL_PORT_MASK);
./net/wireless/marvell/mwifiex/sdio.c:715:			    *port, card->mp_rd_bitmap);
./net/wireless/marvell/mwifiex/sdio.c:719:	if (!(card->mp_rd_bitmap & (1 << card->curr_rd_port)))
./net/wireless/marvell/mwifiex/sdio.c:723:	card->mp_rd_bitmap &= (u32)(~(1 << card->curr_rd_port));
./net/wireless/marvell/mwifiex/sdio.c:724:	*port = card->curr_rd_port;
./net/wireless/marvell/mwifiex/sdio.c:726:	if (++card->curr_rd_port == card->max_ports)
./net/wireless/marvell/mwifiex/sdio.c:727:		card->curr_rd_port = reg->start_rd_port;
./net/wireless/marvell/mwifiex/sdio.c:731:		    *port, rd_bitmap, card->mp_rd_bitmap);
./net/wireless/marvell/mwifiex/sdio.c:746:	const struct mwifiex_sdio_card_reg *reg = card->reg;
./net/wireless/marvell/mwifiex/sdio.c:747:	u32 wr_bitmap = card->mp_wr_bitmap;
./net/wireless/marvell/mwifiex/sdio.c:752:	if (!(wr_bitmap & card->mp_data_port_mask)) {
./net/wireless/marvell/mwifiex/sdio.c:757:	if (card->mp_wr_bitmap & (1 << card->curr_wr_port)) {
./net/wireless/marvell/mwifiex/sdio.c:758:		card->mp_wr_bitmap &= (u32) (~(1 << card->curr_wr_port));
./net/wireless/marvell/mwifiex/sdio.c:759:		*port = card->curr_wr_port;
./net/wireless/marvell/mwifiex/sdio.c:760:		if (++card->curr_wr_port == card->mp_end_port)
./net/wireless/marvell/mwifiex/sdio.c:761:			card->curr_wr_port = reg->start_wr_port;
./net/wireless/marvell/mwifiex/sdio.c:767:	if ((card->has_control_mask) && (*port == CTRL_PORT)) {
./net/wireless/marvell/mwifiex/sdio.c:770:			    *port, card->curr_wr_port, wr_bitmap,
./net/wireless/marvell/mwifiex/sdio.c:771:			    card->mp_wr_bitmap);
./net/wireless/marvell/mwifiex/sdio.c:777:		    *port, wr_bitmap, card->mp_wr_bitmap);
./net/wireless/marvell/mwifiex/sdio.c:793:		if (mwifiex_read_reg(adapter, card->reg->poll_reg, &cs))
./net/wireless/marvell/mwifiex/sdio.c:816:	struct sdio_func *func = card->func;
./net/wireless/marvell/mwifiex/sdio.c:819:	mwifiex_write_reg_locked(func, card->reg->host_int_mask_reg, 0);
./net/wireless/marvell/mwifiex/sdio.c:833:	if (mwifiex_read_data_sync(adapter, card->mp_regs,
./net/wireless/marvell/mwifiex/sdio.c:834:				   card->reg->max_mp_regs,
./net/wireless/marvell/mwifiex/sdio.c:840:	sdio_ireg = card->mp_regs[card->reg->host_int_status_reg];
./net/wireless/marvell/mwifiex/sdio.c:870:	if (!card || !card->adapter) {
./net/wireless/marvell/mwifiex/sdio.c:872:		       func, card, card ? card->adapter : NULL);
./net/wireless/marvell/mwifiex/sdio.c:875:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/sdio.c:893:	struct sdio_func *func = card->func;
./net/wireless/marvell/mwifiex/sdio.c:907:	ret = mwifiex_write_reg_locked(func, card->reg->host_int_mask_reg,
./net/wireless/marvell/mwifiex/sdio.c:908:				       card->reg->host_int_enable);
./net/wireless/marvell/mwifiex/sdio.c:969:	const struct mwifiex_sdio_card_reg *reg = card->reg;
./net/wireless/marvell/mwifiex/sdio.c:995:	sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:1106:	sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:1284:	if ((card->has_control_mask) && (port == CTRL_PORT)) {
./net/wireless/marvell/mwifiex/sdio.c:1294:	if (!card->mpa_rx.enabled) {
./net/wireless/marvell/mwifiex/sdio.c:1303:	if ((!card->has_control_mask && (card->mp_rd_bitmap &
./net/wireless/marvell/mwifiex/sdio.c:1304:					 card->reg->data_port_mask)) ||
./net/wireless/marvell/mwifiex/sdio.c:1305:	    (card->has_control_mask && (card->mp_rd_bitmap &
./net/wireless/marvell/mwifiex/sdio.c:1361:			    card->mpa_rx.pkt_cnt);
./net/wireless/marvell/mwifiex/sdio.c:1363:		if (card->supports_sdio_new_mode) {
./net/wireless/marvell/mwifiex/sdio.c:1367:			for (i = 0, port_count = 0; i < card->max_ports; i++)
./net/wireless/marvell/mwifiex/sdio.c:1368:				if (card->mpa_rx.ports & BIT(i))
./net/wireless/marvell/mwifiex/sdio.c:1376:				 (port_count << 8)) + card->mpa_rx.start_port;
./net/wireless/marvell/mwifiex/sdio.c:1379:				 (card->mpa_rx.ports << 4)) +
./net/wireless/marvell/mwifiex/sdio.c:1380:				 card->mpa_rx.start_port;
./net/wireless/marvell/mwifiex/sdio.c:1383:		if (card->mpa_rx.pkt_cnt == 1)
./net/wireless/marvell/mwifiex/sdio.c:1384:			mport = adapter->ioport + card->mpa_rx.start_port;
./net/wireless/marvell/mwifiex/sdio.c:1386:		if (mwifiex_read_data_sync(adapter, card->mpa_rx.buf,
./net/wireless/marvell/mwifiex/sdio.c:1387:					   card->mpa_rx.buf_len, mport, 1))
./net/wireless/marvell/mwifiex/sdio.c:1390:		curr_ptr = card->mpa_rx.buf;
./net/wireless/marvell/mwifiex/sdio.c:1392:		for (pind = 0; pind < card->mpa_rx.pkt_cnt; pind++) {
./net/wireless/marvell/mwifiex/sdio.c:1393:			u32 *len_arr = card->mpa_rx.len_arr;
./net/wireless/marvell/mwifiex/sdio.c:1449:						      card->mpa_rx.buf, rx_len,
./net/wireless/marvell/mwifiex/sdio.c:1509:	const struct mwifiex_sdio_card_reg *reg = card->reg;
./net/wireless/marvell/mwifiex/sdio.c:1538:		rx_len = card->mp_regs[reg->cmd_rd_len_1] << 8;
./net/wireless/marvell/mwifiex/sdio.c:1539:		rx_len |= (u16)card->mp_regs[reg->cmd_rd_len_0];
./net/wireless/marvell/mwifiex/sdio.c:1573:		bitmap = (u32) card->mp_regs[reg->wr_bitmap_l];
./net/wireless/marvell/mwifiex/sdio.c:1574:		bitmap |= ((u32) card->mp_regs[reg->wr_bitmap_u]) << 8;
./net/wireless/marvell/mwifiex/sdio.c:1575:		if (card->supports_sdio_new_mode) {
./net/wireless/marvell/mwifiex/sdio.c:1577:				((u32) card->mp_regs[reg->wr_bitmap_1l]) << 16;
./net/wireless/marvell/mwifiex/sdio.c:1579:				((u32) card->mp_regs[reg->wr_bitmap_1u]) << 24;
./net/wireless/marvell/mwifiex/sdio.c:1581:		card->mp_wr_bitmap = bitmap;
./net/wireless/marvell/mwifiex/sdio.c:1585:			    card->mp_wr_bitmap);
./net/wireless/marvell/mwifiex/sdio.c:1587:		    (card->mp_wr_bitmap & card->mp_data_port_mask)) {
./net/wireless/marvell/mwifiex/sdio.c:1597:	if (card->has_control_mask && adapter->cmd_sent) {
./net/wireless/marvell/mwifiex/sdio.c:1600:		card->mp_wr_bitmap |=
./net/wireless/marvell/mwifiex/sdio.c:1601:			(u32) card->mp_regs[reg->wr_bitmap_l] & CTRL_PORT_MASK;
./net/wireless/marvell/mwifiex/sdio.c:1602:		if (card->mp_wr_bitmap & CTRL_PORT_MASK)
./net/wireless/marvell/mwifiex/sdio.c:1609:		bitmap = (u32) card->mp_regs[reg->rd_bitmap_l];
./net/wireless/marvell/mwifiex/sdio.c:1610:		bitmap |= ((u32) card->mp_regs[reg->rd_bitmap_u]) << 8;
./net/wireless/marvell/mwifiex/sdio.c:1611:		if (card->supports_sdio_new_mode) {
./net/wireless/marvell/mwifiex/sdio.c:1613:				((u32) card->mp_regs[reg->rd_bitmap_1l]) << 16;
./net/wireless/marvell/mwifiex/sdio.c:1615:				((u32) card->mp_regs[reg->rd_bitmap_1u]) << 24;
./net/wireless/marvell/mwifiex/sdio.c:1617:		card->mp_rd_bitmap = bitmap;
./net/wireless/marvell/mwifiex/sdio.c:1620:			    card->mp_rd_bitmap);
./net/wireless/marvell/mwifiex/sdio.c:1631:			rx_len = ((u16) card->mp_regs[len_reg_u]) << 8;
./net/wireless/marvell/mwifiex/sdio.c:1632:			rx_len |= (u16) card->mp_regs[len_reg_l];
./net/wireless/marvell/mwifiex/sdio.c:1640:			    (card->mpa_rx.enabled &&
./net/wireless/marvell/mwifiex/sdio.c:1642:			      card->mpa_rx.buf_size))) {
./net/wireless/marvell/mwifiex/sdio.c:1716:	if (!card->mpa_tx.enabled ||
./net/wireless/marvell/mwifiex/sdio.c:1717:	    (card->has_control_mask && (port == CTRL_PORT)) ||
./net/wireless/marvell/mwifiex/sdio.c:1718:	    (card->supports_sdio_new_mode && (port == CMD_PORT_SLCT))) {
./net/wireless/marvell/mwifiex/sdio.c:1737:				if (!(card->mp_wr_bitmap &
./net/wireless/marvell/mwifiex/sdio.c:1738:				      (1 << card->curr_wr_port)) ||
./net/wireless/marvell/mwifiex/sdio.c:1746:				if (!(card->mp_wr_bitmap &
./net/wireless/marvell/mwifiex/sdio.c:1747:				      (1 << card->curr_wr_port)))
./net/wireless/marvell/mwifiex/sdio.c:1754:			    (card->mp_wr_bitmap & (1 << card->curr_wr_port)))
./net/wireless/marvell/mwifiex/sdio.c:1794:			    __func__, card->mpa_tx.start_port,
./net/wireless/marvell/mwifiex/sdio.c:1795:			    card->mpa_tx.ports);
./net/wireless/marvell/mwifiex/sdio.c:1796:		if (card->supports_sdio_new_mode) {
./net/wireless/marvell/mwifiex/sdio.c:1800:			for (i = 0, port_count = 0; i < card->max_ports; i++)
./net/wireless/marvell/mwifiex/sdio.c:1801:				if (card->mpa_tx.ports & BIT(i))
./net/wireless/marvell/mwifiex/sdio.c:1809:				 (port_count << 8)) + card->mpa_tx.start_port;
./net/wireless/marvell/mwifiex/sdio.c:1812:				 (card->mpa_tx.ports << 4)) +
./net/wireless/marvell/mwifiex/sdio.c:1813:				 card->mpa_tx.start_port;
./net/wireless/marvell/mwifiex/sdio.c:1816:		if (card->mpa_tx.pkt_cnt == 1)
./net/wireless/marvell/mwifiex/sdio.c:1817:			mport = adapter->ioport + card->mpa_tx.start_port;
./net/wireless/marvell/mwifiex/sdio.c:1819:		ret = mwifiex_write_data_to_card(adapter, card->mpa_tx.buf,
./net/wireless/marvell/mwifiex/sdio.c:1820:						 card->mpa_tx.buf_len, mport);
./net/wireless/marvell/mwifiex/sdio.c:1827:		adapter->dbg.last_mp_wr_bitmap[index] = card->mp_wr_bitmap;
./net/wireless/marvell/mwifiex/sdio.c:1828:		adapter->dbg.last_mp_wr_len[index] = card->mpa_tx.buf_len;
./net/wireless/marvell/mwifiex/sdio.c:1829:		adapter->dbg.last_mp_curr_wr_port[index] = card->curr_wr_port;
./net/wireless/marvell/mwifiex/sdio.c:1906:		if (card->supports_sdio_new_mode)
./net/wireless/marvell/mwifiex/sdio.c:1927:			card->curr_wr_port = port;
./net/wireless/marvell/mwifiex/sdio.c:1928:			card->mp_wr_bitmap |= (u32)(1 << card->curr_wr_port);
./net/wireless/marvell/mwifiex/sdio.c:1932:			if (!(card->mp_wr_bitmap & (1 << card->curr_wr_port)))
./net/wireless/marvell/mwifiex/sdio.c:1952:	card->mpa_tx.buf = kzalloc(mpa_tx_buf_size, GFP_KERNEL);
./net/wireless/marvell/mwifiex/sdio.c:1953:	if (!card->mpa_tx.buf) {
./net/wireless/marvell/mwifiex/sdio.c:1958:	card->mpa_tx.buf_size = mpa_tx_buf_size;
./net/wireless/marvell/mwifiex/sdio.c:1962:	card->mpa_rx.buf = kzalloc(rx_buf_size, GFP_KERNEL);
./net/wireless/marvell/mwifiex/sdio.c:1963:	if (!card->mpa_rx.buf) {
./net/wireless/marvell/mwifiex/sdio.c:1968:	card->mpa_rx.buf_size = rx_buf_size;
./net/wireless/marvell/mwifiex/sdio.c:1972:		kfree(card->mpa_tx.buf);
./net/wireless/marvell/mwifiex/sdio.c:1973:		kfree(card->mpa_rx.buf);
./net/wireless/marvell/mwifiex/sdio.c:1974:		card->mpa_tx.buf_size = 0;
./net/wireless/marvell/mwifiex/sdio.c:1975:		card->mpa_rx.buf_size = 0;
./net/wireless/marvell/mwifiex/sdio.c:1993:		card->adapter = NULL;
./net/wireless/marvell/mwifiex/sdio.c:1994:		sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:1995:		sdio_disable_func(card->func);
./net/wireless/marvell/mwifiex/sdio.c:1996:		sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:2009:	struct sdio_func *func = card->func;
./net/wireless/marvell/mwifiex/sdio.c:2012:	card->adapter = adapter;
./net/wireless/marvell/mwifiex/sdio.c:2013:	adapter->tx_buf_size = card->tx_buf_size;
./net/wireless/marvell/mwifiex/sdio.c:2018:	ret = sdio_set_block_size(card->func, MWIFIEX_SDIO_BLOCK_SIZE);
./net/wireless/marvell/mwifiex/sdio.c:2026:	strcpy(adapter->fw_name, card->firmware);
./net/wireless/marvell/mwifiex/sdio.c:2027:	if (card->fw_dump_enh) {
./net/wireless/marvell/mwifiex/sdio.c:2053:	const struct mwifiex_sdio_card_reg *reg = card->reg;
./net/wireless/marvell/mwifiex/sdio.c:2057:	sdio_set_drvdata(card->func, card);
./net/wireless/marvell/mwifiex/sdio.c:2064:	mwifiex_read_reg(adapter, card->reg->host_int_status_reg, &sdio_ireg);
./net/wireless/marvell/mwifiex/sdio.c:2070:	card->mp_rd_bitmap = 0;
./net/wireless/marvell/mwifiex/sdio.c:2071:	card->mp_wr_bitmap = 0;
./net/wireless/marvell/mwifiex/sdio.c:2072:	card->curr_rd_port = reg->start_rd_port;
./net/wireless/marvell/mwifiex/sdio.c:2073:	card->curr_wr_port = reg->start_wr_port;
./net/wireless/marvell/mwifiex/sdio.c:2075:	card->mp_data_port_mask = reg->data_port_mask;
./net/wireless/marvell/mwifiex/sdio.c:2077:	card->mpa_tx.buf_len = 0;
./net/wireless/marvell/mwifiex/sdio.c:2078:	card->mpa_tx.pkt_cnt = 0;
./net/wireless/marvell/mwifiex/sdio.c:2079:	card->mpa_tx.start_port = 0;
./net/wireless/marvell/mwifiex/sdio.c:2081:	card->mpa_tx.enabled = 1;
./net/wireless/marvell/mwifiex/sdio.c:2082:	card->mpa_tx.pkt_aggr_limit = card->mp_agg_pkt_limit;
./net/wireless/marvell/mwifiex/sdio.c:2084:	card->mpa_rx.buf_len = 0;
./net/wireless/marvell/mwifiex/sdio.c:2085:	card->mpa_rx.pkt_cnt = 0;
./net/wireless/marvell/mwifiex/sdio.c:2086:	card->mpa_rx.start_port = 0;
./net/wireless/marvell/mwifiex/sdio.c:2088:	card->mpa_rx.enabled = 1;
./net/wireless/marvell/mwifiex/sdio.c:2089:	card->mpa_rx.pkt_aggr_limit = card->mp_agg_pkt_limit;
./net/wireless/marvell/mwifiex/sdio.c:2092:	card->mp_regs = kzalloc(reg->max_mp_regs, GFP_KERNEL);
./net/wireless/marvell/mwifiex/sdio.c:2093:	if (!card->mp_regs)
./net/wireless/marvell/mwifiex/sdio.c:2097:	card->mpa_rx.skb_arr = kzalloc((sizeof(void *)) *
./net/wireless/marvell/mwifiex/sdio.c:2098:				       card->mp_agg_pkt_limit, GFP_KERNEL);
./net/wireless/marvell/mwifiex/sdio.c:2099:	if (!card->mpa_rx.skb_arr) {
./net/wireless/marvell/mwifiex/sdio.c:2100:		kfree(card->mp_regs);
./net/wireless/marvell/mwifiex/sdio.c:2104:	card->mpa_rx.len_arr = kzalloc(sizeof(*card->mpa_rx.len_arr) *
./net/wireless/marvell/mwifiex/sdio.c:2105:				       card->mp_agg_pkt_limit, GFP_KERNEL);
./net/wireless/marvell/mwifiex/sdio.c:2106:	if (!card->mpa_rx.len_arr) {
./net/wireless/marvell/mwifiex/sdio.c:2107:		kfree(card->mp_regs);
./net/wireless/marvell/mwifiex/sdio.c:2108:		kfree(card->mpa_rx.skb_arr);
./net/wireless/marvell/mwifiex/sdio.c:2113:					     card->mp_tx_agg_buf_size,
./net/wireless/marvell/mwifiex/sdio.c:2114:					     card->mp_rx_agg_buf_size);
./net/wireless/marvell/mwifiex/sdio.c:2117:	if (ret && (card->mp_tx_agg_buf_size == MWIFIEX_MP_AGGR_BUF_SIZE_MAX ||
./net/wireless/marvell/mwifiex/sdio.c:2118:		    card->mp_rx_agg_buf_size == MWIFIEX_MP_AGGR_BUF_SIZE_MAX)) {
./net/wireless/marvell/mwifiex/sdio.c:2127:			card->mpa_tx.enabled = 0;
./net/wireless/marvell/mwifiex/sdio.c:2128:			card->mpa_rx.enabled = 0;
./net/wireless/marvell/mwifiex/sdio.c:2132:	adapter->auto_tdls = card->can_auto_tdls;
./net/wireless/marvell/mwifiex/sdio.c:2133:	adapter->ext_scan = card->can_ext_scan;
./net/wireless/marvell/mwifiex/sdio.c:2160:	cancel_work_sync(&card->work);
./net/wireless/marvell/mwifiex/sdio.c:2162:	kfree(card->mp_regs);
./net/wireless/marvell/mwifiex/sdio.c:2163:	kfree(card->mpa_rx.skb_arr);
./net/wireless/marvell/mwifiex/sdio.c:2164:	kfree(card->mpa_rx.len_arr);
./net/wireless/marvell/mwifiex/sdio.c:2165:	kfree(card->mpa_tx.buf);
./net/wireless/marvell/mwifiex/sdio.c:2166:	kfree(card->mpa_rx.buf);
./net/wireless/marvell/mwifiex/sdio.c:2176:	const struct mwifiex_sdio_card_reg *reg = card->reg;
./net/wireless/marvell/mwifiex/sdio.c:2179:	card->mp_end_port = port;
./net/wireless/marvell/mwifiex/sdio.c:2181:	card->mp_data_port_mask = reg->data_port_mask;
./net/wireless/marvell/mwifiex/sdio.c:2184:		for (i = 1; i <= card->max_ports - card->mp_end_port; i++)
./net/wireless/marvell/mwifiex/sdio.c:2185:			card->mp_data_port_mask &=
./net/wireless/marvell/mwifiex/sdio.c:2186:					~(1 << (card->max_ports - i));
./net/wireless/marvell/mwifiex/sdio.c:2189:	card->curr_wr_port = reg->start_wr_port;
./net/wireless/marvell/mwifiex/sdio.c:2193:		    port, card->mp_data_port_mask);
./net/wireless/marvell/mwifiex/sdio.c:2199:	struct sdio_func *func = card->func;
./net/wireless/marvell/mwifiex/sdio.c:2206:	mmc_hw_reset(func->card->host);
./net/wireless/marvell/mwifiex/sdio.c:2212:	clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &card->work_flags);
./net/wireless/marvell/mwifiex/sdio.c:2213:	clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags);
./net/wireless/marvell/mwifiex/sdio.c:2229:	sdio_writeb(card->func, card->reg->fw_dump_host_ready,
./net/wireless/marvell/mwifiex/sdio.c:2230:		    card->reg->fw_dump_ctrl, &ret);
./net/wireless/marvell/mwifiex/sdio.c:2236:		ctrl_data = sdio_readb(card->func, card->reg->fw_dump_ctrl,
./net/wireless/marvell/mwifiex/sdio.c:2246:		if (ctrl_data != card->reg->fw_dump_host_ready) {
./net/wireless/marvell/mwifiex/sdio.c:2249:			sdio_writeb(card->func, card->reg->fw_dump_host_ready,
./net/wireless/marvell/mwifiex/sdio.c:2250:				    card->reg->fw_dump_ctrl, &ret);
./net/wireless/marvell/mwifiex/sdio.c:2258:	if (ctrl_data == card->reg->fw_dump_host_ready) {
./net/wireless/marvell/mwifiex/sdio.c:2277:	if (!card->can_dump_fw)
./net/wireless/marvell/mwifiex/sdio.c:2291:	sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:2299:	reg = card->reg->fw_dump_start;
./net/wireless/marvell/mwifiex/sdio.c:2301:	dump_num = sdio_readb(card->func, reg, &ret);
./net/wireless/marvell/mwifiex/sdio.c:2316:		reg = card->reg->fw_dump_start;
./net/wireless/marvell/mwifiex/sdio.c:2318:			read_reg = sdio_readb(card->func, reg, &ret);
./net/wireless/marvell/mwifiex/sdio.c:2330:						card->reg->fw_dump_ctrl,
./net/wireless/marvell/mwifiex/sdio.c:2361:			reg_start = card->reg->fw_dump_start;
./net/wireless/marvell/mwifiex/sdio.c:2362:			reg_end = card->reg->fw_dump_end;
./net/wireless/marvell/mwifiex/sdio.c:2364:				*dbg_ptr = sdio_readb(card->func, reg, &ret);
./net/wireless/marvell/mwifiex/sdio.c:2388:	sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:2401:	if (!card->fw_dump_enh)
./net/wireless/marvell/mwifiex/sdio.c:2411:	sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:2419:	reg_start = card->reg->fw_dump_start;
./net/wireless/marvell/mwifiex/sdio.c:2420:	reg_end = card->reg->fw_dump_end;
./net/wireless/marvell/mwifiex/sdio.c:2423:			start_flag = sdio_readb(card->func, reg, &ret);
./net/wireless/marvell/mwifiex/sdio.c:2459:			*dbg_ptr = sdio_readb(card->func, reg, &ret);
./net/wireless/marvell/mwifiex/sdio.c:2502:	sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:2512:	if (card->fw_dump_enh)
./net/wireless/marvell/mwifiex/sdio.c:2525:			       &card->work_flags))
./net/wireless/marvell/mwifiex/sdio.c:2526:		mwifiex_sdio_device_dump_work(card->adapter);
./net/wireless/marvell/mwifiex/sdio.c:2528:			       &card->work_flags))
./net/wireless/marvell/mwifiex/sdio.c:2529:		mwifiex_sdio_card_reset_work(card->adapter);
./net/wireless/marvell/mwifiex/sdio.c:2537:	if (!test_and_set_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags))
./net/wireless/marvell/mwifiex/sdio.c:2538:		schedule_work(&card->work);
./net/wireless/marvell/mwifiex/sdio.c:2547:			      &card->work_flags))
./net/wireless/marvell/mwifiex/sdio.c:2548:		schedule_work(&card->work);
./net/wireless/marvell/mwifiex/sdio.c:2652:	sdio_claim_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:2653:	sdio_enable_func(card->func);
./net/wireless/marvell/mwifiex/sdio.c:2654:	sdio_set_block_size(card->func, MWIFIEX_SDIO_BLOCK_SIZE);
./net/wireless/marvell/mwifiex/sdio.c:2655:	sdio_release_host(card->func);
./net/wireless/marvell/mwifiex/sdio.c:2660:	adapter->tx_buf_size = card->tx_buf_size;
./net/wireless/marvell/mwifiex/sdio.c:2666:	mwifiex_read_reg(adapter, card->reg->host_int_status_reg, &sdio_ireg);
./net/wireless/marvell/mwifiex/usb.c:178:	if (card->rx_cmd_ep == context->ep)
./net/wireless/marvell/mwifiex/usb.c:179:		atomic_dec(&card->rx_cmd_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:181:		atomic_dec(&card->rx_data_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:188:			if (card->rx_cmd_ep != context->ep)
./net/wireless/marvell/mwifiex/usb.c:209:			if (card->rx_cmd_ep == context->ep)
./net/wireless/marvell/mwifiex/usb.c:217:			if (card->rx_cmd_ep != context->ep)
./net/wireless/marvell/mwifiex/usb.c:230:		if (card->rx_cmd_ep != context->ep)
./net/wireless/marvell/mwifiex/usb.c:237:	if (card->rx_cmd_ep == context->ep)
./net/wireless/marvell/mwifiex/usb.c:242:	if (card->rx_cmd_ep == context->ep) {
./net/wireless/marvell/mwifiex/usb.c:266:	if (context->ep == card->tx_cmd_ep) {
./net/wireless/marvell/mwifiex/usb.c:269:		atomic_dec(&card->tx_cmd_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:277:			port = &card->port[i];
./net/wireless/marvell/mwifiex/usb.c:287:	if (card->mc_resync_flag)
./net/wireless/marvell/mwifiex/usb.c:300:	if (card->rx_cmd_ep != ctx->ep) {
./net/wireless/marvell/mwifiex/usb.c:309:	if (card->rx_cmd_ep == ctx->ep &&
./net/wireless/marvell/mwifiex/usb.c:310:	    card->rx_cmd_ep_type == USB_ENDPOINT_XFER_INT)
./net/wireless/marvell/mwifiex/usb.c:311:		usb_fill_int_urb(ctx->urb, card->udev,
./net/wireless/marvell/mwifiex/usb.c:312:				 usb_rcvintpipe(card->udev, ctx->ep),
./net/wireless/marvell/mwifiex/usb.c:314:				 (void *)ctx, card->rx_cmd_interval);
./net/wireless/marvell/mwifiex/usb.c:316:		usb_fill_bulk_urb(ctx->urb, card->udev,
./net/wireless/marvell/mwifiex/usb.c:317:				  usb_rcvbulkpipe(card->udev, ctx->ep),
./net/wireless/marvell/mwifiex/usb.c:321:	if (card->rx_cmd_ep == ctx->ep)
./net/wireless/marvell/mwifiex/usb.c:322:		atomic_inc(&card->rx_cmd_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:324:		atomic_inc(&card->rx_data_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:331:		if (card->rx_cmd_ep == ctx->ep)
./net/wireless/marvell/mwifiex/usb.c:332:			atomic_dec(&card->rx_cmd_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:334:			atomic_dec(&card->rx_data_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:347:	if (atomic_read(&card->rx_cmd_urb_pending) && card->rx_cmd.urb)
./net/wireless/marvell/mwifiex/usb.c:348:		usb_kill_urb(card->rx_cmd.urb);
./net/wireless/marvell/mwifiex/usb.c:350:	usb_free_urb(card->rx_cmd.urb);
./net/wireless/marvell/mwifiex/usb.c:351:	card->rx_cmd.urb = NULL;
./net/wireless/marvell/mwifiex/usb.c:353:	if (atomic_read(&card->rx_data_urb_pending))
./net/wireless/marvell/mwifiex/usb.c:355:			if (card->rx_data_list[i].urb)
./net/wireless/marvell/mwifiex/usb.c:356:				usb_kill_urb(card->rx_data_list[i].urb);
./net/wireless/marvell/mwifiex/usb.c:359:		usb_free_urb(card->rx_data_list[i].urb);
./net/wireless/marvell/mwifiex/usb.c:360:		card->rx_data_list[i].urb = NULL;
./net/wireless/marvell/mwifiex/usb.c:364:		port = &card->port[i];
./net/wireless/marvell/mwifiex/usb.c:372:	usb_free_urb(card->tx_cmd.urb);
./net/wireless/marvell/mwifiex/usb.c:373:	card->tx_cmd.urb = NULL;
./net/wireless/marvell/mwifiex/usb.c:396:	init_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/usb.c:410:		card->usb_boot_state = USB8XXX_FW_DNLD;
./net/wireless/marvell/mwifiex/usb.c:416:		card->usb_boot_state = USB8XXX_FW_READY;
./net/wireless/marvell/mwifiex/usb.c:420:		card->usb_boot_state = USB8XXX_FW_DNLD;
./net/wireless/marvell/mwifiex/usb.c:424:	card->udev = udev;
./net/wireless/marvell/mwifiex/usb.c:425:	card->intf = intf;
./net/wireless/marvell/mwifiex/usb.c:439:			card->rx_cmd_ep_type = usb_endpoint_type(epd);
./net/wireless/marvell/mwifiex/usb.c:440:			card->rx_cmd_interval = epd->bInterval;
./net/wireless/marvell/mwifiex/usb.c:443:				 epd->bEndpointAddress, card->rx_cmd_ep_type);
./net/wireless/marvell/mwifiex/usb.c:444:			card->rx_cmd_ep = usb_endpoint_num(epd);
./net/wireless/marvell/mwifiex/usb.c:445:			atomic_set(&card->rx_cmd_urb_pending, 0);
./net/wireless/marvell/mwifiex/usb.c:453:			card->rx_data_ep = usb_endpoint_num(epd);
./net/wireless/marvell/mwifiex/usb.c:454:			atomic_set(&card->rx_data_urb_pending, 0);
./net/wireless/marvell/mwifiex/usb.c:462:			card->port[0].tx_data_ep = usb_endpoint_num(epd);
./net/wireless/marvell/mwifiex/usb.c:463:			atomic_set(&card->port[0].tx_data_urb_pending, 0);
./net/wireless/marvell/mwifiex/usb.c:472:			card->port[1].tx_data_ep = usb_endpoint_num(epd);
./net/wireless/marvell/mwifiex/usb.c:473:			atomic_set(&card->port[1].tx_data_urb_pending, 0);
./net/wireless/marvell/mwifiex/usb.c:479:			card->tx_cmd_ep_type = usb_endpoint_type(epd);
./net/wireless/marvell/mwifiex/usb.c:480:			card->tx_cmd_interval = epd->bInterval;
./net/wireless/marvell/mwifiex/usb.c:486:				 epd->bEndpointAddress, card->tx_cmd_ep_type);
./net/wireless/marvell/mwifiex/usb.c:487:			card->tx_cmd_ep = usb_endpoint_num(epd);
./net/wireless/marvell/mwifiex/usb.c:488:			atomic_set(&card->tx_cmd_urb_pending, 0);
./net/wireless/marvell/mwifiex/usb.c:489:			card->bulk_out_maxpktsize =
./net/wireless/marvell/mwifiex/usb.c:496:	ret = mwifiex_add_card(card, &card->fw_done, &usb_ops,
./net/wireless/marvell/mwifiex/usb.c:497:			       MWIFIEX_USB, &card->udev->dev);
./net/wireless/marvell/mwifiex/usb.c:524:	wait_for_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/usb.c:526:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/usb.c:554:	if (atomic_read(&card->rx_cmd_urb_pending) && card->rx_cmd.urb)
./net/wireless/marvell/mwifiex/usb.c:555:		usb_kill_urb(card->rx_cmd.urb);
./net/wireless/marvell/mwifiex/usb.c:557:	if (atomic_read(&card->rx_data_urb_pending))
./net/wireless/marvell/mwifiex/usb.c:559:			if (card->rx_data_list[i].urb)
./net/wireless/marvell/mwifiex/usb.c:560:				usb_kill_urb(card->rx_data_list[i].urb);
./net/wireless/marvell/mwifiex/usb.c:563:		port = &card->port[i];
./net/wireless/marvell/mwifiex/usb.c:570:	if (card->tx_cmd.urb)
./net/wireless/marvell/mwifiex/usb.c:571:		usb_kill_urb(card->tx_cmd.urb);
./net/wireless/marvell/mwifiex/usb.c:589:	if (!card->adapter) {
./net/wireless/marvell/mwifiex/usb.c:590:		dev_err(&intf->dev, "%s: card->adapter is NULL\n",
./net/wireless/marvell/mwifiex/usb.c:594:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/usb.c:607:	if (!atomic_read(&card->rx_data_urb_pending))
./net/wireless/marvell/mwifiex/usb.c:609:			mwifiex_usb_submit_rx_urb(&card->rx_data_list[i],
./net/wireless/marvell/mwifiex/usb.c:612:	if (!atomic_read(&card->rx_cmd_urb_pending)) {
./net/wireless/marvell/mwifiex/usb.c:613:		card->rx_cmd.skb = dev_alloc_skb(MWIFIEX_RX_CMD_BUF_SIZE);
./net/wireless/marvell/mwifiex/usb.c:614:		if (card->rx_cmd.skb)
./net/wireless/marvell/mwifiex/usb.c:615:			mwifiex_usb_submit_rx_urb(&card->rx_cmd,
./net/wireless/marvell/mwifiex/usb.c:633:	wait_for_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/usb.c:635:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/usb.c:639:	if (card->udev->state != USB_STATE_NOTATTACHED && !adapter->mfg_mode) {
./net/wireless/marvell/mwifiex/usb.c:675:	if (!(*len % card->bulk_out_maxpktsize))
./net/wireless/marvell/mwifiex/usb.c:679:	ret = usb_bulk_msg(card->udev, usb_sndbulkpipe(card->udev, ep), pbuf,
./net/wireless/marvell/mwifiex/usb.c:699:	ret = usb_bulk_msg(card->udev, usb_rcvbulkpipe(card->udev, ep), pbuf,
./net/wireless/marvell/mwifiex/usb.c:731:			card->port[i].block_status = false;
./net/wireless/marvell/mwifiex/usb.c:751:			if (active_port == card->port[i].tx_data_ep)
./net/wireless/marvell/mwifiex/usb.c:752:				card->port[i].block_status = false;
./net/wireless/marvell/mwifiex/usb.c:754:				card->port[i].block_status = true;
./net/wireless/marvell/mwifiex/usb.c:765:		if (priv->usb_port == card->port[idx].tx_data_ep)
./net/wireless/marvell/mwifiex/usb.c:766:			return !card->port[idx].block_status;
./net/wireless/marvell/mwifiex/usb.c:778:		if (!card->port[i].block_status)
./net/wireless/marvell/mwifiex/usb.c:798:	if (ep == card->tx_cmd_ep &&
./net/wireless/marvell/mwifiex/usb.c:799:	    card->tx_cmd_ep_type == USB_ENDPOINT_XFER_INT)
./net/wireless/marvell/mwifiex/usb.c:800:		usb_fill_int_urb(tx_urb, card->udev,
./net/wireless/marvell/mwifiex/usb.c:801:				 usb_sndintpipe(card->udev, ep), skb_send->data,
./net/wireless/marvell/mwifiex/usb.c:803:				 (void *)context, card->tx_cmd_interval);
./net/wireless/marvell/mwifiex/usb.c:805:		usb_fill_bulk_urb(tx_urb, card->udev,
./net/wireless/marvell/mwifiex/usb.c:806:				  usb_sndbulkpipe(card->udev, ep),
./net/wireless/marvell/mwifiex/usb.c:812:	if (ep == card->tx_cmd_ep)
./net/wireless/marvell/mwifiex/usb.c:813:		atomic_inc(&card->tx_cmd_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:817:	if (ep != card->tx_cmd_ep &&
./net/wireless/marvell/mwifiex/usb.c:828:		if (ep == card->tx_cmd_ep) {
./net/wireless/marvell/mwifiex/usb.c:829:			atomic_dec(&card->tx_cmd_urb_pending);
./net/wireless/marvell/mwifiex/usb.c:1167:	if (ep == card->tx_cmd_ep) {
./net/wireless/marvell/mwifiex/usb.c:1168:		context = &card->tx_cmd;
./net/wireless/marvell/mwifiex/usb.c:1172:			if (ep == card->port[idx].tx_data_ep) {
./net/wireless/marvell/mwifiex/usb.c:1173:				port = &card->port[idx];
./net/wireless/marvell/mwifiex/usb.c:1212:	card->tx_cmd.adapter = adapter;
./net/wireless/marvell/mwifiex/usb.c:1213:	card->tx_cmd.ep = card->tx_cmd_ep;
./net/wireless/marvell/mwifiex/usb.c:1215:	card->tx_cmd.urb = usb_alloc_urb(0, GFP_KERNEL);
./net/wireless/marvell/mwifiex/usb.c:1216:	if (!card->tx_cmd.urb)
./net/wireless/marvell/mwifiex/usb.c:1220:		port = &card->port[i];
./net/wireless/marvell/mwifiex/usb.c:1255:	card->rx_cmd.adapter = adapter;
./net/wireless/marvell/mwifiex/usb.c:1256:	card->rx_cmd.ep = card->rx_cmd_ep;
./net/wireless/marvell/mwifiex/usb.c:1258:	card->rx_cmd.urb = usb_alloc_urb(0, GFP_KERNEL);
./net/wireless/marvell/mwifiex/usb.c:1259:	if (!card->rx_cmd.urb)
./net/wireless/marvell/mwifiex/usb.c:1262:	card->rx_cmd.skb = dev_alloc_skb(MWIFIEX_RX_CMD_BUF_SIZE);
./net/wireless/marvell/mwifiex/usb.c:1263:	if (!card->rx_cmd.skb)
./net/wireless/marvell/mwifiex/usb.c:1266:	if (mwifiex_usb_submit_rx_urb(&card->rx_cmd, MWIFIEX_RX_CMD_BUF_SIZE))
./net/wireless/marvell/mwifiex/usb.c:1270:		card->rx_data_list[i].adapter = adapter;
./net/wireless/marvell/mwifiex/usb.c:1271:		card->rx_data_list[i].ep = card->rx_data_ep;
./net/wireless/marvell/mwifiex/usb.c:1273:		card->rx_data_list[i].urb = usb_alloc_urb(0, GFP_KERNEL);
./net/wireless/marvell/mwifiex/usb.c:1274:		if (!card->rx_data_list[i].urb)
./net/wireless/marvell/mwifiex/usb.c:1276:		if (mwifiex_usb_submit_rx_urb(&card->rx_data_list[i],
./net/wireless/marvell/mwifiex/usb.c:1289:	card->adapter = adapter;
./net/wireless/marvell/mwifiex/usb.c:1291:	switch (le16_to_cpu(card->udev->descriptor.idProduct)) {
./net/wireless/marvell/mwifiex/usb.c:1332:		port = &card->port[idx];
./net/wireless/marvell/mwifiex/usb.c:1350:	card->adapter = NULL;
./net/wireless/marvell/mwifiex/usb.c:1496:	if (card->usb_boot_state == USB8XXX_FW_DNLD) {
./net/wireless/marvell/mwifiex/usb.c:1502:		if (card->usb_boot_state == USB8XXX_FW_DNLD)
./net/wireless/marvell/mwifiex/usb.c:1517:	skb_push(card->rx_cmd.skb, INTF_HEADER_LEN);
./net/wireless/marvell/mwifiex/usb.c:1518:	if ((ep == card->rx_cmd_ep) &&
./net/wireless/marvell/mwifiex/usb.c:1519:	    (!atomic_read(&card->rx_cmd_urb_pending)))
./net/wireless/marvell/mwifiex/usb.c:1520:		mwifiex_usb_submit_rx_urb(&card->rx_cmd,
./net/wireless/marvell/mwifiex/usb.c:1553:		if (card->rx_data_list[i].skb)
./net/wireless/marvell/mwifiex/usb.c:1555:		ctx = &card->rx_data_list[i];
./net/wireless/marvell/mwifiex/pcie.c:61:	mapping.addr = pci_map_single(card->dev, skb->data, size, flags);
./net/wireless/marvell/mwifiex/pcie.c:62:	if (pci_dma_mapping_error(card->dev, mapping.addr)) {
./net/wireless/marvell/mwifiex/pcie.c:78:	pci_unmap_single(card->dev, mapping.addr, mapping.len, flags);
./net/wireless/marvell/mwifiex/pcie.c:88:	iowrite32(data, card->pci_mmap1 + reg);
./net/wireless/marvell/mwifiex/pcie.c:99:	*data = ioread32(card->pci_mmap1 + reg);
./net/wireless/marvell/mwifiex/pcie.c:112:	*data = ioread8(card->pci_mmap1 + reg);
./net/wireless/marvell/mwifiex/pcie.c:124:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:129:	if (card->sleep_cookie_vbase) {
./net/wireless/marvell/mwifiex/pcie.c:130:		cookie_value = get_unaligned_le32(card->sleep_cookie_vbase);
./net/wireless/marvell/mwifiex/pcie.c:159:	wait_for_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/pcie.c:161:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/pcie.c:203:	if (!card->adapter) {
./net/wireless/marvell/mwifiex/pcie.c:208:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/pcie.c:245:	init_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/pcie.c:247:	card->dev = pdev;
./net/wireless/marvell/mwifiex/pcie.c:251:		card->pcie.reg = data->reg;
./net/wireless/marvell/mwifiex/pcie.c:252:		card->pcie.blksz_fw_dl = data->blksz_fw_dl;
./net/wireless/marvell/mwifiex/pcie.c:253:		card->pcie.tx_buf_size = data->tx_buf_size;
./net/wireless/marvell/mwifiex/pcie.c:254:		card->pcie.can_dump_fw = data->can_dump_fw;
./net/wireless/marvell/mwifiex/pcie.c:255:		card->pcie.mem_type_mapping_tbl = data->mem_type_mapping_tbl;
./net/wireless/marvell/mwifiex/pcie.c:256:		card->pcie.num_mem_types = data->num_mem_types;
./net/wireless/marvell/mwifiex/pcie.c:257:		card->pcie.can_ext_scan = data->can_ext_scan;
./net/wireless/marvell/mwifiex/pcie.c:258:		INIT_WORK(&card->work, mwifiex_pcie_work);
./net/wireless/marvell/mwifiex/pcie.c:268:	if (mwifiex_add_card(card, &card->fw_done, &pcie_ops,
./net/wireless/marvell/mwifiex/pcie.c:291:	wait_for_completion(&card->fw_done);
./net/wireless/marvell/mwifiex/pcie.c:293:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/pcie.c:297:	reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:355:	struct mwifiex_adapter *adapter = card->adapter;
./net/wireless/marvell/mwifiex/pcie.c:368:	clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &card->work_flags);
./net/wireless/marvell/mwifiex/pcie.c:369:	clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags);
./net/wireless/marvell/mwifiex/pcie.c:381:	struct mwifiex_adapter *adapter = card->adapter;
./net/wireless/marvell/mwifiex/pcie.c:451:	struct sk_buff *cmdrsp = card->cmdrsp_buf;
./net/wireless/marvell/mwifiex/pcie.c:454:		pci_dma_sync_single_for_cpu(card->dev,
./net/wireless/marvell/mwifiex/pcie.c:466:		pci_dma_sync_single_for_device(card->dev,
./net/wireless/marvell/mwifiex/pcie.c:482:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:573:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:579:		card->tx_buf_list[i] = NULL;
./net/wireless/marvell/mwifiex/pcie.c:581:			card->txbd_ring[i] = (void *)card->txbd_ring_vbase +
./net/wireless/marvell/mwifiex/pcie.c:583:			desc2 = card->txbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:586:			card->txbd_ring[i] = (void *)card->txbd_ring_vbase +
./net/wireless/marvell/mwifiex/pcie.c:588:			desc = card->txbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:603:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:617:			kfree(card->rxbd_ring_vbase);
./net/wireless/marvell/mwifiex/pcie.c:633:		card->rx_buf_list[i] = skb;
./net/wireless/marvell/mwifiex/pcie.c:635:			card->rxbd_ring[i] = (void *)card->rxbd_ring_vbase +
./net/wireless/marvell/mwifiex/pcie.c:637:			desc2 = card->rxbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:644:			card->rxbd_ring[i] = (void *)(card->rxbd_ring_vbase +
./net/wireless/marvell/mwifiex/pcie.c:646:			desc = card->rxbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:674:			kfree(card->evtbd_ring_vbase);
./net/wireless/marvell/mwifiex/pcie.c:690:		card->evt_buf_list[i] = skb;
./net/wireless/marvell/mwifiex/pcie.c:691:		card->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +
./net/wireless/marvell/mwifiex/pcie.c:693:		desc = card->evtbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:708:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:716:			desc2 = card->txbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:717:			if (card->tx_buf_list[i]) {
./net/wireless/marvell/mwifiex/pcie.c:718:				skb = card->tx_buf_list[i];
./net/wireless/marvell/mwifiex/pcie.c:725:			desc = card->txbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:726:			if (card->tx_buf_list[i]) {
./net/wireless/marvell/mwifiex/pcie.c:727:				skb = card->tx_buf_list[i];
./net/wireless/marvell/mwifiex/pcie.c:734:		card->tx_buf_list[i] = NULL;
./net/wireless/marvell/mwifiex/pcie.c:747:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:755:			desc2 = card->rxbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:756:			if (card->rx_buf_list[i]) {
./net/wireless/marvell/mwifiex/pcie.c:757:				skb = card->rx_buf_list[i];
./net/wireless/marvell/mwifiex/pcie.c:764:			desc = card->rxbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:765:			if (card->rx_buf_list[i]) {
./net/wireless/marvell/mwifiex/pcie.c:766:				skb = card->rx_buf_list[i];
./net/wireless/marvell/mwifiex/pcie.c:773:		card->rx_buf_list[i] = NULL;
./net/wireless/marvell/mwifiex/pcie.c:790:		desc = card->evtbd_ring[i];
./net/wireless/marvell/mwifiex/pcie.c:791:		if (card->evt_buf_list[i]) {
./net/wireless/marvell/mwifiex/pcie.c:792:			skb = card->evt_buf_list[i];
./net/wireless/marvell/mwifiex/pcie.c:797:		card->evt_buf_list[i] = NULL;
./net/wireless/marvell/mwifiex/pcie.c:809:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:816:	card->txbd_wrptr = 0;
./net/wireless/marvell/mwifiex/pcie.c:819:		card->txbd_rdptr = 0;
./net/wireless/marvell/mwifiex/pcie.c:821:		card->txbd_rdptr |= reg->tx_rollover_ind;
./net/wireless/marvell/mwifiex/pcie.c:826:		card->txbd_ring_size = sizeof(struct mwifiex_pfu_buf_desc) *
./net/wireless/marvell/mwifiex/pcie.c:829:		card->txbd_ring_size = sizeof(struct mwifiex_pcie_buf_desc) *
./net/wireless/marvell/mwifiex/pcie.c:834:		    card->txbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:835:	card->txbd_ring_vbase = pci_alloc_consistent(card->dev,
./net/wireless/marvell/mwifiex/pcie.c:836:						     card->txbd_ring_size,
./net/wireless/marvell/mwifiex/pcie.c:837:						     &card->txbd_ring_pbase);
./net/wireless/marvell/mwifiex/pcie.c:838:	if (!card->txbd_ring_vbase) {
./net/wireless/marvell/mwifiex/pcie.c:841:			    card->txbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:846:		    card->txbd_ring_vbase, (unsigned int)card->txbd_ring_pbase,
./net/wireless/marvell/mwifiex/pcie.c:847:		    (u32)((u64)card->txbd_ring_pbase >> 32),
./net/wireless/marvell/mwifiex/pcie.c:848:		    card->txbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:856:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:860:	if (card->txbd_ring_vbase)
./net/wireless/marvell/mwifiex/pcie.c:861:		pci_free_consistent(card->dev, card->txbd_ring_size,
./net/wireless/marvell/mwifiex/pcie.c:862:				    card->txbd_ring_vbase,
./net/wireless/marvell/mwifiex/pcie.c:863:				    card->txbd_ring_pbase);
./net/wireless/marvell/mwifiex/pcie.c:864:	card->txbd_ring_size = 0;
./net/wireless/marvell/mwifiex/pcie.c:865:	card->txbd_wrptr = 0;
./net/wireless/marvell/mwifiex/pcie.c:866:	card->txbd_rdptr = 0 | reg->tx_rollover_ind;
./net/wireless/marvell/mwifiex/pcie.c:867:	card->txbd_ring_vbase = NULL;
./net/wireless/marvell/mwifiex/pcie.c:868:	card->txbd_ring_pbase = 0;
./net/wireless/marvell/mwifiex/pcie.c:879:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:886:	card->rxbd_wrptr = 0;
./net/wireless/marvell/mwifiex/pcie.c:887:	card->rxbd_rdptr = reg->rx_rollover_ind;
./net/wireless/marvell/mwifiex/pcie.c:890:		card->rxbd_ring_size = sizeof(struct mwifiex_pfu_buf_desc) *
./net/wireless/marvell/mwifiex/pcie.c:893:		card->rxbd_ring_size = sizeof(struct mwifiex_pcie_buf_desc) *
./net/wireless/marvell/mwifiex/pcie.c:898:		    card->rxbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:899:	card->rxbd_ring_vbase = pci_alloc_consistent(card->dev,
./net/wireless/marvell/mwifiex/pcie.c:900:						     card->rxbd_ring_size,
./net/wireless/marvell/mwifiex/pcie.c:901:						     &card->rxbd_ring_pbase);
./net/wireless/marvell/mwifiex/pcie.c:902:	if (!card->rxbd_ring_vbase) {
./net/wireless/marvell/mwifiex/pcie.c:905:			    card->rxbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:911:		    card->rxbd_ring_vbase, (u32)card->rxbd_ring_pbase,
./net/wireless/marvell/mwifiex/pcie.c:912:		    (u32)((u64)card->rxbd_ring_pbase >> 32),
./net/wireless/marvell/mwifiex/pcie.c:913:		    card->rxbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:924:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:928:	if (card->rxbd_ring_vbase)
./net/wireless/marvell/mwifiex/pcie.c:929:		pci_free_consistent(card->dev, card->rxbd_ring_size,
./net/wireless/marvell/mwifiex/pcie.c:930:				    card->rxbd_ring_vbase,
./net/wireless/marvell/mwifiex/pcie.c:931:				    card->rxbd_ring_pbase);
./net/wireless/marvell/mwifiex/pcie.c:932:	card->rxbd_ring_size = 0;
./net/wireless/marvell/mwifiex/pcie.c:933:	card->rxbd_wrptr = 0;
./net/wireless/marvell/mwifiex/pcie.c:934:	card->rxbd_rdptr = 0 | reg->rx_rollover_ind;
./net/wireless/marvell/mwifiex/pcie.c:935:	card->rxbd_ring_vbase = NULL;
./net/wireless/marvell/mwifiex/pcie.c:936:	card->rxbd_ring_pbase = 0;
./net/wireless/marvell/mwifiex/pcie.c:947:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:954:	card->evtbd_wrptr = 0;
./net/wireless/marvell/mwifiex/pcie.c:955:	card->evtbd_rdptr = reg->evt_rollover_ind;
./net/wireless/marvell/mwifiex/pcie.c:957:	card->evtbd_ring_size = sizeof(struct mwifiex_evt_buf_desc) *
./net/wireless/marvell/mwifiex/pcie.c:962:		card->evtbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:963:	card->evtbd_ring_vbase = pci_alloc_consistent(card->dev,
./net/wireless/marvell/mwifiex/pcie.c:964:						      card->evtbd_ring_size,
./net/wireless/marvell/mwifiex/pcie.c:965:						      &card->evtbd_ring_pbase);
./net/wireless/marvell/mwifiex/pcie.c:966:	if (!card->evtbd_ring_vbase) {
./net/wireless/marvell/mwifiex/pcie.c:969:			    card->evtbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:975:		    card->evtbd_ring_vbase, (u32)card->evtbd_ring_pbase,
./net/wireless/marvell/mwifiex/pcie.c:976:		    (u32)((u64)card->evtbd_ring_pbase >> 32),
./net/wireless/marvell/mwifiex/pcie.c:977:		    card->evtbd_ring_size);
./net/wireless/marvell/mwifiex/pcie.c:988:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:992:	if (card->evtbd_ring_vbase)
./net/wireless/marvell/mwifiex/pcie.c:993:		pci_free_consistent(card->dev, card->evtbd_ring_size,
./net/wireless/marvell/mwifiex/pcie.c:994:				    card->evtbd_ring_vbase,
./net/wireless/marvell/mwifiex/pcie.c:995:				    card->evtbd_ring_pbase);
./net/wireless/marvell/mwifiex/pcie.c:996:	card->evtbd_wrptr = 0;
./net/wireless/marvell/mwifiex/pcie.c:997:	card->evtbd_rdptr = 0 | reg->evt_rollover_ind;
./net/wireless/marvell/mwifiex/pcie.c:998:	card->evtbd_ring_size = 0;
./net/wireless/marvell/mwifiex/pcie.c:999:	card->evtbd_ring_vbase = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1000:	card->evtbd_ring_pbase = 0;
./net/wireless/marvell/mwifiex/pcie.c:1025:	card->cmdrsp_buf = skb;
./net/wireless/marvell/mwifiex/pcie.c:1042:	if (card && card->cmdrsp_buf) {
./net/wireless/marvell/mwifiex/pcie.c:1043:		mwifiex_unmap_pci_memory(adapter, card->cmdrsp_buf,
./net/wireless/marvell/mwifiex/pcie.c:1045:		dev_kfree_skb_any(card->cmdrsp_buf);
./net/wireless/marvell/mwifiex/pcie.c:1046:		card->cmdrsp_buf = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1049:	if (card && card->cmd_buf) {
./net/wireless/marvell/mwifiex/pcie.c:1050:		mwifiex_unmap_pci_memory(adapter, card->cmd_buf,
./net/wireless/marvell/mwifiex/pcie.c:1052:		dev_kfree_skb_any(card->cmd_buf);
./net/wireless/marvell/mwifiex/pcie.c:1053:		card->cmd_buf = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1066:	card->sleep_cookie_vbase = pci_alloc_consistent(card->dev, sizeof(u32),
./net/wireless/marvell/mwifiex/pcie.c:1067:						     &card->sleep_cookie_pbase);
./net/wireless/marvell/mwifiex/pcie.c:1068:	if (!card->sleep_cookie_vbase) {
./net/wireless/marvell/mwifiex/pcie.c:1075:	put_unaligned(tmp, card->sleep_cookie_vbase);
./net/wireless/marvell/mwifiex/pcie.c:1079:		    get_unaligned(card->sleep_cookie_vbase));
./net/wireless/marvell/mwifiex/pcie.c:1096:	if (card && card->sleep_cookie_vbase) {
./net/wireless/marvell/mwifiex/pcie.c:1097:		pci_free_consistent(card->dev, sizeof(u32),
./net/wireless/marvell/mwifiex/pcie.c:1098:				    card->sleep_cookie_vbase,
./net/wireless/marvell/mwifiex/pcie.c:1099:				    card->sleep_cookie_pbase);
./net/wireless/marvell/mwifiex/pcie.c:1100:		card->sleep_cookie_vbase = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1114:	if (!mwifiex_pcie_txbd_empty(card, card->txbd_rdptr)) {
./net/wireless/marvell/mwifiex/pcie.c:1115:		card->txbd_flush = 1;
./net/wireless/marvell/mwifiex/pcie.c:1139:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1153:		    card->txbd_rdptr, rdptr);
./net/wireless/marvell/mwifiex/pcie.c:1157:	while (((card->txbd_rdptr & reg->tx_mask) !=
./net/wireless/marvell/mwifiex/pcie.c:1159:	       ((card->txbd_rdptr & reg->tx_rollover_ind) !=
./net/wireless/marvell/mwifiex/pcie.c:1161:		wrdoneidx = (card->txbd_rdptr & reg->tx_mask) >>
./net/wireless/marvell/mwifiex/pcie.c:1164:		skb = card->tx_buf_list[wrdoneidx];
./net/wireless/marvell/mwifiex/pcie.c:1175:			if (card->txbd_flush)
./net/wireless/marvell/mwifiex/pcie.c:1183:		card->tx_buf_list[wrdoneidx] = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1186:			desc2 = card->txbd_ring[wrdoneidx];
./net/wireless/marvell/mwifiex/pcie.c:1189:			desc = card->txbd_ring[wrdoneidx];
./net/wireless/marvell/mwifiex/pcie.c:1192:		switch (card->dev->device) {
./net/wireless/marvell/mwifiex/pcie.c:1194:			card->txbd_rdptr++;
./net/wireless/marvell/mwifiex/pcie.c:1198:			card->txbd_rdptr += reg->ring_tx_start_ptr;
./net/wireless/marvell/mwifiex/pcie.c:1203:		if ((card->txbd_rdptr & reg->tx_mask) == num_tx_buffs)
./net/wireless/marvell/mwifiex/pcie.c:1204:			card->txbd_rdptr = ((card->txbd_rdptr &
./net/wireless/marvell/mwifiex/pcie.c:1212:	if (card->txbd_flush) {
./net/wireless/marvell/mwifiex/pcie.c:1213:		if (mwifiex_pcie_txbd_empty(card, card->txbd_rdptr))
./net/wireless/marvell/mwifiex/pcie.c:1214:			card->txbd_flush = 0;
./net/wireless/marvell/mwifiex/pcie.c:1234:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1254:		card->txbd_rdptr, card->txbd_wrptr);
./net/wireless/marvell/mwifiex/pcie.c:1267:		wrindx = (card->txbd_wrptr & reg->tx_mask) >> reg->tx_start_ptr;
./net/wireless/marvell/mwifiex/pcie.c:1269:		card->tx_buf_list[wrindx] = skb;
./net/wireless/marvell/mwifiex/pcie.c:1273:			desc2 = card->txbd_ring[wrindx];
./net/wireless/marvell/mwifiex/pcie.c:1281:			desc = card->txbd_ring[wrindx];
./net/wireless/marvell/mwifiex/pcie.c:1288:		switch (card->dev->device) {
./net/wireless/marvell/mwifiex/pcie.c:1290:			card->txbd_wrptr++;
./net/wireless/marvell/mwifiex/pcie.c:1294:			card->txbd_wrptr += reg->ring_tx_start_ptr;
./net/wireless/marvell/mwifiex/pcie.c:1298:		if ((card->txbd_wrptr & reg->tx_mask) == num_tx_buffs)
./net/wireless/marvell/mwifiex/pcie.c:1299:			card->txbd_wrptr = ((card->txbd_wrptr &
./net/wireless/marvell/mwifiex/pcie.c:1303:		rx_val = card->rxbd_rdptr & reg->rx_wrap_mask;
./net/wireless/marvell/mwifiex/pcie.c:1306:				      card->txbd_wrptr | rx_val)) {
./net/wireless/marvell/mwifiex/pcie.c:1331:			    card->txbd_rdptr, card->txbd_wrptr);
./net/wireless/marvell/mwifiex/pcie.c:1347:	card->tx_buf_list[wrindx] = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1364:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1382:	card->rxbd_wrptr = wrptr;
./net/wireless/marvell/mwifiex/pcie.c:1385:		(card->rxbd_rdptr & reg->rx_mask)) ||
./net/wireless/marvell/mwifiex/pcie.c:1387:		(card->rxbd_rdptr & reg->rx_rollover_ind))) {
./net/wireless/marvell/mwifiex/pcie.c:1391:		rd_index = card->rxbd_rdptr & reg->rx_mask;
./net/wireless/marvell/mwifiex/pcie.c:1392:		skb_data = card->rx_buf_list[rd_index];
./net/wireless/marvell/mwifiex/pcie.c:1401:		card->rx_buf_list[rd_index] = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1411:				    rx_len, card->rxbd_rdptr, wrptr);
./net/wireless/marvell/mwifiex/pcie.c:1417:				    card->rxbd_rdptr, wrptr, rx_len);
./net/wireless/marvell/mwifiex/pcie.c:1446:		card->rx_buf_list[rd_index] = skb_tmp;
./net/wireless/marvell/mwifiex/pcie.c:1449:			desc2 = card->rxbd_ring[rd_index];
./net/wireless/marvell/mwifiex/pcie.c:1456:			desc = card->rxbd_ring[rd_index];
./net/wireless/marvell/mwifiex/pcie.c:1462:		if ((++card->rxbd_rdptr & reg->rx_mask) ==
./net/wireless/marvell/mwifiex/pcie.c:1464:			card->rxbd_rdptr = ((card->rxbd_rdptr &
./net/wireless/marvell/mwifiex/pcie.c:1470:			    card->rxbd_rdptr, wrptr);
./net/wireless/marvell/mwifiex/pcie.c:1472:		tx_val = card->txbd_wrptr & reg->tx_wrap_mask;
./net/wireless/marvell/mwifiex/pcie.c:1475:				      card->rxbd_rdptr | tx_val)) {
./net/wireless/marvell/mwifiex/pcie.c:1491:		card->rxbd_wrptr = wrptr;
./net/wireless/marvell/mwifiex/pcie.c:1506:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1570:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1571:	int tx_wrap = card->txbd_wrptr & reg->tx_wrap_mask;
./net/wireless/marvell/mwifiex/pcie.c:1574:	if (mwifiex_write_reg(adapter, reg->rx_rdptr, card->rxbd_rdptr |
./net/wireless/marvell/mwifiex/pcie.c:1589:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1602:	if (!card->cmdrsp_buf) {
./net/wireless/marvell/mwifiex/pcie.c:1619:	card->cmd_buf = skb;
./net/wireless/marvell/mwifiex/pcie.c:1636:	if (card->cmdrsp_buf) {
./net/wireless/marvell/mwifiex/pcie.c:1637:		cmdrsp_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmdrsp_buf);
./net/wireless/marvell/mwifiex/pcie.c:1658:	cmd_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmd_buf);
./net/wireless/marvell/mwifiex/pcie.c:1678:			      card->cmd_buf->len)) {
./net/wireless/marvell/mwifiex/pcie.c:1707:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1708:	struct sk_buff *skb = card->cmdrsp_buf;
./net/wireless/marvell/mwifiex/pcie.c:1718:		pci_dma_sync_single_for_cpu(card->dev,
./net/wireless/marvell/mwifiex/pcie.c:1724:	if (card->cmd_buf) {
./net/wireless/marvell/mwifiex/pcie.c:1725:		mwifiex_unmap_pci_memory(adapter, card->cmd_buf,
./net/wireless/marvell/mwifiex/pcie.c:1727:		dev_kfree_skb_any(card->cmd_buf);
./net/wireless/marvell/mwifiex/pcie.c:1728:		card->cmd_buf = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1737:			pci_dma_sync_single_for_device(card->dev,
./net/wireless/marvell/mwifiex/pcie.c:1775:		card->cmdrsp_buf = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1806:		card->cmdrsp_buf = skb;
./net/wireless/marvell/mwifiex/pcie.c:1807:		skb_push(card->cmdrsp_buf, adapter->intf_hdr_len);
./net/wireless/marvell/mwifiex/pcie.c:1822:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1823:	u32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;
./net/wireless/marvell/mwifiex/pcie.c:1852:		    card->evtbd_rdptr, wrptr);
./net/wireless/marvell/mwifiex/pcie.c:1853:	if (((wrptr & MWIFIEX_EVTBD_MASK) != (card->evtbd_rdptr
./net/wireless/marvell/mwifiex/pcie.c:1856:	     (card->evtbd_rdptr & reg->evt_rollover_ind))) {
./net/wireless/marvell/mwifiex/pcie.c:1863:		skb_cmd = card->evt_buf_list[rdptr];
./net/wireless/marvell/mwifiex/pcie.c:1868:		card->evt_buf_list[rdptr] = NULL;
./net/wireless/marvell/mwifiex/pcie.c:1869:		desc = card->evtbd_ring[rdptr];
./net/wireless/marvell/mwifiex/pcie.c:1915:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:1917:	u32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;
./net/wireless/marvell/mwifiex/pcie.c:1938:	if (!card->evt_buf_list[rdptr]) {
./net/wireless/marvell/mwifiex/pcie.c:1945:		card->evt_buf_list[rdptr] = skb;
./net/wireless/marvell/mwifiex/pcie.c:1946:		desc = card->evtbd_ring[rdptr];
./net/wireless/marvell/mwifiex/pcie.c:1954:			    rdptr, card->evt_buf_list[rdptr], skb);
./net/wireless/marvell/mwifiex/pcie.c:1957:	if ((++card->evtbd_rdptr & MWIFIEX_EVTBD_MASK) == MWIFIEX_MAX_EVT_BD) {
./net/wireless/marvell/mwifiex/pcie.c:1958:		card->evtbd_rdptr = ((card->evtbd_rdptr &
./net/wireless/marvell/mwifiex/pcie.c:1965:		    card->evtbd_rdptr, wrptr);
./net/wireless/marvell/mwifiex/pcie.c:1969:			      card->evtbd_rdptr)) {
./net/wireless/marvell/mwifiex/pcie.c:2100:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2198:			tx_blocks = (txlen + card->pcie.blksz_fw_dl - 1) /
./net/wireless/marvell/mwifiex/pcie.c:2199:				    card->pcie.blksz_fw_dl;
./net/wireless/marvell/mwifiex/pcie.c:2206:		skb_trim(skb, tx_blocks * card->pcie.blksz_fw_dl);
./net/wireless/marvell/mwifiex/pcie.c:2266:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2319:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2344:	if (card->msi_enable) {
./net/wireless/marvell/mwifiex/pcie.c:2354:	if (card->msix_enable && msg_id >= 0) {
./net/wireless/marvell/mwifiex/pcie.c:2411:	if (!card->adapter) {
./net/wireless/marvell/mwifiex/pcie.c:2413:		       card ? card->adapter : NULL);
./net/wireless/marvell/mwifiex/pcie.c:2416:	adapter = card->adapter;
./net/wireless/marvell/mwifiex/pcie.c:2421:	if (card->msix_enable)
./net/wireless/marvell/mwifiex/pcie.c:2453:	if (!card->msi_enable) {
./net/wireless/marvell/mwifiex/pcie.c:2460:	if (card->msi_enable) {
./net/wireless/marvell/mwifiex/pcie.c:2520:	if (!card->msi_enable && !card->msix_enable &&
./net/wireless/marvell/mwifiex/pcie.c:2565:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2604:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2645:	const struct mwifiex_pcie_card_reg *creg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2653:	if (!card->pcie.can_dump_fw)
./net/wireless/marvell/mwifiex/pcie.c:2787:	pci_try_reset_function(card->dev);
./net/wireless/marvell/mwifiex/pcie.c:2796:			       &card->work_flags))
./net/wireless/marvell/mwifiex/pcie.c:2797:		mwifiex_pcie_device_dump_work(card->adapter);
./net/wireless/marvell/mwifiex/pcie.c:2799:			       &card->work_flags))
./net/wireless/marvell/mwifiex/pcie.c:2800:		mwifiex_pcie_card_reset_work(card->adapter);
./net/wireless/marvell/mwifiex/pcie.c:2809:			      &card->work_flags))
./net/wireless/marvell/mwifiex/pcie.c:2810:		schedule_work(&card->work);
./net/wireless/marvell/mwifiex/pcie.c:2817:	if (!test_and_set_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags))
./net/wireless/marvell/mwifiex/pcie.c:2818:		schedule_work(&card->work);
./net/wireless/marvell/mwifiex/pcie.c:2824:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2827:	card->cmdrsp_buf = NULL;
./net/wireless/marvell/mwifiex/pcie.c:2859:		card->sleep_cookie_vbase = NULL;
./net/wireless/marvell/mwifiex/pcie.c:2879:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2897:	struct pci_dev *pdev = card->dev;
./net/wireless/marvell/mwifiex/pcie.c:2925:	card->pci_mmap = pci_iomap(pdev, 0, 0);
./net/wireless/marvell/mwifiex/pcie.c:2926:	if (!card->pci_mmap) {
./net/wireless/marvell/mwifiex/pcie.c:2936:	card->pci_mmap1 = pci_iomap(pdev, 2, 0);
./net/wireless/marvell/mwifiex/pcie.c:2937:	if (!card->pci_mmap1) {
./net/wireless/marvell/mwifiex/pcie.c:2944:		  card->pci_mmap, card->pci_mmap1);
./net/wireless/marvell/mwifiex/pcie.c:2953:	pci_iounmap(pdev, card->pci_mmap1);
./net/wireless/marvell/mwifiex/pcie.c:2957:	pci_iounmap(pdev, card->pci_mmap);
./net/wireless/marvell/mwifiex/pcie.c:2973:	struct pci_dev *pdev = card->dev;
./net/wireless/marvell/mwifiex/pcie.c:2974:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:2978:	cancel_work_sync(&card->work);
./net/wireless/marvell/mwifiex/pcie.c:2991:	pci_iounmap(pdev, card->pci_mmap);
./net/wireless/marvell/mwifiex/pcie.c:2992:	pci_iounmap(pdev, card->pci_mmap1);
./net/wireless/marvell/mwifiex/pcie.c:3003:	struct pci_dev *pdev = card->dev;
./net/wireless/marvell/mwifiex/pcie.c:3005:	if (card->pcie.reg->msix_support) {
./net/wireless/marvell/mwifiex/pcie.c:3007:			card->msix_entries[i].entry = i;
./net/wireless/marvell/mwifiex/pcie.c:3008:		ret = pci_enable_msix_exact(pdev, card->msix_entries,
./net/wireless/marvell/mwifiex/pcie.c:3012:				card->msix_ctx[i].dev = pdev;
./net/wireless/marvell/mwifiex/pcie.c:3013:				card->msix_ctx[i].msg_id = i;
./net/wireless/marvell/mwifiex/pcie.c:3015:				ret = request_irq(card->msix_entries[i].vector,
./net/wireless/marvell/mwifiex/pcie.c:3018:						  &card->msix_ctx[i]);
./net/wireless/marvell/mwifiex/pcie.c:3027:					free_irq(card->msix_entries[j].vector,
./net/wireless/marvell/mwifiex/pcie.c:3028:						 &card->msix_ctx[i]);
./net/wireless/marvell/mwifiex/pcie.c:3032:				card->msix_enable = 1;
./net/wireless/marvell/mwifiex/pcie.c:3041:		card->msi_enable = 1;
./net/wireless/marvell/mwifiex/pcie.c:3043:	mwifiex_dbg(adapter, INFO, "msi_enable = %d\n", card->msi_enable);
./net/wireless/marvell/mwifiex/pcie.c:3045:	card->share_irq_ctx.dev = pdev;
./net/wireless/marvell/mwifiex/pcie.c:3046:	card->share_irq_ctx.msg_id = -1;
./net/wireless/marvell/mwifiex/pcie.c:3048:			  "MRVL_PCIE", &card->share_irq_ctx);
./net/wireless/marvell/mwifiex/pcie.c:3068:	switch (card->dev->device) {
./net/wireless/marvell/mwifiex/pcie.c:3118:	card->adapter = adapter;
./net/wireless/marvell/mwifiex/pcie.c:3123:	adapter->tx_buf_size = card->pcie.tx_buf_size;
./net/wireless/marvell/mwifiex/pcie.c:3124:	adapter->mem_type_mapping_tbl = card->pcie.mem_type_mapping_tbl;
./net/wireless/marvell/mwifiex/pcie.c:3125:	adapter->num_mem_types = card->pcie.num_mem_types;
./net/wireless/marvell/mwifiex/pcie.c:3126:	adapter->ext_scan = card->pcie.can_ext_scan;
./net/wireless/marvell/mwifiex/pcie.c:3141:	struct pci_dev *pdev = card->dev;
./net/wireless/marvell/mwifiex/pcie.c:3144:	if (card->msix_enable) {
./net/wireless/marvell/mwifiex/pcie.c:3146:			synchronize_irq(card->msix_entries[i].vector);
./net/wireless/marvell/mwifiex/pcie.c:3149:			free_irq(card->msix_entries[i].vector,
./net/wireless/marvell/mwifiex/pcie.c:3150:				 &card->msix_ctx[i]);
./net/wireless/marvell/mwifiex/pcie.c:3152:		card->msix_enable = 0;
./net/wireless/marvell/mwifiex/pcie.c:3157:	       free_irq(card->dev->irq, &card->share_irq_ctx);
./net/wireless/marvell/mwifiex/pcie.c:3159:		if (card->msi_enable)
./net/wireless/marvell/mwifiex/pcie.c:3162:	card->adapter = NULL;
./net/wireless/marvell/mwifiex/pcie.c:3172:	struct pci_dev *pdev = card->dev;
./net/wireless/marvell/mwifiex/pcie.c:3177:	adapter->tx_buf_size = card->pcie.tx_buf_size;
./net/wireless/marvell/mwifiex/pcie.c:3188:	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
./net/wireless/marvell/mwifiex/pcie.c:3189:	struct pci_dev *pdev = card->dev;
./net/wireless/marvell/mwifiex/main.c:1036:	card->mc_resync_flag = true;
./net/wireless/marvell/mwifiex/main.c:1038:		if (atomic_read(&card->port[i].tx_data_urb_pending)) {
./net/wireless/marvell/mwifiex/main.c:1044:	card->mc_resync_flag = false;
./net/wireless/marvell/mwifiex/main.c:1104:			     sdio_card->mp_rd_bitmap, sdio_card->curr_rd_port);
./net/wireless/marvell/mwifiex/main.c:1106:			     sdio_card->mp_wr_bitmap, sdio_card->curr_wr_port);
./net/wireless/marvell/libertas/if_sdio.c:152:	scratch = sdio_readb(card->func, card->scratch_reg, &ret);
./net/wireless/marvell/libertas/if_sdio.c:154:		scratch |= sdio_readb(card->func, card->scratch_reg + 1,
./net/wireless/marvell/libertas/if_sdio.c:171:	rx_unit = sdio_readb(card->func, IF_SDIO_RX_UNIT, &ret);
./net/wireless/marvell/libertas/if_sdio.c:184:	switch (card->model) {
./net/wireless/marvell/libertas/if_sdio.c:191:		rx_len = sdio_readb(card->func, IF_SDIO_RX_LEN, &ret);
./net/wireless/marvell/libertas/if_sdio.c:193:			rx_len <<= card->rx_unit;
./net/wireless/marvell/libertas/if_sdio.c:209:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_sdio.c:260:	lbs_process_rxed_packet(card->priv, skb);
./net/wireless/marvell/libertas/if_sdio.c:274:	if (card->model == MODEL_8385) {
./net/wireless/marvell/libertas/if_sdio.c:275:		event = sdio_readb(card->func, IF_SDIO_EVENT, &ret);
./net/wireless/marvell/libertas/if_sdio.c:294:	lbs_queue_event(card->priv, event & 0xFF);
./net/wireless/marvell/libertas/if_sdio.c:309:		status = sdio_readb(card->func, IF_SDIO_STATUS, &ret);
./net/wireless/marvell/libertas/if_sdio.c:346:	chunk = sdio_align_size(card->func, size);
./net/wireless/marvell/libertas/if_sdio.c:348:	ret = sdio_readsb(card->func, card->buffer, card->ioport, chunk);
./net/wireless/marvell/libertas/if_sdio.c:352:	chunk = card->buffer[0] | (card->buffer[1] << 8);
./net/wireless/marvell/libertas/if_sdio.c:353:	type = card->buffer[2] | (card->buffer[3] << 8);
./net/wireless/marvell/libertas/if_sdio.c:372:		ret = if_sdio_handle_cmd(card, card->buffer + 4, chunk - 4);
./net/wireless/marvell/libertas/if_sdio.c:377:		ret = if_sdio_handle_data(card, card->buffer + 4, chunk - 4);
./net/wireless/marvell/libertas/if_sdio.c:382:		ret = if_sdio_handle_event(card, card->buffer + 4, chunk - 4);
./net/wireless/marvell/libertas/if_sdio.c:410:		spin_lock_irqsave(&card->lock, flags);
./net/wireless/marvell/libertas/if_sdio.c:411:		packet = card->packets;
./net/wireless/marvell/libertas/if_sdio.c:413:			card->packets = packet->next;
./net/wireless/marvell/libertas/if_sdio.c:414:		spin_unlock_irqrestore(&card->lock, flags);
./net/wireless/marvell/libertas/if_sdio.c:419:		sdio_claim_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:423:			ret = sdio_writesb(card->func, card->ioport,
./net/wireless/marvell/libertas/if_sdio.c:430:		sdio_release_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:458:	sdio_claim_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:460:	ret = sdio_set_block_size(card->func, 32);
./net/wireless/marvell/libertas/if_sdio.c:484:		ret = sdio_writesb(card->func, card->ioport,
./net/wireless/marvell/libertas/if_sdio.c:495:	ret = sdio_writesb(card->func, card->ioport, chunk_buffer, 64);
./net/wireless/marvell/libertas/if_sdio.c:506:		req_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);
./net/wireless/marvell/libertas/if_sdio.c:510:		req_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;
./net/wireless/marvell/libertas/if_sdio.c:528:	sdio_release_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:554:	sdio_claim_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:556:	ret = sdio_set_block_size(card->func, 32);
./net/wireless/marvell/libertas/if_sdio.c:570:			req_size = sdio_readb(card->func, IF_SDIO_RD_BASE,
./net/wireless/marvell/libertas/if_sdio.c:575:			req_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1,
./net/wireless/marvell/libertas/if_sdio.c:622:			ret = sdio_writesb(card->func, card->ioport,
./net/wireless/marvell/libertas/if_sdio.c:660:	sdio_release_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:703:	sdio_claim_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:704:	sdio_writeb(card->func, 0x00, IF_SDIO_H_INT_MASK, &ret);
./net/wireless/marvell/libertas/if_sdio.c:705:	sdio_release_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:707:	sdio_claim_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:709:	sdio_release_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:732:	} else if ((card->model == MODEL_8686) && (scratch & 0x7fff)) {
./net/wireless/marvell/libertas/if_sdio.c:738:	ret = lbs_get_firmware_async(card->priv, &card->func->dev, card->model,
./net/wireless/marvell/libertas/if_sdio.c:752:	struct sdio_func *func = card->func;
./net/wireless/marvell/libertas/if_sdio.c:753:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_sdio.c:757:	sdio_set_block_size(card->func, IF_SDIO_BLOCK_SIZE);
./net/wireless/marvell/libertas/if_sdio.c:763:	if ((card->model != MODEL_8385)
./net/wireless/marvell/libertas/if_sdio.c:764:			&& (card->model != MODEL_8686))
./net/wireless/marvell/libertas/if_sdio.c:765:		card->rx_unit = if_sdio_read_rx_unit(card);
./net/wireless/marvell/libertas/if_sdio.c:767:		card->rx_unit = 0;
./net/wireless/marvell/libertas/if_sdio.c:801:	if (card->model == MODEL_8688) {
./net/wireless/marvell/libertas/if_sdio.c:812:	wake_up(&card->pwron_waitq);
./net/wireless/marvell/libertas/if_sdio.c:814:	if (!card->started) {
./net/wireless/marvell/libertas/if_sdio.c:818:			card->started = true;
./net/wireless/marvell/libertas/if_sdio.c:835:	struct sdio_func *func = card->func;
./net/wireless/marvell/libertas/if_sdio.c:836:	struct mmc_host *host = func->card->host;
./net/wireless/marvell/libertas/if_sdio.c:848:	if ((card->model == MODEL_8686) &&
./net/wireless/marvell/libertas/if_sdio.c:853:		func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
./net/wireless/marvell/libertas/if_sdio.c:864:	card->ioport = sdio_readb(func, IF_SDIO_IOPORT, &ret);
./net/wireless/marvell/libertas/if_sdio.c:868:	card->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 1, &ret) << 8;
./net/wireless/marvell/libertas/if_sdio.c:872:	card->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 2, &ret) << 16;
./net/wireless/marvell/libertas/if_sdio.c:894:	struct sdio_func *func = card->func;
./net/wireless/marvell/libertas/if_sdio.c:895:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_sdio.c:932:	size = sdio_align_size(card->func, nb + 4);
./net/wireless/marvell/libertas/if_sdio.c:954:	spin_lock_irqsave(&card->lock, flags);
./net/wireless/marvell/libertas/if_sdio.c:956:	if (!card->packets)
./net/wireless/marvell/libertas/if_sdio.c:957:		card->packets = packet;
./net/wireless/marvell/libertas/if_sdio.c:959:		cur = card->packets;
./net/wireless/marvell/libertas/if_sdio.c:976:	spin_unlock_irqrestore(&card->lock, flags);
./net/wireless/marvell/libertas/if_sdio.c:978:	queue_work(card->workqueue, &card->packet_worker);
./net/wireless/marvell/libertas/if_sdio.c:1008:	sdio_claim_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:1010:	sdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);
./net/wireless/marvell/libertas/if_sdio.c:1014:	sdio_release_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:1024:	sdio_claim_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:1026:	sdio_writeb(card->func, 0, CONFIGURATION_REG, &ret);
./net/wireless/marvell/libertas/if_sdio.c:1030:	sdio_release_host(card->func);
./net/wireless/marvell/libertas/if_sdio.c:1063:	reset_host = card->func->card->host;
./net/wireless/marvell/libertas/if_sdio.c:1072:	flush_workqueue(card->workqueue);
./net/wireless/marvell/libertas/if_sdio.c:1077:	pm_runtime_put_sync(&card->func->dev);
./net/wireless/marvell/libertas/if_sdio.c:1088:	pm_runtime_get_sync(&card->func->dev);
./net/wireless/marvell/libertas/if_sdio.c:1094:	wait_event(card->pwron_waitq, priv->fw_ready);
./net/wireless/marvell/libertas/if_sdio.c:1111:	cause = sdio_readb(card->func, IF_SDIO_H_INT_STATUS, &ret);
./net/wireless/marvell/libertas/if_sdio.c:1117:	sdio_writeb(card->func, ~cause, IF_SDIO_H_INT_STATUS, &ret);
./net/wireless/marvell/libertas/if_sdio.c:1125:	card->priv->is_activity_detected = 1;
./net/wireless/marvell/libertas/if_sdio.c:1127:		lbs_host_to_card_done(card->priv);
./net/wireless/marvell/libertas/if_sdio.c:1146:	for (i = 0;i < func->card->num_info;i++) {
./net/wireless/marvell/libertas/if_sdio.c:1147:		if (sscanf(func->card->info[i],
./net/wireless/marvell/libertas/if_sdio.c:1150:		if (sscanf(func->card->info[i],
./net/wireless/marvell/libertas/if_sdio.c:1153:		if (!strcmp(func->card->info[i], "IBIS Wireless SDIO Card")) {
./net/wireless/marvell/libertas/if_sdio.c:1159:	if (i == func->card->num_info) {
./net/wireless/marvell/libertas/if_sdio.c:1168:	card->func = func;
./net/wireless/marvell/libertas/if_sdio.c:1169:	card->model = model;
./net/wireless/marvell/libertas/if_sdio.c:1171:	switch (card->model) {
./net/wireless/marvell/libertas/if_sdio.c:1173:		card->scratch_reg = IF_SDIO_SCRATCH_OLD;
./net/wireless/marvell/libertas/if_sdio.c:1176:		card->scratch_reg = IF_SDIO_SCRATCH;
./net/wireless/marvell/libertas/if_sdio.c:1180:		card->scratch_reg = IF_SDIO_FW_STATUS;
./net/wireless/marvell/libertas/if_sdio.c:1184:	spin_lock_init(&card->lock);
./net/wireless/marvell/libertas/if_sdio.c:1185:	card->workqueue = alloc_workqueue("libertas_sdio", WQ_MEM_RECLAIM, 0);
./net/wireless/marvell/libertas/if_sdio.c:1186:	INIT_WORK(&card->packet_worker, if_sdio_host_to_card_worker);
./net/wireless/marvell/libertas/if_sdio.c:1187:	init_waitqueue_head(&card->pwron_waitq);
./net/wireless/marvell/libertas/if_sdio.c:1191:		if (card->model == fw_table[i].model)
./net/wireless/marvell/libertas/if_sdio.c:1195:		pr_err("unknown card model 0x%x\n", card->model);
./net/wireless/marvell/libertas/if_sdio.c:1205:			model, (unsigned)card->ioport);
./net/wireless/marvell/libertas/if_sdio.c:1214:	card->priv = priv;
./net/wireless/marvell/libertas/if_sdio.c:1224:	priv->is_polling = !(func->card->host->caps & MMC_CAP_SDIO_IRQ);
./net/wireless/marvell/libertas/if_sdio.c:1233:	flush_workqueue(card->workqueue);
./net/wireless/marvell/libertas/if_sdio.c:1236:	destroy_workqueue(card->workqueue);
./net/wireless/marvell/libertas/if_sdio.c:1237:	while (card->packets) {
./net/wireless/marvell/libertas/if_sdio.c:1238:		packet = card->packets;
./net/wireless/marvell/libertas/if_sdio.c:1239:		card->packets = card->packets->next;
./net/wireless/marvell/libertas/if_sdio.c:1258:	if (user_rmmod && (card->model == MODEL_8688)) {
./net/wireless/marvell/libertas/if_sdio.c:1268:		if (__lbs_cmd(card->priv, CMD_FUNC_SHUTDOWN,
./net/wireless/marvell/libertas/if_sdio.c:1276:	lbs_stop_card(card->priv);
./net/wireless/marvell/libertas/if_sdio.c:1277:	lbs_remove_card(card->priv);
./net/wireless/marvell/libertas/if_sdio.c:1279:	destroy_workqueue(card->workqueue);
./net/wireless/marvell/libertas/if_sdio.c:1281:	while (card->packets) {
./net/wireless/marvell/libertas/if_sdio.c:1282:		packet = card->packets;
./net/wireless/marvell/libertas/if_sdio.c:1283:		card->packets = card->packets->next;
./net/wireless/marvell/libertas/if_sdio.c:1294:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_sdio.c:1356:	if (card->priv->power_up_on_resume) {
./net/wireless/marvell/libertas/if_sdio.c:1358:		wait_event(card->pwron_waitq, card->priv->fw_ready);
./net/wireless/marvell/libertas/if_sdio.c:1361:	ret = lbs_resume(card->priv);
./net/wireless/marvell/libertas/if_spi.c:86:	list_for_each_safe(cursor, next, &card->cmd_packet_list) {
./net/wireless/marvell/libertas/if_spi.c:91:	list_for_each_safe(cursor, next, &card->data_packet_list) {
./net/wireless/marvell/libertas/if_spi.c:135:	if (!time_after(jiffies, card->prev_xfer_time + 1)) {
./net/wireless/marvell/libertas/if_spi.c:146:	card->prev_xfer_time = jiffies;
./net/wireless/marvell/libertas/if_spi.c:181:	err = spi_sync(card->spi, &m);
./net/wireless/marvell/libertas/if_spi.c:234:	delay = spu_reg_is_port_reg(reg) ? card->spu_port_delay :
./net/wireless/marvell/libertas/if_spi.c:235:						card->spu_reg_delay;
./net/wireless/marvell/libertas/if_spi.c:236:	if (card->use_dummy_writes) {
./net/wireless/marvell/libertas/if_spi.c:251:	err = spi_sync(card->spi, &m);
./net/wireless/marvell/libertas/if_spi.c:425:	card->use_dummy_writes = 0;
./net/wireless/marvell/libertas/if_spi.c:432:	card->spu_port_delay = 1000;
./net/wireless/marvell/libertas/if_spi.c:433:	card->spu_reg_delay = 1000;
./net/wireless/marvell/libertas/if_spi.c:437:	card->spu_port_delay = delay & 0x0000ffff;
./net/wireless/marvell/libertas/if_spi.c:438:	card->spu_reg_delay = (delay & 0xffff0000) >> 16;
./net/wireless/marvell/libertas/if_spi.c:442:		card->use_dummy_writes = 1;
./net/wireless/marvell/libertas/if_spi.c:453:		    card->spu_port_delay, card->spu_reg_delay);
./net/wireless/marvell/libertas/if_spi.c:583:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_spi.c:632:			memset(card->cmd_buffer, 0, len);
./net/wireless/marvell/libertas/if_spi.c:633:			memcpy(card->cmd_buffer, fw, bytes);
./net/wireless/marvell/libertas/if_spi.c:635:			memcpy(card->cmd_buffer, fw, len);
./net/wireless/marvell/libertas/if_spi.c:641:				card->cmd_buffer, len);
./net/wireless/marvell/libertas/if_spi.c:678:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_spi.c:717:				card->cmd_buffer, ALIGN(len, 4));
./net/wireless/marvell/libertas/if_spi.c:725:	memcpy(priv->resp_buf[i], card->cmd_buffer, len);
./net/wireless/marvell/libertas/if_spi.c:739:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_spi.c:777:	err = lbs_process_rxed_packet(card->priv, skb);
./net/wireless/marvell/libertas/if_spi.c:797:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_spi.c:834:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_spi.c:863:	priv = card->priv;
./net/wireless/marvell/libertas/if_spi.c:892:	   (card->priv->psstate != PS_STATE_FULL_POWER &&
./net/wireless/marvell/libertas/if_spi.c:901:		lbs_host_to_card_done(card->priv);
./net/wireless/marvell/libertas/if_spi.c:905:		spin_lock_irqsave(&card->buffer_lock, flags);
./net/wireless/marvell/libertas/if_spi.c:906:		if (!list_empty(&card->cmd_packet_list)) {
./net/wireless/marvell/libertas/if_spi.c:907:			packet = (struct if_spi_packet *)(card->
./net/wireless/marvell/libertas/if_spi.c:911:		spin_unlock_irqrestore(&card->buffer_lock, flags);
./net/wireless/marvell/libertas/if_spi.c:919:		spin_lock_irqsave(&card->buffer_lock, flags);
./net/wireless/marvell/libertas/if_spi.c:920:		if (!list_empty(&card->data_packet_list)) {
./net/wireless/marvell/libertas/if_spi.c:921:			packet = (struct if_spi_packet *)(card->
./net/wireless/marvell/libertas/if_spi.c:925:		spin_unlock_irqrestore(&card->buffer_lock, flags);
./net/wireless/marvell/libertas/if_spi.c:972:		spin_lock_irqsave(&card->buffer_lock, flags);
./net/wireless/marvell/libertas/if_spi.c:973:		list_add_tail(&packet->list, &card->cmd_packet_list);
./net/wireless/marvell/libertas/if_spi.c:974:		spin_unlock_irqrestore(&card->buffer_lock, flags);
./net/wireless/marvell/libertas/if_spi.c:978:		spin_lock_irqsave(&card->buffer_lock, flags);
./net/wireless/marvell/libertas/if_spi.c:979:		list_add_tail(&packet->list, &card->data_packet_list);
./net/wireless/marvell/libertas/if_spi.c:980:		spin_unlock_irqrestore(&card->buffer_lock, flags);
./net/wireless/marvell/libertas/if_spi.c:991:	queue_work(card->workqueue, &card->packet_work);
./net/wireless/marvell/libertas/if_spi.c:1006:	queue_work(card->workqueue, &card->packet_work);
./net/wireless/marvell/libertas/if_spi.c:1017:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_spi.c:1023:	err = spu_init(card, card->pdata->use_dummy_writes);
./net/wireless/marvell/libertas/if_spi.c:1026:	err = spu_get_chip_revision(card, &card->card_id, &card->card_rev);
./net/wireless/marvell/libertas/if_spi.c:1039:			if (card->card_id == fw_table[i].model)
./net/wireless/marvell/libertas/if_spi.c:1044:				   card->card_id);
./net/wireless/marvell/libertas/if_spi.c:1049:		err = lbs_get_firmware(&card->spi->dev, card->card_id,
./net/wireless/marvell/libertas/if_spi.c:1061:				card->card_id, card->card_rev,
./net/wireless/marvell/libertas/if_spi.c:1062:				card->spi->master->bus_num,
./net/wireless/marvell/libertas/if_spi.c:1063:				card->spi->chip_select,
./net/wireless/marvell/libertas/if_spi.c:1064:				card->spi->max_speed_hz);
./net/wireless/marvell/libertas/if_spi.c:1088:	if (card->suspended) {
./net/wireless/marvell/libertas/if_spi.c:1089:		if (card->pdata->setup)
./net/wireless/marvell/libertas/if_spi.c:1090:			card->pdata->setup(card->spi);
./net/wireless/marvell/libertas/if_spi.c:1095:		enable_irq(card->spi->irq);
./net/wireless/marvell/libertas/if_spi.c:1098:		lbs_resume(card->priv);
./net/wireless/marvell/libertas/if_spi.c:1100:		card->suspended = 0;
./net/wireless/marvell/libertas/if_spi.c:1129:	card->pdata = pdata;
./net/wireless/marvell/libertas/if_spi.c:1130:	card->spi = spi;
./net/wireless/marvell/libertas/if_spi.c:1131:	card->prev_xfer_time = jiffies;
./net/wireless/marvell/libertas/if_spi.c:1133:	INIT_LIST_HEAD(&card->cmd_packet_list);
./net/wireless/marvell/libertas/if_spi.c:1134:	INIT_LIST_HEAD(&card->data_packet_list);
./net/wireless/marvell/libertas/if_spi.c:1135:	spin_lock_init(&card->buffer_lock);
./net/wireless/marvell/libertas/if_spi.c:1153:	card->priv = priv;
./net/wireless/marvell/libertas/if_spi.c:1163:	card->workqueue = alloc_workqueue("libertas_spi", WQ_MEM_RECLAIM, 0);
./net/wireless/marvell/libertas/if_spi.c:1164:	if (!card->workqueue) {
./net/wireless/marvell/libertas/if_spi.c:1168:	INIT_WORK(&card->packet_work, if_spi_host_to_card_worker);
./net/wireless/marvell/libertas/if_spi.c:1169:	INIT_WORK(&card->resume_work, if_spi_resume_worker);
./net/wireless/marvell/libertas/if_spi.c:1195:	destroy_workqueue(card->workqueue);
./net/wireless/marvell/libertas/if_spi.c:1210:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_spi.c:1214:	cancel_work_sync(&card->resume_work);
./net/wireless/marvell/libertas/if_spi.c:1220:	destroy_workqueue(card->workqueue);
./net/wireless/marvell/libertas/if_spi.c:1221:	if (card->pdata->teardown)
./net/wireless/marvell/libertas/if_spi.c:1222:		card->pdata->teardown(spi);
./net/wireless/marvell/libertas/if_spi.c:1233:	if (!card->suspended) {
./net/wireless/marvell/libertas/if_spi.c:1234:		lbs_suspend(card->priv);
./net/wireless/marvell/libertas/if_spi.c:1235:		flush_workqueue(card->workqueue);
./net/wireless/marvell/libertas/if_spi.c:1238:		if (card->pdata->teardown)
./net/wireless/marvell/libertas/if_spi.c:1239:			card->pdata->teardown(spi);
./net/wireless/marvell/libertas/if_spi.c:1240:		card->suspended = 1;
./net/wireless/marvell/libertas/if_spi.c:1252:	schedule_work(&card->resume_work);
./net/wireless/marvell/libertas/if_cs.c:111:	unsigned int val = ioread8(card->iobase + reg);
./net/wireless/marvell/libertas/if_cs.c:118:	unsigned int val = ioread16(card->iobase + reg);
./net/wireless/marvell/libertas/if_cs.c:132:	ioread16_rep(card->iobase + reg, buf, count);
./net/wireless/marvell/libertas/if_cs.c:139:	iowrite8(val, card->iobase + reg);
./net/wireless/marvell/libertas/if_cs.c:146:	iowrite16(val, card->iobase + reg);
./net/wireless/marvell/libertas/if_cs.c:158:	iowrite16_rep(card->iobase + reg, buf, count);
./net/wireless/marvell/libertas/if_cs.c:498:	struct lbs_private *priv = card->priv;
./net/wireless/marvell/libertas/if_cs.c:512:		card->priv->surpriseremoved = 1;
./net/wireless/marvell/libertas/if_cs.c:583:	if (card->align_regs)
./net/wireless/marvell/libertas/if_cs.c:732:	if (ret == 0 && (card->model != MODEL_8305))
./net/wireless/marvell/libertas/if_cs.c:738:	ret = request_irq(card->p_dev->irq, if_cs_interrupt,
./net/wireless/marvell/libertas/if_cs.c:756:		free_irq(card->p_dev->irq, card);
./net/wireless/marvell/libertas/if_cs.c:798:	if (card->iobase)
./net/wireless/marvell/libertas/if_cs.c:799:		ioport_unmap(card->iobase);
./net/wireless/marvell/libertas/if_cs.c:828:	card->p_dev = p_dev;
./net/wireless/marvell/libertas/if_cs.c:847:	card->iobase = ioport_map(p_dev->resource[0]->start,
./net/wireless/marvell/libertas/if_cs.c:849:	if (!card->iobase) {
./net/wireless/marvell/libertas/if_cs.c:868:	card->align_regs = false;
./net/wireless/marvell/libertas/if_cs.c:870:	card->model = get_model(p_dev->manf_id, p_dev->card_id);
./net/wireless/marvell/libertas/if_cs.c:871:	if (card->model == MODEL_UNKNOWN) {
./net/wireless/marvell/libertas/if_cs.c:880:	if (card->model == MODEL_8305) {
./net/wireless/marvell/libertas/if_cs.c:881:		card->align_regs = true;
./net/wireless/marvell/libertas/if_cs.c:889:	if ((card->model == MODEL_8381) && prod_id < IF_CS_CF8381_B3_REV) {
./net/wireless/marvell/libertas/if_cs.c:895:	if ((card->model == MODEL_8385) && prod_id < IF_CS_CF8385_B1_REV) {
./net/wireless/marvell/libertas/if_cs.c:909:	card->priv = priv;
./net/wireless/marvell/libertas/if_cs.c:917:	ret = lbs_get_firmware_async(priv, &p_dev->dev, card->model, fw_table,
./net/wireless/marvell/libertas/if_cs.c:929:	ioport_unmap(card->iobase);
./net/wireless/marvell/libertas/if_cs.c:941:	lbs_stop_card(card->priv);
./net/wireless/marvell/libertas/if_cs.c:942:	lbs_remove_card(card->priv);
./net/wireless/intel/iwlegacy/3945-mac.c:2804:	 * ucode filename and max sizes are card-specific. */
./net/wireless/ath/ath10k/sdio.c:116:	return mmc_wait_for_cmd(card->host, &io_cmd, 0);
./net/wireless/ath/ath10k/sdio.c:131:	ret = mmc_wait_for_cmd(card->host, &io_cmd, 0);
./net/wireless/ath/ath6kl/sdio.c:147:	return mmc_wait_for_cmd(card->host, &io_cmd, 0);
./net/wireless/ath/ath6kl/sdio.c:325:	mmc_wait_for_req(ar_sdio->func->card->host, &mmc_req);
./net/wireless/ath/ath6kl/sdio.c:744:	if (ar_sdio->func->card->host->max_segs < MAX_SCATTER_ENTRIES_PER_REQ) {
./net/wireless/ath/ath6kl/sdio.c:746:			   ar_sdio->func->card->host->max_segs,
./net/wireless/ath/ath6kl/sdio.c:923:	if (func->card && func->card->host)
./net/wireless/ath/ath6kl/sdio.c:924:		func->card->host->pm_flags &= ~MMC_PM_KEEP_POWER;
./net/wireless/ath/wil6210/main.c:938:	/* clear any interrupts which on-card-firmware
./net/wireless/intersil/orinoco/orinoco_tmd.c:67:	iowrite8(COR_VALUE | COR_RESET, card->bridge_io);
./net/wireless/intersil/orinoco/orinoco_tmd.c:70:	iowrite8(COR_VALUE, card->bridge_io);
./net/wireless/intersil/orinoco/orinoco_tmd.c:135:	card->bridge_io = bridge_io;
./net/wireless/intersil/orinoco/orinoco_tmd.c:199:	pci_iounmap(pdev, card->bridge_io);
./net/wireless/intersil/orinoco/orinoco_nortel.c:70:	iowrite16(8, card->bridge_io + 2);
./net/wireless/intersil/orinoco/orinoco_nortel.c:71:	ioread16(card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_nortel.c:72:	iowrite16(0x80, card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_nortel.c:76:	iowrite16(0, card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_nortel.c:77:	iowrite16(0, card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_nortel.c:81:	iowrite16(COR_VALUE, card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_nortel.c:82:	iowrite16(COR_VALUE, card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_nortel.c:85:	iowrite16(0x228, card->bridge_io + 2);
./net/wireless/intersil/orinoco/orinoco_nortel.c:96:	if (ioread16(card->bridge_io) & 1) {
./net/wireless/intersil/orinoco/orinoco_nortel.c:100:	iowrite16(0x118, card->bridge_io + 2);
./net/wireless/intersil/orinoco/orinoco_nortel.c:101:	iowrite16(0x108, card->bridge_io + 2);
./net/wireless/intersil/orinoco/orinoco_nortel.c:103:	iowrite16(0x8, card->bridge_io + 2);
./net/wireless/intersil/orinoco/orinoco_nortel.c:106:		if (ioread16(card->bridge_io) & 0x10)
./net/wireless/intersil/orinoco/orinoco_nortel.c:113:	if (ioread16(card->attr_io + COR_OFFSET) & 1) {
./net/wireless/intersil/orinoco/orinoco_nortel.c:117:	if (ioread16(card->attr_io + COR_OFFSET + 2) & 1) {
./net/wireless/intersil/orinoco/orinoco_nortel.c:121:	if (ioread16(card->attr_io + COR_OFFSET + 4) & 1) {
./net/wireless/intersil/orinoco/orinoco_nortel.c:127:	iowrite16(COR_VALUE, card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_nortel.c:129:	reg = ioread16(card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_nortel.c:137:	iowrite16(1, card->bridge_io + 10);
./net/wireless/intersil/orinoco/orinoco_nortel.c:192:	card->bridge_io = bridge_io;
./net/wireless/intersil/orinoco/orinoco_nortel.c:193:	card->attr_io = attr_io;
./net/wireless/intersil/orinoco/orinoco_nortel.c:265:	iowrite16(0, card->bridge_io + 10);
./net/wireless/intersil/orinoco/orinoco_nortel.c:272:	pci_iounmap(pdev, card->attr_io);
./net/wireless/intersil/orinoco/orinoco_nortel.c:273:	pci_iounmap(pdev, card->bridge_io);
./net/wireless/intersil/orinoco/orinoco_cs.c:74:	struct pcmcia_device *link = card->p_dev;
./net/wireless/intersil/orinoco/orinoco_cs.c:78:	set_bit(0, &card->hard_reset_in_progress);
./net/wireless/intersil/orinoco/orinoco_cs.c:85:	clear_bit(0, &card->hard_reset_in_progress);
./net/wireless/intersil/orinoco/orinoco_cs.c:107:	card->p_dev = link;
./net/wireless/intersil/orinoco/orinoco_cs.c:217:	if (!test_bit(0, &card->hard_reset_in_progress))
./net/wireless/intersil/orinoco/orinoco_cs.c:229:	if (!test_bit(0, &card->hard_reset_in_progress))
./net/wireless/intersil/orinoco/spectrum_cs.c:134:	struct pcmcia_device *link = card->p_dev;
./net/wireless/intersil/orinoco/spectrum_cs.c:146:	struct pcmcia_device *link = card->p_dev;
./net/wireless/intersil/orinoco/spectrum_cs.c:169:	card->p_dev = link;
./net/wireless/intersil/orinoco/airport.c:56:	disable_irq(card->irq);
./net/wireless/intersil/orinoco/airport.c:78:	enable_irq(card->irq);
./net/wireless/intersil/orinoco/airport.c:93:	if (card->ndev_registered)
./net/wireless/intersil/orinoco/airport.c:95:	card->ndev_registered = 0;
./net/wireless/intersil/orinoco/airport.c:97:	if (card->irq_requested)
./net/wireless/intersil/orinoco/airport.c:98:		free_irq(card->irq, priv);
./net/wireless/intersil/orinoco/airport.c:99:	card->irq_requested = 0;
./net/wireless/intersil/orinoco/airport.c:101:	if (card->vaddr)
./net/wireless/intersil/orinoco/airport.c:102:		iounmap(card->vaddr);
./net/wireless/intersil/orinoco/airport.c:103:	card->vaddr = NULL;
./net/wireless/intersil/orinoco/airport.c:131:	disable_irq(card->irq);
./net/wireless/intersil/orinoco/airport.c:134:			  macio_get_of_node(card->mdev), 0, 0);
./net/wireless/intersil/orinoco/airport.c:137:			  macio_get_of_node(card->mdev), 0, 1);
./net/wireless/intersil/orinoco/airport.c:140:	enable_irq(card->irq);
./net/wireless/intersil/orinoco/airport.c:170:	card->mdev = mdev;
./net/wireless/intersil/orinoco/airport.c:181:	card->irq = macio_irq(mdev, 0);
./net/wireless/intersil/orinoco/airport.c:184:	card->vaddr = ioremap(phys_addr, AIRPORT_IO_LEN);
./net/wireless/intersil/orinoco/airport.c:185:	if (!card->vaddr) {
./net/wireless/intersil/orinoco/airport.c:190:	hermes_struct_init(hw, card->vaddr, HERMES_16BIT_REGSPACING);
./net/wireless/intersil/orinoco/airport.c:200:	if (request_irq(card->irq, orinoco_interrupt, 0, DRIVER_NAME, priv)) {
./net/wireless/intersil/orinoco/airport.c:201:		printk(KERN_ERR PFX "Couldn't get IRQ %d\n", card->irq);
./net/wireless/intersil/orinoco/airport.c:204:	card->irq_requested = 1;
./net/wireless/intersil/orinoco/airport.c:213:	if (orinoco_if_add(priv, phys_addr, card->irq, NULL) != 0) {
./net/wireless/intersil/orinoco/airport.c:217:	card->ndev_registered = 1;
./net/wireless/intersil/orinoco/orinoco_plx.c:117:	iowrite8(COR_VALUE | COR_RESET, card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_plx.c:120:	iowrite8(COR_VALUE, card->attr_io + COR_OFFSET);
./net/wireless/intersil/orinoco/orinoco_plx.c:150:		printk("%02X:", ioread8(card->attr_io + (i << 1)));
./net/wireless/intersil/orinoco/orinoco_plx.c:156:		if (cis_magic[i] != ioread8(card->attr_io + (i << 1))) {
./net/wireless/intersil/orinoco/orinoco_plx.c:166:	csr_reg = ioread32(card->bridge_io + PLX_INTCSR);
./net/wireless/intersil/orinoco/orinoco_plx.c:169:		iowrite32(csr_reg, card->bridge_io + PLX_INTCSR);
./net/wireless/intersil/orinoco/orinoco_plx.c:170:		csr_reg = ioread32(card->bridge_io + PLX_INTCSR);
./net/wireless/intersil/orinoco/orinoco_plx.c:231:	card->bridge_io = bridge_io;
./net/wireless/intersil/orinoco/orinoco_plx.c:232:	card->attr_io = attr_io;
./net/wireless/intersil/orinoco/orinoco_plx.c:308:	pci_iounmap(pdev, card->attr_io);
./net/wireless/intersil/orinoco/orinoco_plx.c:309:	pci_iounmap(pdev, card->bridge_io);
./net/wireless/ti/wlcore/sdio.c:157:	ret = pm_runtime_get_sync(&card->dev);
./net/wireless/ti/wlcore/sdio.c:164:		ret = mmc_power_restore_host(card->host);
./net/wireless/ti/wlcore/sdio.c:166:			pm_runtime_put_sync(&card->dev);
./net/wireless/ti/wlcore/sdio.c:190:	ret = mmc_power_save_host(card->host);
./net/wireless/ti/wlcore/sdio.c:195:	pm_runtime_put_sync(&card->dev);
./net/wireless/ti/wlcore/sdio.c:313:	func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
./net/wireless/ti/wlcore/sdio.c:316:	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
./net/wireless/ti/wlcore/sdio.c:340:	if (func->card->cccr.sdio_vsn == SDIO_SDIO_REV_3_00)
./net/can/softing/softing_main.c:43:	if (card->pdat->generation >= 2) {
./net/can/softing/softing_main.c:44:		spin_lock_bh(&card->spin);
./net/can/softing/softing_main.c:45:		iowrite8(ioread8(&card->dpram[DPRAM_V2_RESET]) & ~1,
./net/can/softing/softing_main.c:46:				&card->dpram[DPRAM_V2_RESET]);
./net/can/softing/softing_main.c:47:		spin_unlock_bh(&card->spin);
./net/can/softing/softing_main.c:53:	if (card->pdat->generation >= 2) {
./net/can/softing/softing_main.c:54:		spin_lock_bh(&card->spin);
./net/can/softing/softing_main.c:55:		iowrite8(ioread8(&card->dpram[DPRAM_V2_RESET]) | 1,
./net/can/softing/softing_main.c:56:				&card->dpram[DPRAM_V2_RESET]);
./net/can/softing/softing_main.c:57:		spin_unlock_bh(&card->spin);
./net/can/softing/softing_main.c:76:	spin_lock(&card->spin);
./net/can/softing/softing_main.c:79:	if (!card->fw.up ||
./net/can/softing/softing_main.c:80:			(card->tx.pending >= TXMAX) ||
./net/can/softing/softing_main.c:83:	fifo_wr = ioread8(&card->dpram[DPRAM_TX_WR]);
./net/can/softing/softing_main.c:84:	fifo_rd = ioread8(&card->dpram[DPRAM_TX_RD]);
./net/can/softing/softing_main.c:110:	memcpy_toio(&card->dpram[DPRAM_TX + DPRAM_TX_SIZE * fifo_wr],
./net/can/softing/softing_main.c:114:	iowrite8(fifo_wr, &card->dpram[DPRAM_TX_WR]);
./net/can/softing/softing_main.c:115:	card->tx.last_bus = priv->index;
./net/can/softing/softing_main.c:116:	++card->tx.pending;
./net/can/softing/softing_main.c:125:	spin_unlock(&card->spin);
./net/can/softing/softing_main.c:126:	if (card->tx.pending >= TXMAX) {
./net/can/softing/softing_main.c:128:		for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_main.c:129:			if (card->net[j])
./net/can/softing/softing_main.c:130:				netif_stop_queue(card->net[j]);
./net/can/softing/softing_main.c:174:	lost_msg = ioread8(&card->dpram[DPRAM_RX_LOST]);
./net/can/softing/softing_main.c:178:		iowrite8(0, &card->dpram[DPRAM_RX_LOST]);
./net/can/softing/softing_main.c:187:		for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_main.c:188:			netdev = card->net[j];
./net/can/softing/softing_main.c:202:	fifo_rd = ioread8(&card->dpram[DPRAM_RX_RD]);
./net/can/softing/softing_main.c:203:	fifo_wr = ioread8(&card->dpram[DPRAM_RX_WR]);
./net/can/softing/softing_main.c:210:	memcpy_fromio(buf, &card->dpram[DPRAM_RX + DPRAM_RX_SIZE*fifo_rd],
./net/can/softing/softing_main.c:214:	iowrite8(fifo_rd, &card->dpram[DPRAM_RX_RD]);
./net/can/softing/softing_main.c:221:	netdev = card->net[0];
./net/can/softing/softing_main.c:223:		netdev = card->net[1];
./net/can/softing/softing_main.c:249:		iowrite8(state, &card->dpram[priv->index ?
./net/can/softing/softing_main.c:304:			if (card->tx.pending)
./net/can/softing/softing_main.c:305:				--card->tx.pending;
./net/can/softing/softing_main.c:337:	spin_lock_bh(&card->spin);
./net/can/softing/softing_main.c:339:		++card->irq.svc_count;
./net/can/softing/softing_main.c:342:	spin_unlock_bh(&card->spin);
./net/can/softing/softing_main.c:344:	offset = card->tx.last_bus;
./net/can/softing/softing_main.c:345:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_main.c:346:		if (card->tx.pending >= TXMAX)
./net/can/softing/softing_main.c:348:		netdev = card->net[(j + offset + 1) % card->pdat->nbus];
./net/can/softing/softing_main.c:372:	ir = ioread8(&card->dpram[DPRAM_V2_IRQ_TOHOST]);
./net/can/softing/softing_main.c:373:	iowrite8(0, &card->dpram[DPRAM_V2_IRQ_TOHOST]);
./net/can/softing/softing_main.c:382:	ir = ioread8(&card->dpram[DPRAM_IRQ_TOHOST]);
./net/can/softing/softing_main.c:383:	iowrite8(0, &card->dpram[DPRAM_IRQ_TOHOST]);
./net/can/softing/softing_main.c:435:	if (!card->irq.nr) {
./net/can/softing/softing_main.c:437:	} else if (card->irq.requested && !enable) {
./net/can/softing/softing_main.c:438:		free_irq(card->irq.nr, card);
./net/can/softing/softing_main.c:439:		card->irq.requested = 0;
./net/can/softing/softing_main.c:440:	} else if (!card->irq.requested && enable) {
./net/can/softing/softing_main.c:441:		ret = request_threaded_irq(card->irq.nr,
./net/can/softing/softing_main.c:442:				(card->pdat->generation >= 2) ?
./net/can/softing/softing_main.c:445:				dev_name(&card->pdev->dev), card);
./net/can/softing/softing_main.c:447:			dev_alert(&card->pdev->dev,
./net/can/softing/softing_main.c:449:					card->irq.nr);
./net/can/softing/softing_main.c:452:		card->irq.requested = 1;
./net/can/softing/softing_main.c:461:	if (mutex_lock_interruptible(&card->fw.lock))
./net/can/softing/softing_main.c:463:	fw_up = card->fw.up;
./net/can/softing/softing_main.c:464:	card->fw.up = 0;
./net/can/softing/softing_main.c:466:	if (card->irq.requested && card->irq.nr) {
./net/can/softing/softing_main.c:467:		free_irq(card->irq.nr, card);
./net/can/softing/softing_main.c:468:		card->irq.requested = 0;
./net/can/softing/softing_main.c:471:		if (card->pdat->enable_irq)
./net/can/softing/softing_main.c:472:			card->pdat->enable_irq(card->pdev, 0);
./net/can/softing/softing_main.c:474:		if (card->pdat->reset)
./net/can/softing/softing_main.c:475:			card->pdat->reset(card->pdev, 1);
./net/can/softing/softing_main.c:477:	mutex_unlock(&card->fw.lock);
./net/can/softing/softing_main.c:487:	if (mutex_lock_interruptible(&card->fw.lock))
./net/can/softing/softing_main.c:489:	if (card->fw.up) {
./net/can/softing/softing_main.c:490:		mutex_unlock(&card->fw.lock);
./net/can/softing/softing_main.c:494:	if (card->pdat->enable_irq)
./net/can/softing/softing_main.c:495:		card->pdat->enable_irq(card->pdev, 1);
./net/can/softing/softing_main.c:498:	if (card->pdat->reset)
./net/can/softing/softing_main.c:499:		card->pdat->reset(card->pdev, 1);
./net/can/softing/softing_main.c:500:	for (j = 0; (j + sizeof(stream)) < card->dpram_size;
./net/can/softing/softing_main.c:503:		memcpy_toio(&card->dpram[j], stream, sizeof(stream));
./net/can/softing/softing_main.c:506:		memcpy_fromio(back, &card->dpram[j], sizeof(stream));
./net/can/softing/softing_main.c:511:		dev_alert(&card->pdev->dev, "dpram failed at 0x%04x\n", j);
./net/can/softing/softing_main.c:517:	ret = softing_load_fw(card->pdat->boot.fw, card, card->dpram,
./net/can/softing/softing_main.c:518:				card->dpram_size,
./net/can/softing/softing_main.c:519:				card->pdat->boot.offs - card->pdat->boot.addr);
./net/can/softing/softing_main.c:523:	ret = softing_load_fw(card->pdat->load.fw, card, card->dpram,
./net/can/softing/softing_main.c:524:				card->dpram_size,
./net/can/softing/softing_main.c:525:				card->pdat->load.offs - card->pdat->load.addr);
./net/can/softing/softing_main.c:529:	if (card->pdat->reset)
./net/can/softing/softing_main.c:530:		card->pdat->reset(card->pdev, 0);
./net/can/softing/softing_main.c:535:	ret = softing_load_app_fw(card->pdat->app.fw, card);
./net/can/softing/softing_main.c:543:	card->fw.up = 1;
./net/can/softing/softing_main.c:544:	mutex_unlock(&card->fw.lock);
./net/can/softing/softing_main.c:547:	card->fw.up = 0;
./net/can/softing/softing_main.c:548:	if (card->pdat->enable_irq)
./net/can/softing/softing_main.c:549:		card->pdat->enable_irq(card->pdev, 0);
./net/can/softing/softing_main.c:551:	if (card->pdat->reset)
./net/can/softing/softing_main.c:552:		card->pdat->reset(card->pdev, 1);
./net/can/softing/softing_main.c:553:	mutex_unlock(&card->fw.lock);
./net/can/softing/softing_main.c:592:	ret = mutex_lock_interruptible(&card->fw.lock);
./net/can/softing/softing_main.c:596:		mutex_unlock(&card->fw.lock);
./net/can/softing/softing_main.c:600:	mutex_unlock(&card->fw.lock);
./net/can/softing/softing_main.c:645:		dev_alert(&card->pdev->dev, "alloc_candev failed\n");
./net/can/softing/softing_main.c:652:	priv->btr_const.brp_max = card->pdat->max_brp;
./net/can/softing/softing_main.c:653:	priv->btr_const.sjw_max = card->pdat->max_sjw;
./net/can/softing/softing_main.c:658:	SET_NETDEV_DEV(netdev, &card->pdev->dev);
./net/can/softing/softing_main.c:698:	return sprintf(buf, "%u\n", card->member); \
./net/can/softing/softing_main.c:707:	return sprintf(buf, "%s\n", card->member); \
./net/can/softing/softing_main.c:744:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_main.c:745:		if (!card->net[j])
./net/can/softing/softing_main.c:747:		softing_netdev_cleanup(card->net[j]);
./net/can/softing/softing_main.c:748:		card->net[j] = NULL;
./net/can/softing/softing_main.c:752:	iounmap(card->dpram);
./net/can/softing/softing_main.c:771:	if (pdat->nbus > ARRAY_SIZE(card->net)) {
./net/can/softing/softing_main.c:779:	card->pdat = pdat;
./net/can/softing/softing_main.c:780:	card->pdev = pdev;
./net/can/softing/softing_main.c:782:	mutex_init(&card->fw.lock);
./net/can/softing/softing_main.c:783:	spin_lock_init(&card->spin);
./net/can/softing/softing_main.c:789:	card->dpram_phys = pres->start;
./net/can/softing/softing_main.c:790:	card->dpram_size = resource_size(pres);
./net/can/softing/softing_main.c:791:	card->dpram = ioremap_nocache(card->dpram_phys, card->dpram_size);
./net/can/softing/softing_main.c:792:	if (!card->dpram) {
./net/can/softing/softing_main.c:793:		dev_alert(&card->pdev->dev, "dpram ioremap failed\n");
./net/can/softing/softing_main.c:799:		card->irq.nr = pres->start;
./net/can/softing/softing_main.c:809:	card->id.freq = card->pdat->freq;
./net/can/softing/softing_main.c:813:		dev_alert(&card->pdev->dev, "sysfs failed\n");
./net/can/softing/softing_main.c:817:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_main.c:818:		card->net[j] = netdev =
./net/can/softing/softing_main.c:819:			softing_netdev_create(card, card->id.chip[j]);
./net/can/softing/softing_main.c:826:		priv = netdev_priv(card->net[j]);
./net/can/softing/softing_main.c:831:			card->net[j] = NULL;
./net/can/softing/softing_main.c:832:			dev_alert(&card->pdev->dev,
./net/can/softing/softing_main.c:837:	dev_info(&card->pdev->dev, "%s ready.\n", card->pdat->name);
./net/can/softing/softing_main.c:841:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_main.c:842:		if (!card->net[j])
./net/can/softing/softing_main.c:844:		softing_netdev_cleanup(card->net[j]);
./net/can/softing/softing_main.c:850:	iounmap(card->dpram);
./net/can/softing/softing_cs.c:52:	.name = "CANcard-NEC",
./net/can/softing/softing_cs.c:64:	.name = "CANcard-SJA",
./net/can/softing/softing_cs.c:76:	.name = "CANcard-2",
./net/can/softing/softing_cs.c:100:	.name = "Vector-CANcard-SJA",
./net/can/softing/softing_cs.c:112:	.name = "Vector-CANcard-2",
./net/can/softing/softing_cs.c:124:	.name = "EDICcard-NEC",
./net/can/softing/softing_cs.c:136:	.name = "EDICcard-2",
./net/can/softing/softing_fw.c:28: * Make sure that card->dpram[DPRAM_FCT_HOST] is preset
./net/can/softing/softing_fw.c:36:	iowrite16(cmd, &card->dpram[DPRAM_FCT_PARAM]);
./net/can/softing/softing_fw.c:37:	iowrite8(vector >> 8, &card->dpram[DPRAM_FCT_HOST + 1]);
./net/can/softing/softing_fw.c:38:	iowrite8(vector, &card->dpram[DPRAM_FCT_HOST]);
./net/can/softing/softing_fw.c:45:		ret = ioread8(&card->dpram[DPRAM_FCT_HOST]) +
./net/can/softing/softing_fw.c:46:			(ioread8(&card->dpram[DPRAM_FCT_HOST + 1]) << 8);
./net/can/softing/softing_fw.c:51:			return ioread16(&card->dpram[DPRAM_FCT_RESULT]);
./net/can/softing/softing_fw.c:60:	dev_alert(&card->pdev->dev, "firmware %s failed (%i)\n", msg, ret);
./net/can/softing/softing_fw.c:70:		dev_alert(&card->pdev->dev, "%s returned %u\n", msg, ret);
./net/can/softing/softing_fw.c:82:	iowrite16(RES_NONE, &card->dpram[DPRAM_RECEIPT]);
./net/can/softing/softing_fw.c:83:	iowrite16(cmd, &card->dpram[DPRAM_COMMAND]);
./net/can/softing/softing_fw.c:89:		ret = ioread16(&card->dpram[DPRAM_RECEIPT]);
./net/can/softing/softing_fw.c:101:	dev_alert(&card->pdev->dev, "bootloader %s failed (%i)\n", msg, ret);
./net/can/softing/softing_fw.c:156:	ret = request_firmware(&fw, file, &card->pdev->dev);
./net/can/softing/softing_fw.c:159:	dev_dbg(&card->pdev->dev, "%s, firmware(%s) got %u bytes"
./net/can/softing/softing_fw.c:161:		card->pdat->name, file, (unsigned int)fw->size,
./net/can/softing/softing_fw.c:212:			dev_alert(&card->pdev->dev, "DPRAM readback failed\n");
./net/can/softing/softing_fw.c:225:		dev_info(&card->pdev->dev, "firmware %s failed\n", file);
./net/can/softing/softing_fw.c:239:	ret = request_firmware(&fw, file, &card->pdev->dev);
./net/can/softing/softing_fw.c:241:		dev_alert(&card->pdev->dev, "request_firmware(%s) got %i\n",
./net/can/softing/softing_fw.c:245:	dev_dbg(&card->pdev->dev, "firmware(%s) got %lu bytes\n",
./net/can/softing/softing_fw.c:256:		dev_alert(&card->pdev->dev, "firmware starts with type 0x%x\n",
./net/can/softing/softing_fw.c:261:		dev_alert(&card->pdev->dev, "firmware string '%.*s' fault\n",
./net/can/softing/softing_fw.c:281:			dev_alert(&card->pdev->dev,
./net/can/softing/softing_fw.c:293:		memcpy_toio(&card->dpram[card->pdat->app.offs], dat, len);
./net/can/softing/softing_fw.c:294:		iowrite32(card->pdat->app.offs + card->pdat->app.addr,
./net/can/softing/softing_fw.c:295:				&card->dpram[DPRAM_COMMAND + 2]);
./net/can/softing/softing_fw.c:296:		iowrite32(addr, &card->dpram[DPRAM_COMMAND + 6]);
./net/can/softing/softing_fw.c:297:		iowrite16(len, &card->dpram[DPRAM_COMMAND + 10]);
./net/can/softing/softing_fw.c:298:		iowrite8(1, &card->dpram[DPRAM_COMMAND + 12]);
./net/can/softing/softing_fw.c:303:		rx_sum = ioread16(&card->dpram[DPRAM_RECEIPT + 2]);
./net/can/softing/softing_fw.c:305:			dev_alert(&card->pdev->dev, "SRAM seems to be damaged"
./net/can/softing/softing_fw.c:314:	iowrite32(start_addr, &card->dpram[DPRAM_COMMAND + 2]);
./net/can/softing/softing_fw.c:315:	iowrite8(1, &card->dpram[DPRAM_COMMAND + 6]);
./net/can/softing/softing_fw.c:323:		dev_info(&card->pdev->dev, "firmware %s failed\n", file);
./net/can/softing/softing_fw.c:333:		iowrite8(0, &card->dpram[DPRAM_RESET_RX_FIFO]);
./net/can/softing/softing_fw.c:334:		iowrite8(0, &card->dpram[DPRAM_RESET_RX_FIFO+1]);
./net/can/softing/softing_fw.c:335:		iowrite8(1, &card->dpram[DPRAM_RESET]);
./net/can/softing/softing_fw.c:336:		iowrite8(0, &card->dpram[DPRAM_RESET+1]);
./net/can/softing/softing_fw.c:345:	card->tx.pending = 0;
./net/can/softing/softing_fw.c:368:	card->id.serial = ioread32(&card->dpram[DPRAM_FCT_PARAM]);
./net/can/softing/softing_fw.c:373:	card->id.fw_version = ioread16(&card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:374:	card->id.hw_version = ioread16(&card->dpram[DPRAM_FCT_PARAM + 4]);
./net/can/softing/softing_fw.c:375:	card->id.license = ioread16(&card->dpram[DPRAM_FCT_PARAM + 6]);
./net/can/softing/softing_fw.c:376:	card->id.chip[0] = ioread16(&card->dpram[DPRAM_FCT_PARAM + 8]);
./net/can/softing/softing_fw.c:377:	card->id.chip[1] = ioread16(&card->dpram[DPRAM_FCT_PARAM + 10]);
./net/can/softing/softing_fw.c:387:	card->ts_ref = ktime_get();
./net/can/softing/softing_fw.c:391:	do_div(ovf, card->pdat->freq ?: 16);
./net/can/softing/softing_fw.c:393:	card->ts_overflow = ktime_add_us(0, ovf);
./net/can/softing/softing_fw.c:408:	do_div(rawl, card->pdat->freq ?: 16);
./net/can/softing/softing_fw.c:409:	target = ktime_add_us(card->ts_ref, rawl);
./net/can/softing/softing_fw.c:411:	tmp = ktime_add(target, card->ts_overflow);
./net/can/softing/softing_fw.c:413:		card->ts_ref = ktime_add(card->ts_ref, card->ts_overflow);
./net/can/softing/softing_fw.c:415:		tmp = ktime_add(target, card->ts_overflow);
./net/can/softing/softing_fw.c:442:	if (!card->fw.up)
./net/can/softing/softing_fw.c:445:	ret = mutex_lock_interruptible(&card->fw.lock);
./net/can/softing/softing_fw.c:454:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_fw.c:455:		netdev = card->net[j];
./net/can/softing/softing_fw.c:481:	card->tx.pending = 0;
./net/can/softing/softing_fw.c:492:			&& (softing_error_reporting(card->net[0])
./net/can/softing/softing_fw.c:493:				!= softing_error_reporting(card->net[1]))) {
./net/can/softing/softing_fw.c:494:		dev_alert(&card->pdev->dev,
./net/can/softing/softing_fw.c:500:		netdev = card->net[0];
./net/can/softing/softing_fw.c:505:		iowrite16(bt->brp, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:506:		iowrite16(bt->sjw, &card->dpram[DPRAM_FCT_PARAM + 4]);
./net/can/softing/softing_fw.c:508:				&card->dpram[DPRAM_FCT_PARAM + 6]);
./net/can/softing/softing_fw.c:509:		iowrite16(bt->phase_seg2, &card->dpram[DPRAM_FCT_PARAM + 8]);
./net/can/softing/softing_fw.c:511:				&card->dpram[DPRAM_FCT_PARAM + 10]);
./net/can/softing/softing_fw.c:516:		iowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:517:		iowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 4]);
./net/can/softing/softing_fw.c:523:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:524:		iowrite16(0x07ff, &card->dpram[DPRAM_FCT_PARAM + 4]);
./net/can/softing/softing_fw.c:526:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 6]);
./net/can/softing/softing_fw.c:527:		iowrite16(0xffff, &card->dpram[DPRAM_FCT_PARAM + 8]);
./net/can/softing/softing_fw.c:528:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 10]);
./net/can/softing/softing_fw.c:529:		iowrite16(0x1fff, &card->dpram[DPRAM_FCT_PARAM + 12]);
./net/can/softing/softing_fw.c:534:		iowrite16(priv->output, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:540:		netdev = card->net[1];
./net/can/softing/softing_fw.c:545:		iowrite16(bt->brp, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:546:		iowrite16(bt->sjw, &card->dpram[DPRAM_FCT_PARAM + 4]);
./net/can/softing/softing_fw.c:548:				&card->dpram[DPRAM_FCT_PARAM + 6]);
./net/can/softing/softing_fw.c:549:		iowrite16(bt->phase_seg2, &card->dpram[DPRAM_FCT_PARAM + 8]);
./net/can/softing/softing_fw.c:551:				&card->dpram[DPRAM_FCT_PARAM + 10]);
./net/can/softing/softing_fw.c:556:		iowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:557:		iowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 4]);
./net/can/softing/softing_fw.c:563:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:564:		iowrite16(0x07ff, &card->dpram[DPRAM_FCT_PARAM + 4]);
./net/can/softing/softing_fw.c:566:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 6]);
./net/can/softing/softing_fw.c:567:		iowrite16(0xffff, &card->dpram[DPRAM_FCT_PARAM + 8]);
./net/can/softing/softing_fw.c:568:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 10]);
./net/can/softing/softing_fw.c:569:		iowrite16(0x1fff, &card->dpram[DPRAM_FCT_PARAM + 12]);
./net/can/softing/softing_fw.c:574:		iowrite16(priv->output, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:592:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 2]);
./net/can/softing/softing_fw.c:593:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 4]);
./net/can/softing/softing_fw.c:594:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 6]);
./net/can/softing/softing_fw.c:595:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 8]);
./net/can/softing/softing_fw.c:596:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 10]);
./net/can/softing/softing_fw.c:597:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 12]);
./net/can/softing/softing_fw.c:598:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 14]);
./net/can/softing/softing_fw.c:599:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 16]);
./net/can/softing/softing_fw.c:600:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 18]);
./net/can/softing/softing_fw.c:601:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 20]);
./net/can/softing/softing_fw.c:621:	iowrite8(0, &card->dpram[DPRAM_INFO_BUSSTATE]);
./net/can/softing/softing_fw.c:622:	iowrite8(0, &card->dpram[DPRAM_INFO_BUSSTATE2]);
./net/can/softing/softing_fw.c:623:	if (card->pdat->generation < 2) {
./net/can/softing/softing_fw.c:624:		iowrite8(0, &card->dpram[DPRAM_V2_IRQ_TOHOST]);
./net/can/softing/softing_fw.c:639:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_fw.c:642:		netdev = card->net[j];
./net/can/softing/softing_fw.c:661:	mutex_unlock(&card->fw.lock);
./net/can/softing/softing_fw.c:668:	mutex_unlock(&card->fw.lock);
./net/can/softing/softing_fw.c:670:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./net/can/softing/softing_fw.c:671:		netdev = card->net[j];
./net/can/softing/softing_fw.c:686:		return (card->pdat->generation < 2) ? 0xfb : 0xfa;
./net/can/sja1000/ems_pci.c:120:	return readb(card->base_addr + (port * 4));
./net/can/sja1000/ems_pci.c:140:	       card->conf_addr + PITA2_ICR);
./net/can/sja1000/ems_pci.c:158:	writel(PLX_ICSR_ENA_CLR, card->conf_addr + PLX_ICSR);
./net/can/sja1000/ems_pci.c:189:	for (i = 0; i < card->channels; i++) {
./net/can/sja1000/ems_pci.c:190:		dev = card->net_dev[i];
./net/can/sja1000/ems_pci.c:200:	if (card->base_addr != NULL)
./net/can/sja1000/ems_pci.c:201:		pci_iounmap(card->pci_dev, card->base_addr);
./net/can/sja1000/ems_pci.c:203:	if (card->conf_addr != NULL)
./net/can/sja1000/ems_pci.c:204:		pci_iounmap(card->pci_dev, card->conf_addr);
./net/can/sja1000/ems_pci.c:214:	writeb(0, card->base_addr);
./net/can/sja1000/ems_pci.c:245:	card->pci_dev = pdev;
./net/can/sja1000/ems_pci.c:247:	card->channels = 0;
./net/can/sja1000/ems_pci.c:250:		card->version = 2; /* CPC-PCI v2 */
./net/can/sja1000/ems_pci.c:255:		card->version = 1; /* CPC-PCI v1 */
./net/can/sja1000/ems_pci.c:262:	card->conf_addr = pci_iomap(pdev, 0, conf_size);
./net/can/sja1000/ems_pci.c:263:	if (card->conf_addr == NULL) {
./net/can/sja1000/ems_pci.c:268:	card->base_addr = pci_iomap(pdev, base_bar, EMS_PCI_BASE_SIZE);
./net/can/sja1000/ems_pci.c:269:	if (card->base_addr == NULL) {
./net/can/sja1000/ems_pci.c:274:	if (card->version == 1) {
./net/can/sja1000/ems_pci.c:276:		writel(PITA2_MISC_CONFIG, card->conf_addr + PITA2_MISC);
./net/can/sja1000/ems_pci.c:301:		card->net_dev[i] = dev;
./net/can/sja1000/ems_pci.c:307:		priv->reg_base = card->base_addr + EMS_PCI_CAN_BASE_OFFSET
./net/can/sja1000/ems_pci.c:309:		if (card->version == 1) {
./net/can/sja1000/ems_pci.c:328:			if (card->version == 1)
./net/can/sja1000/ems_pci.c:331:				       card->conf_addr + PITA2_ICR);
./net/can/sja1000/ems_pci.c:335:				       card->conf_addr + PLX_ICSR);
./net/can/sja1000/ems_pci.c:346:			card->channels++;
./net/can/sja1000/ems_pcmcia.c:98:	if (readw(card->base_addr) != 0xAA55)
./net/can/sja1000/ems_pcmcia.c:105:		for (i = 0; i < card->channels; i++) {
./net/can/sja1000/ems_pcmcia.c:106:			dev = card->net_dev[i];
./net/can/sja1000/ems_pcmcia.c:147:	for (i = 0; i < card->channels; i++) {
./net/can/sja1000/ems_pcmcia.c:148:		dev = card->net_dev[i];
./net/can/sja1000/ems_pcmcia.c:158:	writeb(EMS_CMD_UMAP, card->base_addr);
./net/can/sja1000/ems_pcmcia.c:159:	iounmap(card->base_addr);
./net/can/sja1000/ems_pcmcia.c:182:	card->channels = 0;
./net/can/sja1000/ems_pcmcia.c:184:	card->base_addr = ioremap(base, EMS_PCMCIA_MEM_SIZE);
./net/can/sja1000/ems_pcmcia.c:185:	if (!card->base_addr) {
./net/can/sja1000/ems_pcmcia.c:191:	if (readw(card->base_addr) != 0xAA55) {
./net/can/sja1000/ems_pcmcia.c:197:	writeb(EMS_CMD_RESET, card->base_addr);
./net/can/sja1000/ems_pcmcia.c:200:	writeb(EMS_CMD_MAP, card->base_addr);
./net/can/sja1000/ems_pcmcia.c:210:		card->net_dev[i] = dev;
./net/can/sja1000/ems_pcmcia.c:218:		priv->reg_base = card->base_addr + EMS_PCMCIA_CAN_BASE_OFFSET +
./net/can/sja1000/ems_pcmcia.c:237:			card->channels++;
./net/can/sja1000/peak_pci.c:168:	u8 gp_outen = readb(card->cfg_base + PITA_GPOEN) & ~PITA_GPIN_SCL;
./net/can/sja1000/peak_pci.c:169:	writeb(gp_outen, card->cfg_base + PITA_GPOEN);
./net/can/sja1000/peak_pci.c:174:	u8 gp_outen = readb(card->cfg_base + PITA_GPOEN) & ~PITA_GPIN_SDA;
./net/can/sja1000/peak_pci.c:175:	writeb(gp_outen, card->cfg_base + PITA_GPOEN);
./net/can/sja1000/peak_pci.c:191:	gp_out = readb(card->cfg_base + PITA_GPOUT) & ~PITA_GPIN_SDA;
./net/can/sja1000/peak_pci.c:192:	writeb(gp_out, card->cfg_base + PITA_GPOUT);
./net/can/sja1000/peak_pci.c:195:	gp_outen = readb(card->cfg_base + PITA_GPOEN);
./net/can/sja1000/peak_pci.c:201:	writeb(gp_outen, card->cfg_base + PITA_GPOEN);
./net/can/sja1000/peak_pci.c:210:	gp_out = readb(card->cfg_base + PITA_GPOUT) & ~PITA_GPIN_SCL;
./net/can/sja1000/peak_pci.c:211:	writeb(gp_out, card->cfg_base + PITA_GPOUT);
./net/can/sja1000/peak_pci.c:214:	gp_outen = readb(card->cfg_base + PITA_GPOEN);
./net/can/sja1000/peak_pci.c:220:	writeb(gp_outen, card->cfg_base + PITA_GPOEN);
./net/can/sja1000/peak_pci.c:230:	return (readb(card->cfg_base + PITA_GPIN) & PITA_GPIN_SDA) ? 1 : 0;
./net/can/sja1000/peak_pci.c:240:	return (readb(card->cfg_base + PITA_GPIN) & PITA_GPIN_SCL) ? 1 : 0;
./net/can/sja1000/peak_pci.c:261:	if ((offset == 5) && (data == card->led_cache))
./net/can/sja1000/peak_pci.c:264:	ret = i2c_transfer(&card->led_chip, &msg, 1);
./net/can/sja1000/peak_pci.c:269:		card->led_cache = data;
./net/can/sja1000/peak_pci.c:282:	u8 new_led = card->led_cache;
./net/can/sja1000/peak_pci.c:286:	for (i = 0; i < card->chan_count; i++) {
./net/can/sja1000/peak_pci.c:291:		netdev = card->channel[i].netdev;
./net/can/sja1000/peak_pci.c:302:		if (netdev->stats.rx_bytes != card->channel[i].prev_rx_bytes) {
./net/can/sja1000/peak_pci.c:303:			card->channel[i].prev_rx_bytes = netdev->stats.rx_bytes;
./net/can/sja1000/peak_pci.c:307:		if (netdev->stats.tx_bytes != card->channel[i].prev_tx_bytes) {
./net/can/sja1000/peak_pci.c:308:			card->channel[i].prev_tx_bytes = netdev->stats.tx_bytes;
./net/can/sja1000/peak_pci.c:319:		schedule_delayed_work(&card->led_work, HZ);
./net/can/sja1000/peak_pci.c:327:	u8 new_led = card->led_cache;
./net/can/sja1000/peak_pci.c:331:	for (i = 0; i < card->chan_count; i++)
./net/can/sja1000/peak_pci.c:346:	schedule_delayed_work(&card->led_work, HZ);
./net/can/sja1000/peak_pci.c:354:	cancel_delayed_work_sync(&card->led_work);
./net/can/sja1000/peak_pci.c:406:	int c = (priv->reg_base - card->reg_base) / PEAK_PCI_CHAN_SIZE;
./net/can/sja1000/peak_pci.c:460:		card->cfg_base = chan->cfg_base;
./net/can/sja1000/peak_pci.c:461:		card->reg_base = priv->reg_base;
./net/can/sja1000/peak_pci.c:463:		card->led_chip.owner = THIS_MODULE;
./net/can/sja1000/peak_pci.c:464:		card->led_chip.dev.parent = &pdev->dev;
./net/can/sja1000/peak_pci.c:465:		card->led_chip.algo_data = &card->i2c_bit;
./net/can/sja1000/peak_pci.c:466:		strncpy(card->led_chip.name, "peak_i2c",
./net/can/sja1000/peak_pci.c:467:			sizeof(card->led_chip.name));
./net/can/sja1000/peak_pci.c:469:		card->i2c_bit = peak_pciec_i2c_bit_ops;
./net/can/sja1000/peak_pci.c:470:		card->i2c_bit.udelay = 10;
./net/can/sja1000/peak_pci.c:471:		card->i2c_bit.timeout = HZ;
./net/can/sja1000/peak_pci.c:472:		card->i2c_bit.data = card;
./net/can/sja1000/peak_pci.c:476:		err = i2c_bit_add_bus(&card->led_chip);
./net/can/sja1000/peak_pci.c:488:		INIT_DELAYED_WORK(&card->led_work, peak_pciec_led_work);
./net/can/sja1000/peak_pci.c:494:	card->channel[card->chan_count++].netdev = dev;
./net/can/sja1000/peak_pci.c:499:	i2c_del_adapter(&card->led_chip);
./net/can/sja1000/peak_pci.c:512:	i2c_del_adapter(&card->led_chip);
./net/can/sja1000/peak_pcmcia.c:170:	if (!timer_pending(&card->led_timer))
./net/can/sja1000/peak_pcmcia.c:171:		mod_timer(&card->led_timer, jiffies + HZ);
./net/can/sja1000/peak_pcmcia.c:179:	del_timer_sync(&card->led_timer);
./net/can/sja1000/peak_pcmcia.c:196:	int c = (priv->reg_base - card->ioport_addr) / PCC_CHAN_SIZE;
./net/can/sja1000/peak_pcmcia.c:222:	return ioread8(card->ioport_addr + PCC_COMN_OFF + port);
./net/can/sja1000/peak_pcmcia.c:232:		if (card->ccr == v)
./net/can/sja1000/peak_pcmcia.c:234:		card->ccr = v;
./net/can/sja1000/peak_pcmcia.c:237:	iowrite8(v, card->ioport_addr + PCC_COMN_OFF + port);
./net/can/sja1000/peak_pcmcia.c:246:	return ((pcan_read_reg(card, PCC_FW_MAJOR) == card->fw_major) &&
./net/can/sja1000/peak_pcmcia.c:247:		(pcan_read_reg(card, PCC_FW_MINOR) == card->fw_minor));
./net/can/sja1000/peak_pcmcia.c:297:		dev_err(&card->pdev->dev,
./net/can/sja1000/peak_pcmcia.c:330:		dev_err(&card->pdev->dev,
./net/can/sja1000/peak_pcmcia.c:344:	dev_err(&card->pdev->dev,
./net/can/sja1000/peak_pcmcia.c:352:	u8 ccr = card->ccr;
./net/can/sja1000/peak_pcmcia.c:355:	for (i = 0; i < card->chan_count; i++)
./net/can/sja1000/peak_pcmcia.c:376:		dev_err(&card->pdev->dev,
./net/can/sja1000/peak_pcmcia.c:391:	ccr = card->ccr;
./net/can/sja1000/peak_pcmcia.c:392:	for (i = 0; i < card->chan_count; i++) {
./net/can/sja1000/peak_pcmcia.c:397:		netdev = card->channel[i].netdev;
./net/can/sja1000/peak_pcmcia.c:408:		if (netdev->stats.rx_bytes != card->channel[i].prev_rx_bytes) {
./net/can/sja1000/peak_pcmcia.c:409:			card->channel[i].prev_rx_bytes = netdev->stats.rx_bytes;
./net/can/sja1000/peak_pcmcia.c:413:		if (netdev->stats.tx_bytes != card->channel[i].prev_tx_bytes) {
./net/can/sja1000/peak_pcmcia.c:414:			card->channel[i].prev_tx_bytes = netdev->stats.tx_bytes;
./net/can/sja1000/peak_pcmcia.c:425:		mod_timer(&card->led_timer, jiffies + HZ);
./net/can/sja1000/peak_pcmcia.c:443:		for (i = 0; i < card->chan_count; i++) {
./net/can/sja1000/peak_pcmcia.c:459:			netdev = card->channel[i].netdev;
./net/can/sja1000/peak_pcmcia.c:480:	for (i = 0; i < card->chan_count; i++) {
./net/can/sja1000/peak_pcmcia.c:486:		netdev = card->channel[i].netdev;
./net/can/sja1000/peak_pcmcia.c:496:		dev_info(&card->pdev->dev, "%s removed\n", name);
./net/can/sja1000/peak_pcmcia.c:524:	struct pcmcia_device *pdev = card->pdev;
./net/can/sja1000/peak_pcmcia.c:529:	card->ccr = ~ccr;
./net/can/sja1000/peak_pcmcia.c:539:	for (i = 0; i < ARRAY_SIZE(card->channel); i++) {
./net/can/sja1000/peak_pcmcia.c:557:		priv->reg_base = card->ioport_addr + PCC_CHAN_OFF(i);
./net/can/sja1000/peak_pcmcia.c:585:		card->channel[i].netdev = netdev;
./net/can/sja1000/peak_pcmcia.c:586:		card->chan_count++;
./net/can/sja1000/peak_pcmcia.c:627:	ioport_unmap(card->ioport_addr);
./net/can/sja1000/peak_pcmcia.c:668:	card->pdev = pdev;
./net/can/sja1000/peak_pcmcia.c:672:	card->ioport_addr = ioport_map(pdev->resource[0]->start,
./net/can/sja1000/peak_pcmcia.c:674:	if (!card->ioport_addr) {
./net/can/sja1000/peak_pcmcia.c:679:	card->fw_major = pcan_read_reg(card, PCC_FW_MAJOR);
./net/can/sja1000/peak_pcmcia.c:680:	card->fw_minor = pcan_read_reg(card, PCC_FW_MINOR);
./net/can/sja1000/peak_pcmcia.c:685:		card->fw_major, card->fw_minor);
./net/can/sja1000/peak_pcmcia.c:689:	if (!card->chan_count) {
./net/can/sja1000/peak_pcmcia.c:695:	init_timer(&card->led_timer);
./net/can/sja1000/peak_pcmcia.c:696:	card->led_timer.function = pcan_led_timer;
./net/can/sja1000/peak_pcmcia.c:697:	card->led_timer.data = (unsigned long)card;
./net/can/sja1000/peak_pcmcia.c:716:	ioport_unmap(card->ioport_addr);
./net/can/sja1000/plx_pci.c:436:	cntrl = ioread32(card->conf_addr + PLX_CNTRL);
./net/can/sja1000/plx_pci.c:438:	iowrite32(cntrl, card->conf_addr + PLX_CNTRL);
./net/can/sja1000/plx_pci.c:441:	iowrite32(cntrl, card->conf_addr + PLX_CNTRL);
./net/can/sja1000/plx_pci.c:454:	cntrl = ioread32(card->conf_addr + PLX9056_CNTRL);
./net/can/sja1000/plx_pci.c:456:	iowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);
./net/can/sja1000/plx_pci.c:459:	iowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);
./net/can/sja1000/plx_pci.c:463:	iowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);
./net/can/sja1000/plx_pci.c:473:	iowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);
./net/can/sja1000/plx_pci.c:535:		dev = card->net_dev[i];
./net/can/sja1000/plx_pci.c:547:	card->reset_func(pdev);
./net/can/sja1000/plx_pci.c:555:		iowrite32(0x0, card->conf_addr + PLX_INTCSR);
./net/can/sja1000/plx_pci.c:557:		iowrite32(0x0, card->conf_addr + PLX9056_INTCSR);
./net/can/sja1000/plx_pci.c:559:	if (card->conf_addr)
./net/can/sja1000/plx_pci.c:560:		pci_iounmap(pdev, card->conf_addr);
./net/can/sja1000/plx_pci.c:601:	card->channels = 0;
./net/can/sja1000/plx_pci.c:611:	card->conf_addr = addr + ci->conf_map.offset;
./net/can/sja1000/plx_pci.c:614:	card->reset_func = ci->reset_func;
./net/can/sja1000/plx_pci.c:626:		card->net_dev[i] = dev;
./net/can/sja1000/plx_pci.c:665:			card->channels++;
./net/can/sja1000/plx_pci.c:674:			card->net_dev[i] = NULL;
./net/can/sja1000/plx_pci.c:678:	if (!card->channels) {
./net/can/sja1000/plx_pci.c:689:		val = ioread32(card->conf_addr + PLX_INTCSR);
./net/can/sja1000/plx_pci.c:694:		iowrite32(val, card->conf_addr + PLX_INTCSR);
./net/can/sja1000/plx_pci.c:697:			  card->conf_addr + PLX9056_INTCSR);
./net/wan/wanxl.h:35:#define RX_QUEUE_LENGTH 40	/* card->host queue length - per card */
./net/wan/farsync.c:684:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:686:		    (card->device, PCI_INTERRUPT_LINE, &interrupt_line_register)) {
./net/wan/farsync.c:694:		outw(0x440f, card->pci_conf + CNTRL_9054 + 2);
./net/wan/farsync.c:695:		outw(0x040f, card->pci_conf + CNTRL_9054 + 2);
./net/wan/farsync.c:700:		outw(0x240f, card->pci_conf + CNTRL_9054 + 2);
./net/wan/farsync.c:705:		outw(0x040f, card->pci_conf + CNTRL_9054 + 2);
./net/wan/farsync.c:708:		    (card->device, PCI_INTERRUPT_LINE, interrupt_line_register)) {
./net/wan/farsync.c:714:		regval = inl(card->pci_conf + CNTRL_9052);
./net/wan/farsync.c:716:		outl(regval | 0x40000000, card->pci_conf + CNTRL_9052);
./net/wan/farsync.c:717:		outl(regval & ~0x40000000, card->pci_conf + CNTRL_9052);
./net/wan/farsync.c:726:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:730:		(void) readb(card->mem);
./net/wan/farsync.c:736:		outw(0x040e, card->pci_conf + CNTRL_9054 + 2);
./net/wan/farsync.c:737:		outw(0x040f, card->pci_conf + CNTRL_9054 + 2);
./net/wan/farsync.c:739:		(void) readb(card->ctlmem);
./net/wan/farsync.c:748:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:749:		(void) readb(card->ctlmem);
./net/wan/farsync.c:753:		outw(0x0543, card->pci_conf + INTCSR_9052);
./net/wan/farsync.c:762:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:763:		outl(0x0f0c0900, card->pci_conf + INTCSR_9054);
./net/wan/farsync.c:765:		outw(0x0543, card->pci_conf + INTCSR_9052);
./net/wan/farsync.c:774:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:775:		outl(0x00000000, card->pci_conf + INTCSR_9054);
./net/wan/farsync.c:777:		outw(0x0000, card->pci_conf + INTCSR_9052);
./net/wan/farsync.c:810:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:811:	        pci_set_master(card->device);
./net/wan/farsync.c:812:		outl(0x00020441, card->pci_conf + DMAMODE0);
./net/wan/farsync.c:813:		outl(0x00020441, card->pci_conf + DMAMODE1);
./net/wan/farsync.c:814:		outl(0x0, card->pci_conf + DMATHR);
./net/wan/farsync.c:860:	skb_put_data(skb, card->rx_dma_handle_host, len);
./net/wan/farsync.c:892:	if (card->dmarx_in_progress) {
./net/wan/farsync.c:896:	outl(dma, card->pci_conf + DMAPADR0);	/* Copy to here */
./net/wan/farsync.c:897:	outl(mem, card->pci_conf + DMALADR0);	/* from here */
./net/wan/farsync.c:898:	outl(len, card->pci_conf + DMASIZ0);	/* for this length */
./net/wan/farsync.c:899:	outl(0x00000000c, card->pci_conf + DMADPR0);	/* In this direction */
./net/wan/farsync.c:904:	card->dmarx_in_progress = 1;
./net/wan/farsync.c:905:	outb(0x03, card->pci_conf + DMACSR0);	/* Start the transfer */
./net/wan/farsync.c:919:	if (card->dmatx_in_progress) {
./net/wan/farsync.c:923:	outl(dma, card->pci_conf + DMAPADR1);	/* Copy from here */
./net/wan/farsync.c:924:	outl(mem, card->pci_conf + DMALADR1);	/* to here */
./net/wan/farsync.c:925:	outl(len, card->pci_conf + DMASIZ1);	/* for this length */
./net/wan/farsync.c:926:	outl(0x000000004, card->pci_conf + DMADPR1);	/* In this direction */
./net/wan/farsync.c:931:	card->dmatx_in_progress = 1;
./net/wan/farsync.c:932:	outb(0x03, card->pci_conf + DMACSR1);	/* Start the transfer */
./net/wan/farsync.c:948:	spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:954:		spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:956:		spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:980:	spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:1019:	spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:1030:	spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:1047:	spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:1059:	spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:1146:		    card->card_no, port->index, rxp);
./net/wan/farsync.c:1151:		    card->card_no, port->index);
./net/wan/farsync.c:1156:		    card->card_no, port->index);
./net/wan/farsync.c:1161:		    len, card->card_no, port->index);
./net/wan/farsync.c:1226:	if (card->dmarx_in_progress) {
./net/wan/farsync.c:1240:		       card->card_no, port->index);
./net/wan/farsync.c:1280:	if ((len < FST_MIN_DMA_LEN) || (card->family == FST_FAMILY_TXP)) {
./net/wan/farsync.c:1282:			      card->mem + BUF_OFFSET(rxBuffer[pi][rxp][0]),
./net/wan/farsync.c:1303:		card->dma_skb_rx = skb;
./net/wan/farsync.c:1304:		card->dma_port_rx = port;
./net/wan/farsync.c:1305:		card->dma_len_rx = len;
./net/wan/farsync.c:1306:		card->dma_rxpos = rxp;
./net/wan/farsync.c:1307:		fst_rx_dma(card, card->rx_dma_handle_card,
./net/wan/farsync.c:1339:	for (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {
./net/wan/farsync.c:1346:		       !(card->dmatx_in_progress)) {
./net/wan/farsync.c:1352:			spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:1360:			spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:1365:				spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:1371:				spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:1379:				    (card->family == FST_FAMILY_TXP)) {
./net/wan/farsync.c:1381:					memcpy_toio(card->mem +
./net/wan/farsync.c:1395:					memcpy(card->tx_dma_handle_host,
./net/wan/farsync.c:1397:					card->dma_port_tx = port;
./net/wan/farsync.c:1398:					card->dma_len_tx = skb->len;
./net/wan/farsync.c:1399:					card->dma_txpos = port->txpos;
./net/wan/farsync.c:1401:						   card->tx_dma_handle_card,
./net/wan/farsync.c:1438:	for (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {
./net/wan/farsync.c:1443:			 & DMA_OWN) && !(card->dmarx_in_progress)) {
./net/wan/farsync.c:1449:				fst_q_work_item(&fst_work_intq, card->card_no);
./net/wan/farsync.c:1480:	dbg(DBG_INTR, "intr: %d %p\n", card->irq, card);
./net/wan/farsync.c:1481:	if (card->state != FST_RUNNING) {
./net/wan/farsync.c:1483:		       card->card_no, card->state);
./net/wan/farsync.c:1506:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:1510:		dma_intcsr = inl(card->pci_conf + INTCSR_9054);
./net/wan/farsync.c:1516:			outb(0x8, card->pci_conf + DMACSR0);
./net/wan/farsync.c:1517:			fst_rx_dma_complete(card, card->dma_port_rx,
./net/wan/farsync.c:1518:					    card->dma_len_rx, card->dma_skb_rx,
./net/wan/farsync.c:1519:					    card->dma_rxpos);
./net/wan/farsync.c:1520:			card->dmarx_in_progress = 0;
./net/wan/farsync.c:1528:			outb(0x8, card->pci_conf + DMACSR1);
./net/wan/farsync.c:1529:			fst_tx_dma_complete(card, card->dma_port_tx,
./net/wan/farsync.c:1530:					    card->dma_len_tx, card->dma_txpos);
./net/wan/farsync.c:1531:			card->dmatx_in_progress = 0;
./net/wan/farsync.c:1542:		    card->card_no, int_retry_count);
./net/wan/farsync.c:1551:	fst_q_work_item(&fst_work_intq, card->card_no);
./net/wan/farsync.c:1559:		port = &card->ports[event & 0x03];
./net/wan/farsync.c:1596:			    card->card_no, port->index);
./net/wan/farsync.c:1605:			card->state = FST_IFAILED;
./net/wan/farsync.c:1633:		card->state = FST_BADVERSION;
./net/wan/farsync.c:1638:		card->state = FST_BADVERSION;
./net/wan/farsync.c:1643:		card->state = FST_RUNNING;
./net/wan/farsync.c:1646:		card->state = FST_HALTED;
./net/wan/farsync.c:1650:		card->state = FST_HALTED;
./net/wan/farsync.c:1658:	if (FST_RDL(card, numberOfPorts) != card->nports) {
./net/wan/farsync.c:1660:			card->card_no,
./net/wan/farsync.c:1661:			FST_RDL(card, numberOfPorts), card->nports);
./net/wan/farsync.c:1765:	info->nports = card->nports;
./net/wan/farsync.c:1766:	info->type = card->type;
./net/wan/farsync.c:1767:	info->state = card->state;
./net/wan/farsync.c:1777:	info->valid = ((card->state == FST_RUNNING) ? FSTVAL_ALL : FSTVAL_CARD)
./net/wan/farsync.c:1799:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:1816:	if (card->type == FST_TYPE_TE1) {
./net/wan/farsync.c:2002:		card->state = FST_RESET;
./net/wan/farsync.c:2007:		card->state = FST_STARTING;
./net/wan/farsync.c:2038:		memcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);
./net/wan/farsync.c:2044:		if (card->state == FST_RESET) {
./net/wan/farsync.c:2045:			card->state = FST_DOWNLOAD;
./net/wan/farsync.c:2054:		if (card->state == FST_STARTING) {
./net/wan/farsync.c:2058:			if (card->state == FST_RUNNING) {
./net/wan/farsync.c:2059:				spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:2062:				spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:2084:		if (card->state != FST_RUNNING) {
./net/wan/farsync.c:2086:			       card->card_no, card->state);
./net/wan/farsync.c:2142:	if (port->card->state == FST_RUNNING) {
./net/wan/farsync.c:2174:	if (port->card->state == FST_RUNNING) {
./net/wan/farsync.c:2220:	tx_dma_done = inb(card->pci_conf + DMACSR1);
./net/wan/farsync.c:2221:	rx_dma_done = inb(card->pci_conf + DMACSR0);
./net/wan/farsync.c:2224:	    card->dmatx_in_progress, tx_dma_done, card->dmarx_in_progress,
./net/wan/farsync.c:2258:	    card->card_no, port->index);
./net/wan/farsync.c:2285:		    card->card_no, port->index);
./net/wan/farsync.c:2303:	spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:2311:	spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:2328:		    card->card_no, port->index);
./net/wan/farsync.c:2335:	spin_lock_irqsave(&card->card_lock, flags);
./net/wan/farsync.c:2340:	spin_unlock_irqrestore(&card->card_lock, flags);
./net/wan/farsync.c:2343:	fst_q_work_item(&fst_work_txq, card->card_no);
./net/wan/farsync.c:2376:	for (i = 0; i < card->nports; i++) {
./net/wan/farsync.c:2377:		err = register_hdlc_device(card->ports[i].dev);
./net/wan/farsync.c:2382:				unregister_hdlc_device(card->ports[i].dev);
./net/wan/farsync.c:2388:		port_to_dev(&card->ports[0])->name,
./net/wan/farsync.c:2389:		port_to_dev(&card->ports[card->nports - 1])->name,
./net/wan/farsync.c:2390:		type_strings[card->type], card->irq, card->nports);
./net/wan/farsync.c:2455:	card->pci_conf = pci_resource_start(pdev, 1);
./net/wan/farsync.c:2456:	card->phys_mem = pci_resource_start(pdev, 2);
./net/wan/farsync.c:2457:	card->phys_ctlmem = pci_resource_start(pdev, 3);
./net/wan/farsync.c:2458:	if ((card->mem = ioremap(card->phys_mem, FST_MEMSIZE)) == NULL) {
./net/wan/farsync.c:2463:	if ((card->ctlmem = ioremap(card->phys_ctlmem, 0x10)) == NULL) {
./net/wan/farsync.c:2468:	dbg(DBG_PCI, "kernel mem %p, ctlmem %p\n", card->mem, card->ctlmem);
./net/wan/farsync.c:2472:		pr_err("Unable to register interrupt %d\n", card->irq);
./net/wan/farsync.c:2478:	card->irq = pdev->irq;
./net/wan/farsync.c:2479:	card->type = ent->driver_data;
./net/wan/farsync.c:2480:	card->family = ((ent->driver_data == FST_TYPE_T2P) ||
./net/wan/farsync.c:2485:		card->nports = 1;
./net/wan/farsync.c:2487:		card->nports = ((ent->driver_data == FST_TYPE_T2P) ||
./net/wan/farsync.c:2490:	card->state = FST_UNINIT;
./net/wan/farsync.c:2491:        spin_lock_init ( &card->card_lock );
./net/wan/farsync.c:2493:        for ( i = 0 ; i < card->nports ; i++ ) {
./net/wan/farsync.c:2494:		struct net_device *dev = alloc_hdlcdev(&card->ports[i]);
./net/wan/farsync.c:2498:				free_netdev(card->ports[i].dev);
./net/wan/farsync.c:2503:		card->ports[i].dev    = dev;
./net/wan/farsync.c:2504:                card->ports[i].card   = card;
./net/wan/farsync.c:2505:                card->ports[i].index  = i;
./net/wan/farsync.c:2506:                card->ports[i].run    = 0;
./net/wan/farsync.c:2515:                dev->mem_start   = card->phys_mem
./net/wan/farsync.c:2517:                dev->mem_end     = card->phys_mem
./net/wan/farsync.c:2519:                dev->base_addr   = card->pci_conf;
./net/wan/farsync.c:2520:                dev->irq         = card->irq;
./net/wan/farsync.c:2529:	card->device = pdev;
./net/wan/farsync.c:2531:	dbg(DBG_PCI, "type %d nports %d irq %d\n", card->type,
./net/wan/farsync.c:2532:	    card->nports, card->irq);
./net/wan/farsync.c:2534:	    card->pci_conf, card->phys_mem, card->phys_ctlmem);
./net/wan/farsync.c:2538:	card->state = FST_RESET;
./net/wan/farsync.c:2553:	card->card_no = no_of_cards_added++;	/* Record instance and bump it */
./net/wan/farsync.c:2557:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:2561:		card->rx_dma_handle_host =
./net/wan/farsync.c:2562:		    pci_alloc_consistent(card->device, FST_MAX_MTU,
./net/wan/farsync.c:2563:					 &card->rx_dma_handle_card);
./net/wan/farsync.c:2564:		if (card->rx_dma_handle_host == NULL) {
./net/wan/farsync.c:2569:		card->tx_dma_handle_host =
./net/wan/farsync.c:2570:		    pci_alloc_consistent(card->device, FST_MAX_MTU,
./net/wan/farsync.c:2571:					 &card->tx_dma_handle_card);
./net/wan/farsync.c:2572:		if (card->tx_dma_handle_host == NULL) {
./net/wan/farsync.c:2581:	pci_free_consistent(card->device, FST_MAX_MTU,
./net/wan/farsync.c:2582:			    card->rx_dma_handle_host,
./net/wan/farsync.c:2583:			    card->rx_dma_handle_card);
./net/wan/farsync.c:2586:	for (i = 0 ; i < card->nports ; i++)
./net/wan/farsync.c:2587:		unregister_hdlc_device(card->ports[i].dev);
./net/wan/farsync.c:2589:	fst_card_array[card->card_no] = NULL;
./net/wan/farsync.c:2591:	for (i = 0 ; i < card->nports ; i++)
./net/wan/farsync.c:2592:		free_netdev(card->ports[i].dev);
./net/wan/farsync.c:2594:	free_irq(card->irq, card);
./net/wan/farsync.c:2596:	iounmap(card->ctlmem);
./net/wan/farsync.c:2598:	iounmap(card->mem);
./net/wan/farsync.c:2619:	for (i = 0; i < card->nports; i++) {
./net/wan/farsync.c:2620:		struct net_device *dev = port_to_dev(&card->ports[i]);
./net/wan/farsync.c:2625:	free_irq(card->irq, card);
./net/wan/farsync.c:2627:	iounmap(card->ctlmem);
./net/wan/farsync.c:2628:	iounmap(card->mem);
./net/wan/farsync.c:2630:	if (card->family == FST_FAMILY_TXU) {
./net/wan/farsync.c:2634:		pci_free_consistent(card->device, FST_MAX_MTU,
./net/wan/farsync.c:2635:				    card->rx_dma_handle_host,
./net/wan/farsync.c:2636:				    card->rx_dma_handle_card);
./net/wan/farsync.c:2637:		pci_free_consistent(card->device, FST_MAX_MTU,
./net/wan/farsync.c:2638:				    card->tx_dma_handle_host,
./net/wan/farsync.c:2639:				    card->tx_dma_handle_card);
./net/wan/farsync.c:2641:	fst_card_array[card->card_no] = NULL;
./net/wan/pc300too.c:123:	u32 __iomem * init_ctrl = &card->plxbase->init_ctrl;
./net/wan/pc300too.c:158:	if (port->card->type == PC300_RSV) {
./net/wan/pc300too.c:160:			writel(card->init_ctrl_value |
./net/wan/pc300too.c:163:			writel(card->init_ctrl_value &
./net/wan/pc300too.c:223:	if (port->card->type == PC300_X21 &&
./net/wan/pc300too.c:228:	else if (port->card->type == PC300_RSV &&
./net/wan/pc300too.c:233:	else if (port->card->type == PC300_RSV &&
./net/wan/pc300too.c:269:		if (card->ports[i].card)
./net/wan/pc300too.c:270:			unregister_hdlc_device(card->ports[i].netdev);
./net/wan/pc300too.c:272:	if (card->irq)
./net/wan/pc300too.c:273:		free_irq(card->irq, card);
./net/wan/pc300too.c:275:	if (card->rambase)
./net/wan/pc300too.c:276:		iounmap(card->rambase);
./net/wan/pc300too.c:277:	if (card->scabase)
./net/wan/pc300too.c:278:		iounmap(card->scabase);
./net/wan/pc300too.c:279:	if (card->plxbase)
./net/wan/pc300too.c:280:		iounmap(card->plxbase);
./net/wan/pc300too.c:284:	if (card->ports[0].netdev)
./net/wan/pc300too.c:285:		free_netdev(card->ports[0].netdev);
./net/wan/pc300too.c:286:	if (card->ports[1].netdev)
./net/wan/pc300too.c:287:		free_netdev(card->ports[1].netdev);
./net/wan/pc300too.c:336:	card->plxbase = ioremap(plxphys, PC300_PLX_SIZE);
./net/wan/pc300too.c:339:	card->scabase = ioremap(scaphys, PC300_SCA_SIZE);
./net/wan/pc300too.c:342:	card->rambase = pci_ioremap_bar(pdev, 3);
./net/wan/pc300too.c:344:	if (card->plxbase == NULL ||
./net/wan/pc300too.c:345:	    card->scabase == NULL ||
./net/wan/pc300too.c:346:	    card->rambase == NULL) {
./net/wan/pc300too.c:354:	card->init_ctrl_value = readl(&((plx9050 __iomem *)card->scabase)->init_ctrl);
./net/wan/pc300too.c:359:		card->type = PC300_TE; /* not fully supported */
./net/wan/pc300too.c:360:	else if (card->init_ctrl_value & PC300_CTYPE_MASK)
./net/wan/pc300too.c:361:		card->type = PC300_X21;
./net/wan/pc300too.c:363:		card->type = PC300_RSV;
./net/wan/pc300too.c:367:		card->n_ports = 1;
./net/wan/pc300too.c:369:		card->n_ports = 2;
./net/wan/pc300too.c:371:	for (i = 0; i < card->n_ports; i++)
./net/wan/pc300too.c:372:		if (!(card->ports[i].netdev = alloc_hdlcdev(&card->ports[i]))) {
./net/wan/pc300too.c:379:	p = &card->plxbase->init_ctrl;
./net/wan/pc300too.c:380:	writel(card->init_ctrl_value | 0x40000000, p);
./net/wan/pc300too.c:384:	writel(card->init_ctrl_value, p);
./net/wan/pc300too.c:389:	writel(card->init_ctrl_value | 0x20000000, p);
./net/wan/pc300too.c:393:	writel(card->init_ctrl_value, p);
./net/wan/pc300too.c:397:	ramsize = sca_detect_ram(card, card->rambase,
./net/wan/pc300too.c:401:		card->init_ctrl_value &= ~PC300_CLKSEL_MASK;
./net/wan/pc300too.c:403:		card->init_ctrl_value |= PC300_CLKSEL_MASK;
./net/wan/pc300too.c:405:	writel(card->init_ctrl_value, &card->plxbase->init_ctrl);
./net/wan/pc300too.c:407:	i = ramsize / (card->n_ports * (sizeof(pkt_desc) + HDLC_MAX_MRU));
./net/wan/pc300too.c:408:	card->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);
./net/wan/pc300too.c:409:	card->rx_ring_buffers = i - card->tx_ring_buffers;
./net/wan/pc300too.c:411:	card->buff_offset = card->n_ports * sizeof(pkt_desc) *
./net/wan/pc300too.c:412:		(card->tx_ring_buffers + card->rx_ring_buffers);
./net/wan/pc300too.c:415:		card->type == PC300_X21 ? "X21" :
./net/wan/pc300too.c:416:		card->type == PC300_TE ? "TE" : "RSV",
./net/wan/pc300too.c:418:		card->tx_ring_buffers, card->rx_ring_buffers);
./net/wan/pc300too.c:420:	if (card->tx_ring_buffers < 1) {
./net/wan/pc300too.c:427:	writew(0x0041, &card->plxbase->intr_ctrl_stat);
./net/wan/pc300too.c:435:	card->irq = pdev->irq;
./net/wan/pc300too.c:444:	for (i = 0; i < card->n_ports; i++) {
./net/wan/pc300too.c:445:		port_t *port = &card->ports[i];
./net/wan/pc300too.c:451:		dev->irq = card->irq;
./net/wan/pc300too.c:460:		if (card->type == PC300_X21)
./net/wan/hd64570.c:165:		u16 buffs = transmit ? card->tx_ring_buffers
./net/wan/hd64570.c:166:			: card->rx_ring_buffers;
./net/wan/wanxl.c:97:	return &port->card->status->port_status[port->node];
./net/wan/wanxl.c:186:		pci_unmap_single(port->card->pdev, desc->address, skb->len,
./net/wan/wanxl.c:199:	while (desc = &card->status->rx_descs[card->rx_in],
./net/wan/wanxl.c:201:		if ((desc->stat & PACKET_PORT_MASK) > card->n_ports)
./net/wan/wanxl.c:203:				pci_name(card->pdev));
./net/wan/wanxl.c:205:			struct sk_buff *skb = card->rx_skbs[card->rx_in];
./net/wan/wanxl.c:206:			struct port *port = &card->ports[desc->stat &
./net/wan/wanxl.c:213:				pci_unmap_single(card->pdev, desc->address,
./net/wan/wanxl.c:233:					pci_map_single(card->pdev, skb->data,
./net/wan/wanxl.c:236:				card->rx_skbs[card->rx_in] = skb;
./net/wan/wanxl.c:240:		card->rx_in = (card->rx_in + 1) % RX_QUEUE_LENGTH;
./net/wan/wanxl.c:254:        while((stat = readl(card->plx + PLX_DOORBELL_FROM_CARD)) != 0) {
./net/wan/wanxl.c:256:		writel(stat, card->plx + PLX_DOORBELL_FROM_CARD);
./net/wan/wanxl.c:258:                for (i = 0; i < card->n_ports; i++) {
./net/wan/wanxl.c:260:				wanxl_tx_intr(&card->ports[i]);
./net/wan/wanxl.c:262:				wanxl_cable_intr(&card->ports[i]);
./net/wan/wanxl.c:297:	desc->address = pci_map_single(port->card->pdev, skb->data, skb->len,
./net/wan/wanxl.c:302:	       port->card->plx + PLX_DOORBELL_TO_CARD);
./net/wan/wanxl.c:397:	u8 __iomem *dbr = port->card->plx + PLX_DOORBELL_TO_CARD;
./net/wan/wanxl.c:439:	       port->card->plx + PLX_DOORBELL_TO_CARD);
./net/wan/wanxl.c:457:			pci_unmap_single(port->card->pdev, desc->address,
./net/wan/wanxl.c:485:	writel(cmd, card->plx + PLX_MAILBOX_1);
./net/wan/wanxl.c:487:		if (readl(card->plx + PLX_MAILBOX_1) == 0)
./net/wan/wanxl.c:500:	u32 old_value = readl(card->plx + PLX_CONTROL) & ~PLX_CTL_RESET;
./net/wan/wanxl.c:502:	writel(0x80, card->plx + PLX_MAILBOX_0);
./net/wan/wanxl.c:503:	writel(old_value | PLX_CTL_RESET, card->plx + PLX_CONTROL);
./net/wan/wanxl.c:504:	readl(card->plx + PLX_CONTROL); /* wait for posted write */
./net/wan/wanxl.c:506:	writel(old_value, card->plx + PLX_CONTROL);
./net/wan/wanxl.c:507:	readl(card->plx + PLX_CONTROL); /* wait for posted write */
./net/wan/wanxl.c:517:	for (i = 0; i < card->n_ports; i++) {
./net/wan/wanxl.c:518:		unregister_hdlc_device(card->ports[i].dev);
./net/wan/wanxl.c:519:		free_netdev(card->ports[i].dev);
./net/wan/wanxl.c:523:	if (card->irq)
./net/wan/wanxl.c:524:		free_irq(card->irq, card);
./net/wan/wanxl.c:529:		if (card->rx_skbs[i]) {
./net/wan/wanxl.c:530:			pci_unmap_single(card->pdev,
./net/wan/wanxl.c:531:					 card->status->rx_descs[i].address,
./net/wan/wanxl.c:533:			dev_kfree_skb(card->rx_skbs[i]);
./net/wan/wanxl.c:536:	if (card->plx)
./net/wan/wanxl.c:537:		iounmap(card->plx);
./net/wan/wanxl.c:539:	if (card->status)
./net/wan/wanxl.c:541:				    card->status, card->status_address);
./net/wan/wanxl.c:613:	card->pdev = pdev;
./net/wan/wanxl.c:615:	card->status = pci_alloc_consistent(pdev,
./net/wan/wanxl.c:617:					    &card->status_address);
./net/wan/wanxl.c:618:	if (card->status == NULL) {
./net/wan/wanxl.c:626:	       (unsigned long long)card->status_address);
./net/wan/wanxl.c:642:	card->plx = ioremap_nocache(plx_phy, 0x70);
./net/wan/wanxl.c:643:	if (!card->plx) {
./net/wan/wanxl.c:654:	while ((stat = readl(card->plx + PLX_MAILBOX_0)) != 0) {
./net/wan/wanxl.c:678:	ramsize = readl(card->plx + PLX_MAILBOX_2) & MBX2_MEMSZ_MASK;
./net/wan/wanxl.c:703:		card->rx_skbs[i] = skb;
./net/wan/wanxl.c:705:			card->status->rx_descs[i].address =
./net/wan/wanxl.c:706:				pci_map_single(card->pdev, skb->data,
./net/wan/wanxl.c:722:		writel(card->status_address +
./net/wan/wanxl.c:723:		       (void *)&card->status->port_status[i] -
./net/wan/wanxl.c:724:		       (void *)card->status, mem + PDM_OFFSET + 4 + i * 4);
./net/wan/wanxl.c:725:	writel(card->status_address, mem + PDM_OFFSET + 20);
./net/wan/wanxl.c:729:	writel(0, card->plx + PLX_MAILBOX_5);
./net/wan/wanxl.c:740:		if ((stat = readl(card->plx + PLX_MAILBOX_5)) != 0)
./net/wan/wanxl.c:766:	card->irq = pdev->irq;
./net/wan/wanxl.c:770:		struct port *port = &card->ports[i];
./net/wan/wanxl.c:796:		card->n_ports++;
./net/wan/wanxl.c:802:			i ? "," : "", i, card->ports[i].dev->name);
./net/wan/wanxl.c:806:		wanxl_cable_intr(&card->ports[i]); /* get carrier status etc.*/
./net/wan/c101.c:109:	return card->page;
./net/wan/c101.c:114:	card->page = page;
./net/wan/c101.c:115:	writeb(page, card->win0base + C101_PAGE);
./net/wan/c101.c:287:	readb(card->win0base + C101_PAGE); /* Resets SCA? */
./net/wan/c101.c:289:	if (card->irq)
./net/wan/c101.c:290:		free_irq(card->irq, card);
./net/wan/c101.c:292:	if (card->win0base) {
./net/wan/c101.c:293:		iounmap(card->win0base);
./net/wan/c101.c:294:		release_mem_region(card->phy_winbase, C101_MAPPED_RAM_SIZE);
./net/wan/c101.c:297:	free_netdev(card->dev);
./net/wan/c101.c:330:	card->dev = alloc_hdlcdev(card);
./net/wan/c101.c:331:	if (!card->dev) {
./net/wan/c101.c:342:	card->irq = irq;
./net/wan/c101.c:349:	card->phy_winbase = winbase;
./net/wan/c101.c:350:	card->win0base = ioremap(winbase, C101_MAPPED_RAM_SIZE);
./net/wan/c101.c:351:	if (!card->win0base) {
./net/wan/c101.c:357:	card->tx_ring_buffers = TX_RING_BUFFERS;
./net/wan/c101.c:358:	card->rx_ring_buffers = RX_RING_BUFFERS;
./net/wan/c101.c:359:	card->buff_offset = C101_WINDOW_SIZE; /* Bytes 1D00-1FFF reserved */
./net/wan/c101.c:361:	readb(card->win0base + C101_PAGE); /* Resets SCA? */
./net/wan/c101.c:363:	writeb(0, card->win0base + C101_PAGE);
./net/wan/c101.c:364:	writeb(0, card->win0base + C101_DTR); /* Power-up for RAM? */
./net/wan/c101.c:371:	spin_lock_init(&card->lock);
./net/wan/c101.c:379:	card->settings.clock_type = CLOCK_EXT;
./net/wan/c101.c:392:		    card->irq, card->tx_ring_buffers, card->rx_ring_buffers);
./net/wan/c101.c:395:	new_card = &card->next_card;
./net/wan/c101.c:439:		card = card->next_card;
./net/wan/hd64572.c:14: * Packet buffer descriptor rings - starting from card->rambase:
./net/wan/hd64572.c:20: * Packet data buffers - starting from card->rambase + buff_offset:
./net/wan/hd64572.c:51:#define sca_in(reg, card)	     readb(card->scabase + (reg))
./net/wan/hd64572.c:52:#define sca_out(value, reg, card)    writeb(value, card->scabase + (reg))
./net/wan/hd64572.c:53:#define sca_inw(reg, card)	     readw(card->scabase + (reg))
./net/wan/hd64572.c:54:#define sca_outw(value, reg, card)   writew(value, card->scabase + (reg))
./net/wan/hd64572.c:55:#define sca_inl(reg, card)	     readl(card->scabase + (reg))
./net/wan/hd64572.c:56:#define sca_outl(value, reg, card)   writel(value, card->scabase + (reg))
./net/wan/hd64572.c:80:	u16 rx_buffs = port->card->rx_ring_buffers;
./net/wan/hd64572.c:81:	u16 tx_buffs = port->card->tx_ring_buffers;
./net/wan/hd64572.c:98:	return (pkt_desc __iomem *)(port->card->rambase +
./net/wan/hd64572.c:105:	return port->card->buff_offset +
./net/wan/hd64572.c:139:		u16 buffs = transmit ? card->tx_ring_buffers
./net/wan/hd64572.c:140:			: card->rx_ring_buffers;
./net/wan/hd64572.c:164:	sca_outl(desc_offset(port, card->tx_ring_buffers - 1, 0),
./net/wan/hd64572.c:218:	memcpy_fromio(skb->data, card->rambase + buff, len);
./net/wan/hd64572.c:279:		port->rxin = (port->rxin + 1) % card->rx_ring_buffers;
./net/wan/hd64572.c:319:		port->txlast = (port->txlast + 1) % card->tx_ring_buffers;
./net/wan/hd64572.c:530:	for (cnt = 0; cnt < port->card->rx_ring_buffers; cnt++)
./net/wan/hd64572.c:541:	for (cnt = 0; cnt < port->card->tx_ring_buffers; cnt++)
./net/wan/hd64572.c:585:	memcpy_toio(card->rambase + buff, skb->data, len);
./net/wan/hd64572.c:590:	port->txin = (port->txin + 1) % card->tx_ring_buffers;
./net/wan/n2.c:153:	return inb(card->io + N2_PSR) & PSR_PAGEBITS;
./net/wan/n2.c:159:	u8 psr = inb(card->io + N2_PSR);
./net/wan/n2.c:160:	outb((psr & ~PSR_PAGEBITS) | page, card->io + N2_PSR);
./net/wan/n2.c:170:	int io = card->io;
./net/wan/n2.c:214:	int io = port->card->io;
./net/wan/n2.c:237:	int io = port->card->io;
./net/wan/n2.c:308:		if (card->ports[cnt].card) {
./net/wan/n2.c:309:			struct net_device *dev = port_to_dev(&card->ports[cnt]);
./net/wan/n2.c:313:	if (card->irq)
./net/wan/n2.c:314:		free_irq(card->irq, card);
./net/wan/n2.c:316:	if (card->winbase) {
./net/wan/n2.c:317:		iounmap(card->winbase);
./net/wan/n2.c:318:		release_mem_region(card->phy_winbase, USE_WINDOWSIZE);
./net/wan/n2.c:321:	if (card->io)
./net/wan/n2.c:322:		release_region(card->io, N2_IOPORTS);
./net/wan/n2.c:323:	if (card->ports[0].dev)
./net/wan/n2.c:324:		free_netdev(card->ports[0].dev);
./net/wan/n2.c:325:	if (card->ports[1].dev)
./net/wan/n2.c:326:		free_netdev(card->ports[1].dev);
./net/wan/n2.c:363:	card->ports[0].dev = alloc_hdlcdev(&card->ports[0]);
./net/wan/n2.c:364:	card->ports[1].dev = alloc_hdlcdev(&card->ports[1]);
./net/wan/n2.c:365:	if (!card->ports[0].dev || !card->ports[1].dev) {
./net/wan/n2.c:376:	card->io = io;
./net/wan/n2.c:383:	card->irq = irq;
./net/wan/n2.c:390:	card->phy_winbase = winbase;
./net/wan/n2.c:391:	card->winbase = ioremap(winbase, USE_WINDOWSIZE);
./net/wan/n2.c:392:	if (!card->winbase) {
./net/wan/n2.c:423:	card->ram_size = sca_detect_ram(card, card->winbase, MAX_RAM_SIZE);
./net/wan/n2.c:426:	i = card->ram_size / ((valid0 + valid1) * (sizeof(pkt_desc) +
./net/wan/n2.c:429:	card->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);
./net/wan/n2.c:430:	card->rx_ring_buffers = i - card->tx_ring_buffers;
./net/wan/n2.c:432:	card->buff_offset = (valid0 + valid1) * sizeof(pkt_desc) *
./net/wan/n2.c:433:		(card->tx_ring_buffers + card->rx_ring_buffers);
./net/wan/n2.c:436:		card->ram_size / 1024, card->irq,
./net/wan/n2.c:437:		card->tx_ring_buffers, card->rx_ring_buffers);
./net/wan/n2.c:439:	if (card->tx_ring_buffers < 1) {
./net/wan/n2.c:451:		port_t *port = &card->ports[cnt];
./net/wan/n2.c:487:	new_card = &card->next_card;
./net/wan/n2.c:552:		card = card->next_card;
./net/wan/pci200syn.c:98:#define get_port(card, port)	     (&card->ports[port])
./net/wan/pci200syn.c:248:		if (card->ports[i].card)
./net/wan/pci200syn.c:249:			unregister_hdlc_device(card->ports[i].netdev);
./net/wan/pci200syn.c:251:	if (card->irq)
./net/wan/pci200syn.c:252:		free_irq(card->irq, card);
./net/wan/pci200syn.c:254:	if (card->rambase)
./net/wan/pci200syn.c:255:		iounmap(card->rambase);
./net/wan/pci200syn.c:256:	if (card->scabase)
./net/wan/pci200syn.c:257:		iounmap(card->scabase);
./net/wan/pci200syn.c:258:	if (card->plxbase)
./net/wan/pci200syn.c:259:		iounmap(card->plxbase);
./net/wan/pci200syn.c:263:	if (card->ports[0].netdev)
./net/wan/pci200syn.c:264:		free_netdev(card->ports[0].netdev);
./net/wan/pci200syn.c:265:	if (card->ports[1].netdev)
./net/wan/pci200syn.c:266:		free_netdev(card->ports[1].netdev);
./net/wan/pci200syn.c:305:	card->ports[0].netdev = alloc_hdlcdev(&card->ports[0]);
./net/wan/pci200syn.c:306:	card->ports[1].netdev = alloc_hdlcdev(&card->ports[1]);
./net/wan/pci200syn.c:307:	if (!card->ports[0].netdev || !card->ports[1].netdev) {
./net/wan/pci200syn.c:322:	card->plxbase = ioremap(plxphys, PCI200SYN_PLX_SIZE);
./net/wan/pci200syn.c:325:	card->scabase = ioremap(scaphys, PCI200SYN_SCA_SIZE);
./net/wan/pci200syn.c:328:	card->rambase = pci_ioremap_bar(pdev, 3);
./net/wan/pci200syn.c:330:	if (card->plxbase == NULL ||
./net/wan/pci200syn.c:331:	    card->scabase == NULL ||
./net/wan/pci200syn.c:332:	    card->rambase == NULL) {
./net/wan/pci200syn.c:339:	p = &card->plxbase->init_ctrl;
./net/wan/pci200syn.c:348:	ramsize = sca_detect_ram(card, card->rambase,
./net/wan/pci200syn.c:353:	card->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);
./net/wan/pci200syn.c:354:	card->rx_ring_buffers = i - card->tx_ring_buffers;
./net/wan/pci200syn.c:356:	card->buff_offset = 2 * sizeof(pkt_desc) * (card->tx_ring_buffers +
./net/wan/pci200syn.c:357:						    card->rx_ring_buffers);
./net/wan/pci200syn.c:361:		pdev->irq, card->tx_ring_buffers, card->rx_ring_buffers);
./net/wan/pci200syn.c:363:	if (card->tx_ring_buffers < 1) {
./net/wan/pci200syn.c:370:	p = &card->plxbase->intr_ctrl_stat;
./net/wan/pci200syn.c:379:	card->irq = pdev->irq;
./net/wan/pci200syn.c:384:		port_t *port = &card->ports[i];
./net/wan/pci200syn.c:390:		dev->irq = card->irq;
./net/arcnet/com20020-pci.c:75:	priv = card->pci_priv;
./net/arcnet/com20020-pci.c:78:	outb(!!value, priv->misc + ci->leds[card->index].green);
./net/arcnet/com20020-pci.c:90:	priv = card->pci_priv;
./net/arcnet/com20020-pci.c:93:	outb(!!value, priv->misc + ci->leds[card->index].red);
./net/arcnet/com20020-pci.c:233:		card->index = i;
./net/arcnet/com20020-pci.c:234:		card->pci_priv = priv;
./net/arcnet/com20020-pci.c:235:		card->tx_led.brightness_set = led_tx_set;
./net/arcnet/com20020-pci.c:236:		card->tx_led.default_trigger = devm_kasprintf(&pdev->dev,
./net/arcnet/com20020-pci.c:239:		card->tx_led.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,
./net/arcnet/com20020-pci.c:243:		card->tx_led.dev = &dev->dev;
./net/arcnet/com20020-pci.c:244:		card->recon_led.brightness_set = led_recon_set;
./net/arcnet/com20020-pci.c:245:		card->recon_led.default_trigger = devm_kasprintf(&pdev->dev,
./net/arcnet/com20020-pci.c:248:		card->recon_led.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,
./net/arcnet/com20020-pci.c:251:		card->recon_led.dev = &dev->dev;
./net/arcnet/com20020-pci.c:252:		card->dev = dev;
./net/arcnet/com20020-pci.c:254:		ret = devm_led_classdev_register(&pdev->dev, &card->tx_led);
./net/arcnet/com20020-pci.c:258:		ret = devm_led_classdev_register(&pdev->dev, &card->recon_led);
./net/arcnet/com20020-pci.c:270:		list_add(&card->list, &priv->list_dev);
./net/arcnet/com20020-pci.c:290:		struct net_device *dev = card->dev;
./target/sbp/sbp_target.c:610:		spin_lock_irq(&sess->card->lock);
./target/sbp/sbp_target.c:611:		card_valid = (sess->card->local_node != NULL);
./target/sbp/sbp_target.c:612:		spin_unlock_irq(&sess->card->lock);
./target/sbp/sbp_target.c:620:	if (!card_valid || (sess->generation != sess->card->generation)) {
./uwb/whci.c:30:	struct pci_dev *pci_dev = card->pci;
./uwb/whci.c:98:	umc = umc_device_create(&card->pci->dev, n);
./uwb/whci.c:102:	capdata = le_readq(card->uwbbase + UWBCAPDATA(n));
./uwb/whci.c:112:	umc->resource.start  = pci_resource_start(card->pci, bar)
./uwb/whci.c:117:	umc->resource.flags  = card->pci->resource[bar].flags;
./uwb/whci.c:118:	umc->resource.parent = &card->pci->resource[bar];
./uwb/whci.c:119:	umc->irq             = card->pci->irq;
./uwb/whci.c:124:	card->devs[n] = umc;
./uwb/whci.c:134:	struct umc_dev *umc = card->devs[n];
./uwb/whci.c:181:	card->pci = pci;
./uwb/whci.c:182:	card->n_caps = n_caps;
./uwb/whci.c:186:				UWBCAPDATA_SIZE(card->n_caps),
./uwb/whci.c:190:	card->uwbbase = pci_iomap(pci, 0, UWBCAPDATA_SIZE(card->n_caps));
./uwb/whci.c:191:	if (!card->uwbbase)
./uwb/whci.c:195:	for (n = 0; n <= card->n_caps; n++) {
./uwb/whci.c:210:	pci_iounmap(pci, card->uwbbase);
./uwb/whci.c:212:	release_mem_region(pci_resource_start(pci, 0), UWBCAPDATA_SIZE(card->n_caps));
./uwb/whci.c:232:	for (n = card->n_caps; n >= 0 ; n--)
./uwb/whci.c:234:	pci_iounmap(pci, card->uwbbase);
./uwb/whci.c:235:	release_mem_region(pci_resource_start(pci, 0), UWBCAPDATA_SIZE(card->n_caps));
./firewire/core-iso.c:76:		address = dma_map_page(card->device, buffer->pages[i],
./firewire/core-iso.c:78:		if (dma_mapping_error(card->device, address))
./firewire/core-iso.c:133:		dma_unmap_page(card->device, address,
./firewire/core-iso.c:169:	ctx = card->driver->allocate_iso_context(card,
./firewire/core-iso.c:188:	ctx->card->driver->free_iso_context(ctx);
./firewire/core-iso.c:195:	return ctx->card->driver->start_iso(ctx, cycle, sync, tags);
./firewire/core-iso.c:201:	return ctx->card->driver->set_iso_channels(ctx, channels);
./firewire/core-iso.c:209:	return ctx->card->driver->queue_iso(ctx, packet, buffer, payload);
./firewire/core-iso.c:215:	ctx->card->driver->flush_queue_iso(ctx);
./firewire/core-iso.c:221:	return ctx->card->driver->flush_iso_completions(ctx);
./firewire/core-iso.c:227:	return ctx->card->driver->stop_iso(ctx);
./firewire/core-iso.c:370:	spin_lock_irq(&card->lock);
./firewire/core-iso.c:371:	irm_id = card->irm_node->node_id;
./firewire/core-iso.c:372:	spin_unlock_irq(&card->lock);
./firewire/ohci.c:1188:		dma_free_coherent(card->device, PAGE_SIZE, desc,
./firewire/ohci.c:2357:		card->broadcast_channel_auto_allocated = true;
./firewire/ohci.c:2364:	card->priority_budget_implemented = ohci->pri_req_max != 0;
./firewire/core-topology.c:235:		node = fw_node_create(q, port_count, card->color);
./firewire/core-topology.c:241:		if (phy_id == (card->node_id & 0x3f))
./firewire/core-topology.c:273:				child->color = card->color;
./firewire/core-topology.c:313:	card->root_node = node;
./firewire/core-topology.c:314:	card->irm_node = irm_node;
./firewire/core-topology.c:315:	card->gap_count = gap_count;
./firewire/core-topology.c:316:	card->beta_repeaters_present = beta_repeaters_present;
./firewire/core-topology.c:338:		node->color = card->color;
./firewire/core-topology.c:344:			if (child->color == card->color)
./firewire/core-topology.c:366:	card->bm_retries = 0;
./firewire/core-topology.c:387:	card->bm_retries = 0;
./firewire/core-topology.c:394:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-topology.c:395:	card->color++;
./firewire/core-topology.c:396:	if (card->local_node != NULL)
./firewire/core-topology.c:397:		for_each_fw_node(card, card->local_node, report_lost_node);
./firewire/core-topology.c:398:	card->local_node = NULL;
./firewire/core-topology.c:399:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-topology.c:429:	list_add_tail(&card->local_node->link, &list0);
./firewire/core-topology.c:449:		node0->color = card->color;
./firewire/core-topology.c:453:		node1->color = card->color;
./firewire/core-topology.c:456:		if (card->root_node == node1)
./firewire/core-topology.c:457:			card->root_node = node0;
./firewire/core-topology.c:458:		if (card->irm_node == node1)
./firewire/core-topology.c:459:			card->irm_node = node0;
./firewire/core-topology.c:468:				if (node0->ports[i]->color == card->color)
./firewire/core-topology.c:506:	int node_count = (card->root_node->node_id & 0x3f) + 1;
./firewire/core-topology.c:507:	__be32 *map = card->topology_map;
./firewire/core-topology.c:510:	*map++ = cpu_to_be32(be32_to_cpu(card->topology_map[1]) + 1);
./firewire/core-topology.c:516:	fw_compute_block_crc(card->topology_map);
./firewire/core-topology.c:530:	if (!is_next_generation(generation, card->generation) &&
./firewire/core-topology.c:531:	    card->local_node != NULL) {
./firewire/core-topology.c:533:		card->bm_retries = 0;
./firewire/core-topology.c:536:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-topology.c:538:	card->broadcast_channel_allocated = card->broadcast_channel_auto_allocated;
./firewire/core-topology.c:539:	card->node_id = node_id;
./firewire/core-topology.c:545:	card->generation = generation;
./firewire/core-topology.c:546:	card->reset_jiffies = get_jiffies_64();
./firewire/core-topology.c:547:	card->bm_node_id  = 0xffff;
./firewire/core-topology.c:548:	card->bm_abdicate = bm_abdicate;
./firewire/core-topology.c:555:	card->color++;
./firewire/core-topology.c:560:	} else if (card->local_node == NULL) {
./firewire/core-topology.c:561:		card->local_node = local_node;
./firewire/core-topology.c:567:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:92:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-transaction.c:93:	list_for_each_entry(t, &card->transaction_list, link) {
./firewire/core-transaction.c:96:				spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:100:			card->tlabel_mask &= ~(1ULL << t->tlabel);
./firewire/core-transaction.c:104:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:106:	if (&t->link != &card->transaction_list) {
./firewire/core-transaction.c:128:	if (card->driver->cancel_packet(card, &transaction->packet) == 0)
./firewire/core-transaction.c:146:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-transaction.c:148:		spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:152:	card->tlabel_mask &= ~(1ULL << t->tlabel);
./firewire/core-transaction.c:153:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:163:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-transaction.c:166:		spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:172:		  jiffies + card->split_timeout_jiffies);
./firewire/core-transaction.c:174:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:289:	tlabel = card->current_tlabel;
./firewire/core-transaction.c:290:	while (card->tlabel_mask & (1ULL << tlabel)) {
./firewire/core-transaction.c:292:		if (tlabel == card->current_tlabel)
./firewire/core-transaction.c:296:	card->current_tlabel = (tlabel + 1) & 0x3f;
./firewire/core-transaction.c:297:	card->tlabel_mask |= 1ULL << tlabel;
./firewire/core-transaction.c:363:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-transaction.c:367:		spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:382:			destination_id, card->node_id, generation,
./firewire/core-transaction.c:386:	list_add_tail(&t->link, &card->transaction_list);
./firewire/core-transaction.c:388:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:390:	card->driver->send_request(card, &t->packet);
./firewire/core-transaction.c:465:		gap_count = card->driver->read_phy_reg(card, 1);
./firewire/core-transaction.c:482:	card->driver->send_request(card, &phy_config_packet);
./firewire/core-transaction.c:738:	cycles = card->split_timeout_cycles;
./firewire/core-transaction.c:825:	card->driver->send_response(card, &request->response);
./firewire/core-transaction.c:952:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-transaction.c:953:	list_for_each_entry(t, &card->transaction_list, link) {
./firewire/core-transaction.c:956:				spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:960:			card->tlabel_mask &= ~(1ULL << t->tlabel);
./firewire/core-transaction.c:964:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:966:	if (&t->link == &card->transaction_list) {
./firewire/core-transaction.c:1006:	card->driver->cancel_packet(card, &t->packet);
./firewire/core-transaction.c:1060:	memcpy(payload, &card->topology_map[start], length);
./firewire/core-transaction.c:1078:	cycles = card->split_timeout_hi * 8000 + (card->split_timeout_lo >> 19);
./firewire/core-transaction.c:1083:	card->split_timeout_cycles = cycles;
./firewire/core-transaction.c:1084:	card->split_timeout_jiffies = DIV_ROUND_UP(cycles * HZ, 8000);
./firewire/core-transaction.c:1099:		if (!card->priority_budget_implemented) {
./firewire/core-transaction.c:1118:			*data = cpu_to_be32(card->driver->read_csr(card, reg));
./firewire/core-transaction.c:1120:			card->driver->write_csr(card, reg, be32_to_cpu(*data));
./firewire/core-transaction.c:1127:			card->driver->write_csr(card, CSR_STATE_CLEAR,
./firewire/core-transaction.c:1135:			*data = cpu_to_be32(card->split_timeout_hi);
./firewire/core-transaction.c:1137:			spin_lock_irqsave(&card->lock, flags);
./firewire/core-transaction.c:1138:			card->split_timeout_hi = be32_to_cpu(*data) & 7;
./firewire/core-transaction.c:1140:			spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:1148:			*data = cpu_to_be32(card->split_timeout_lo);
./firewire/core-transaction.c:1150:			spin_lock_irqsave(&card->lock, flags);
./firewire/core-transaction.c:1151:			card->split_timeout_lo =
./firewire/core-transaction.c:1154:			spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-transaction.c:1162:			*data = card->maint_utility_register;
./firewire/core-transaction.c:1164:			card->maint_utility_register = *data;
./firewire/core-transaction.c:1171:			*data = cpu_to_be32(card->broadcast_channel);
./firewire/core-transaction.c:1173:			card->broadcast_channel =
./firewire/net.c:510:	guid = cpu_to_be64(dev->card->guid);
./firewire/net.c:787:				      context->card->generation, true);
./firewire/net.c:986:		generation = dev->card->generation;
./firewire/net.c:988:		node_id = dev->card->node_id;
./firewire/net.c:1121:	max_receive = 1U << (dev->card->max_receive + 1);
./firewire/net.c:1133:					dev->card->link_speed, 8,
./firewire/net.c:1464:	SET_NETDEV_DEV(net, card->device);
./firewire/net.c:1489:	put_unaligned_be64(card->guid, &ha->uc.uniq_id);
./firewire/net.c:1490:	ha->uc.max_rec = dev->card->max_receive;
./firewire/net.c:1491:	ha->uc.sspd = dev->card->link_speed;
./firewire/net.c:1503:		   dev_name(card->device));
./firewire/core-card.c:50:	       dev_name(card->device), &vaf);			\
./firewire/core-card.c:121:		BIB_LINK_SPEED(card->link_speed) |
./firewire/core-card.c:122:		BIB_GENERATION(card->config_rom_generation++ % 14 + 2) |
./firewire/core-card.c:124:		BIB_MAX_RECEIVE(card->max_receive) |
./firewire/core-card.c:126:	config_rom[3] = cpu_to_be32(card->guid >> 32);
./firewire/core-card.c:127:	config_rom[4] = cpu_to_be32(card->guid);
./firewire/core-card.c:169:		card->driver->set_config_rom(card, tmp_config_rom,
./firewire/core-card.c:237:	return card->driver->update_phy_reg(card, reg, 0, bit);
./firewire/core-card.c:243:	card->br_short = short_reset;
./firewire/core-card.c:247:	if (!queue_delayed_work(fw_workqueue, &card->br_work,
./firewire/core-card.c:258:	if (card->reset_jiffies != 0 &&
./firewire/core-card.c:259:	    time_before64(get_jiffies_64(), card->reset_jiffies + 2 * HZ)) {
./firewire/core-card.c:260:		if (!queue_delayed_work(fw_workqueue, &card->br_work, 2 * HZ))
./firewire/core-card.c:265:	fw_send_phy_config(card, FW_PHY_CONFIG_NO_NODE_ID, card->generation,
./firewire/core-card.c:267:	reset_bus(card, card->br_short);
./firewire/core-card.c:275:	if (!card->broadcast_channel_allocated) {
./firewire/core-card.c:282:		card->broadcast_channel_allocated = true;
./firewire/core-card.c:285:	device_for_each_child(card->device, (void *)(long)generation,
./firewire/core-card.c:296:	if (!schedule_delayed_work(&card->bm_work, delay))
./firewire/core-card.c:314:	spin_lock_irq(&card->lock);
./firewire/core-card.c:316:	if (card->local_node == NULL) {
./firewire/core-card.c:317:		spin_unlock_irq(&card->lock);
./firewire/core-card.c:321:	generation = card->generation;
./firewire/core-card.c:323:	root_node = card->root_node;
./firewire/core-card.c:330:	irm_device = card->irm_node->data;
./firewire/core-card.c:339:	irm_id   = card->irm_node->node_id;
./firewire/core-card.c:340:	local_id = card->local_node->node_id;
./firewire/core-card.c:343:			     card->reset_jiffies + DIV_ROUND_UP(HZ, 8));
./firewire/core-card.c:345:	if ((is_next_generation(generation, card->bm_generation) &&
./firewire/core-card.c:346:	     !card->bm_abdicate) ||
./firewire/core-card.c:347:	    (card->bm_generation != generation && grace)) {
./firewire/core-card.c:360:		if (!card->irm_node->link_on) {
./firewire/core-card.c:377:		spin_unlock_irq(&card->lock);
./firewire/core-card.c:390:		spin_lock_irq(&card->lock);
./firewire/core-card.c:391:		if (rcode == RCODE_COMPLETE && generation == card->generation)
./firewire/core-card.c:392:			card->bm_node_id =
./firewire/core-card.c:394:		spin_unlock_irq(&card->lock);
./firewire/core-card.c:414:		spin_lock_irq(&card->lock);
./firewire/core-card.c:428:	} else if (card->bm_generation != generation) {
./firewire/core-card.c:433:		spin_unlock_irq(&card->lock);
./firewire/core-card.c:443:	card->bm_generation = generation;
./firewire/core-card.c:456:		spin_unlock_irq(&card->lock);
./firewire/core-card.c:478:	if (!card->beta_repeaters_present &&
./firewire/core-card.c:490:	if (card->bm_retries++ < 5 &&
./firewire/core-card.c:491:	    (card->gap_count != gap_count || new_root_id != root_id))
./firewire/core-card.c:494:	spin_unlock_irq(&card->lock);
./firewire/core-card.c:533:	card->index = atomic_inc_return(&index);
./firewire/core-card.c:534:	card->driver = driver;
./firewire/core-card.c:535:	card->device = device;
./firewire/core-card.c:536:	card->current_tlabel = 0;
./firewire/core-card.c:537:	card->tlabel_mask = 0;
./firewire/core-card.c:538:	card->split_timeout_hi = DEFAULT_SPLIT_TIMEOUT / 8000;
./firewire/core-card.c:539:	card->split_timeout_lo = (DEFAULT_SPLIT_TIMEOUT % 8000) << 19;
./firewire/core-card.c:540:	card->split_timeout_cycles = DEFAULT_SPLIT_TIMEOUT;
./firewire/core-card.c:541:	card->split_timeout_jiffies =
./firewire/core-card.c:543:	card->color = 0;
./firewire/core-card.c:544:	card->broadcast_channel = BROADCAST_CHANNEL_INITIAL;
./firewire/core-card.c:546:	kref_init(&card->kref);
./firewire/core-card.c:547:	init_completion(&card->done);
./firewire/core-card.c:548:	INIT_LIST_HEAD(&card->transaction_list);
./firewire/core-card.c:549:	INIT_LIST_HEAD(&card->phy_receiver_list);
./firewire/core-card.c:550:	spin_lock_init(&card->lock);
./firewire/core-card.c:552:	card->local_node = NULL;
./firewire/core-card.c:554:	INIT_DELAYED_WORK(&card->br_work, br_work);
./firewire/core-card.c:555:	INIT_DELAYED_WORK(&card->bm_work, bm_work);
./firewire/core-card.c:564:	card->max_receive = max_receive;
./firewire/core-card.c:565:	card->link_speed = link_speed;
./firewire/core-card.c:566:	card->guid = guid;
./firewire/core-card.c:571:	ret = card->driver->enable(card, tmp_config_rom, config_rom_length);
./firewire/core-card.c:573:		list_add_tail(&card->link, &card_list);
./firewire/core-card.c:677:	complete(&card->done);
./firewire/core-card.c:685:	card->driver->update_phy_reg(card, 4,
./firewire/core-card.c:690:	list_del_init(&card->link);
./firewire/core-card.c:694:	dummy_driver.free_iso_context	= card->driver->free_iso_context;
./firewire/core-card.c:695:	dummy_driver.stop_iso		= card->driver->stop_iso;
./firewire/core-card.c:696:	card->driver = &dummy_driver;
./firewire/core-card.c:702:	wait_for_completion(&card->done);
./firewire/core-card.c:704:	WARN_ON(!list_empty(&card->transaction_list));
./firewire/core-cdev.c:356:	spin_lock_irq(&card->lock);
./firewire/core-cdev.c:362:	event->local_node_id = card->local_node->node_id;
./firewire/core-cdev.c:363:	event->bm_node_id    = card->bm_node_id;
./firewire/core-cdev.c:364:	event->irm_node_id   = card->irm_node->node_id;
./firewire/core-cdev.c:365:	event->root_node_id  = card->root_node->node_id;
./firewire/core-cdev.c:367:	spin_unlock_irq(&card->lock);
./firewire/core-cdev.c:452:	a->card = client->device->card->index;
./firewire/core-cdev.c:741:		req->card	= card->index;
./firewire/core-cdev.c:1214:	cycle_time = card->driver->read_csr(card, CSR_CYCLE_TIME);
./firewire/core-cdev.c:1262:			  client->device->card->reset_jiffies + HZ)) {
./firewire/core-cdev.c:1476:	if (a->speed > client->device->card->link_speed ||
./firewire/core-cdev.c:1547:	card->driver->send_request(card, &e->p);
./firewire/core-cdev.c:1561:	spin_lock_irq(&card->lock);
./firewire/core-cdev.c:1563:	list_move_tail(&client->phy_receiver_link, &card->phy_receiver_list);
./firewire/core-cdev.c:1566:	spin_unlock_irq(&card->lock);
./firewire/core-cdev.c:1577:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-cdev.c:1579:	list_for_each_entry(client, &card->phy_receiver_list, phy_receiver_link) {
./firewire/core-cdev.c:1594:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-cdev.c:1755:	spin_lock_irq(&client->device->card->lock);
./firewire/core-cdev.c:1757:	spin_unlock_irq(&client->device->card->lock);
./firewire/core-device.c:250:	return device->card->driver->enable_phys_dma(device->card,
./firewire/core-device.c:570:	    card->beta_repeaters_present) {
./firewire/core-device.c:575:			device->max_speed = card->link_speed;
./firewire/core-device.c:809:			  device->card->reset_jiffies + SHUTDOWN_DELAY)
./firewire/core-device.c:810:	    && !list_empty(&device->card->link)) {
./firewire/core-device.c:842:	spin_lock_irqsave(&card->lock, flags);
./firewire/core-device.c:844:	spin_unlock_irqrestore(&card->lock, flags);
./firewire/core-device.c:901:	spin_lock_irq(&card->lock);  /* serialize node access */
./firewire/core-device.c:918:		old->generation = card->generation;
./firewire/core-device.c:925:		if (current_node == card->root_node)
./firewire/core-device.c:931:	spin_unlock_irq(&card->lock);
./firewire/core-device.c:945:	if (!card->broadcast_channel_allocated)
./firewire/core-device.c:1022:			if (device->node == card->root_node)
./firewire/core-device.c:1029:	revived_dev = device_find_child(card->device,
./firewire/core-device.c:1051:	device->device.parent = card->device;
./firewire/core-device.c:1101:	if (device->node == card->root_node)
./firewire/core-device.c:1205:	if (node_id == card->root_node->node_id)
./firewire/core-device.c:1241:		 * card->lock.
./firewire/core-device.c:1247:		device->generation = card->generation;
./firewire/core-device.c:1248:		device->is_local = node == card->local_node;
./firewire/core-device.c:1278:		device->generation = card->generation;
./firewire/core-device.c:1295:		device->generation = card->generation;
./firewire/core-device.c:1324:				list_empty(&card->link) ? 0 : SHUTDOWN_DELAY);
./firewire/sbp2.c:578:		dma_map_single(device->card->device, &orb->response,
./firewire/sbp2.c:580:	if (dma_mapping_error(device->card->device, orb->response_bus))
./firewire/sbp2.c:612:		dma_map_single(device->card->device, &orb->request,
./firewire/sbp2.c:614:	if (dma_mapping_error(device->card->device, orb->base.request_bus))
./firewire/sbp2.c:645:	dma_unmap_single(device->card->device, orb->base.request_bus,
./firewire/sbp2.c:648:	dma_unmap_single(device->card->device, orb->response_bus,
./firewire/sbp2.c:718:	    lu->generation != card->generation) {
./firewire/sbp2.c:741:	if (lu->blocked && lu->generation == card->generation) {
./firewire/sbp2.c:825:	local_node_id = device->card->node_id;
./firewire/sbp2.c:891:	if (generation != device->card->generation) {
./firewire/sbp2.c:932:	local_node_id = device->card->node_id;
./firewire/sbp2.c:945:		if (generation == device->card->generation ||
./firewire/sbp2.c:1147:	if (dma_get_max_seg_size(device->card->device) > SBP2_MAX_SEG_SIZE)
./firewire/sbp2.c:1148:		WARN_ON(dma_set_max_seg_size(device->card->device,
./firewire/sbp2.c:1168:				   device->card->device) < 0)
./firewire/sbp2.c:1192:				device->card->max_receive - 1);
./firewire/sbp2.c:1390:	dma_unmap_single(device->card->device, orb->base.request_bus,
./firewire/sbp2.c:1392:	sbp2_unmap_scatterlist(device->card->device, orb);
./firewire/sbp2.c:1431:		dma_map_single(device->card->device, orb->page_table,
./firewire/sbp2.c:1433:	if (dma_mapping_error(device->card->device, orb->page_table_bus))
./firewire/sbp2.c:1493:		dma_map_single(device->card->device, &orb->request,
./firewire/sbp2.c:1495:	if (dma_mapping_error(device->card->device, orb->base.request_bus)) {
./firewire/sbp2.c:1496:		sbp2_unmap_scatterlist(device->card->device, orb);
./mmc/host/dw_mmc.c:1717:		if (card->type == MMC_TYPE_SDIO ||
./mmc/host/dw_mmc.c:1718:			card->type == MMC_TYPE_SD_COMBO) {
./mmc/host/dw_mmc.c:3312:	if (device_property_read_u32(dev, "card-detect-delay", &pdata->detect_delay_ms))
./mmc/host/dw_mmc.c:3313:		dev_info(dev, "card-detect-delay not found.\n");
./mmc/host/sdhci-spear.c:118:				"failed to request card-detect gpio%d\n",
./mmc/host/sdhci-esdhc-imx.c:1200:				"failed to request card-detect gpio!\n");
./mmc/host/tmio_mmc_core.c:957:		 * delay proved necessary for reliable card-insertion probing.
./mmc/host/tmio_mmc_core.c:1093:	struct tmio_mmc_host *host = mmc_priv(card->host);
./mmc/host/dw_mmc.h:374:/* card-type register defines */
./mmc/host/au1xmmc.c:31: * but now the SecureDigital card-detect feature of CD/DAT3 is ineffective
./mmc/host/sdhci-pci-core.c:489:	struct sdhci_host *host = mmc_priv(card->host);
./mmc/host/mxcmmc.c:948:	if (is_imx31_mmc(mxcmci) && card->type == MMC_TYPE_SDIO)
./mmc/host/sdhci-xenon.c:335:	priv->init_card_type = card->type;
./mmc/host/vub300.c:1361:	int sdio_funcs = card->sdio_funcs;
./mmc/host/vub300.c:1364:			 "vub_%04X%04X", card->cis.vendor, card->cis.device);
./mmc/host/vub300.c:1368:		struct sdio_func *sf = card->sdio_func[n];
./mmc/host/vub300.c:1376:	retval = request_firmware(&fw, vub300->vub_name, &card->dev);
./mmc/host/vub300.c:1380:		retval = request_firmware(&fw, vub300->vub_name, &card->dev);
./mmc/host/vub300.c:1762:		} else if (0 == vub300->mmc->card->sdio_funcs) {
./mmc/host/omap_hsmmc.c:752:	/* Do not initialize card-specific things if the power is off */
./mmc/host/cavium.c:640:	    (mmc->card->scr.cmds & SD_SCR_CMD23_SUPPORT)))
./mmc/host/cavium.c:659:		dev_err(&mmc->card->dev,
./mmc/core/host.h:54:	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
./mmc/core/host.h:59:	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
./mmc/core/host.h:64:	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
./mmc/core/host.h:69:	return card->host->ios.enhanced_strobe;
./mmc/core/block.c:180:	if (card->ext_csd.boot_ro_lock & EXT_CSD_BOOT_WP_B_PERM_WP_EN)
./mmc/core/block.c:182:	else if (card->ext_csd.boot_ro_lock & EXT_CSD_BOOT_WP_B_PWR_WP_EN)
./mmc/core/block.c:420:				mmc_hostname(card->host), __func__);
./mmc/core/block.c:426:		mmc_hostname(card->host), __func__);
./mmc/core/block.c:434:		       mmc_hostname(card->host), __func__, err);
./mmc/core/block.c:436:	pr_debug("%s: %s - SANITIZE COMPLETED\n", mmc_hostname(card->host),
./mmc/core/block.c:506:		err = mmc_app_cmd(card->host, card);
./mmc/core/block.c:529:	mmc_wait_for_req(card->host, &mrq);
./mmc/core/block.c:532:		dev_err(mmc_dev(card->host), "%s: cmd error %d\n",
./mmc/core/block.c:537:		dev_err(mmc_dev(card->host), "%s: data error %d\n",
./mmc/core/block.c:549:		struct mmc_blk_data *main_md = dev_get_drvdata(&card->dev);
./mmc/core/block.c:556:		card->ext_csd.part_config = value;
./mmc/core/block.c:576:			dev_err(mmc_dev(card->host),
./mmc/core/block.c:774:		if (card->ext_csd.cmdq_en) {
./mmc/core/block.c:779:		mmc_retune_pause(card->host);
./mmc/core/block.c:791:		mmc_retune_unpause(card->host);
./mmc/core/block.c:792:		if (card->reenable_cmdq && !card->ext_csd.cmdq_en)
./mmc/core/block.c:803:	struct mmc_blk_data *main_md = dev_get_drvdata(&card->dev);
./mmc/core/block.c:809:		u8 part_config = card->ext_csd.part_config;
./mmc/core/block.c:820:				 card->ext_csd.part_time);
./mmc/core/block.c:826:		card->ext_csd.part_config = part_config;
./mmc/core/block.c:848:	cmd.arg = card->rca << 16;
./mmc/core/block.c:851:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./mmc/core/block.c:854:	if (!mmc_host_is_spi(card->host) && !(cmd.resp[0] & R1_APP_CMD))
./mmc/core/block.c:879:	mmc_wait_for_req(card->host, &mrq);
./mmc/core/block.c:914:		if ((card->host->caps & MMC_CAP_WAIT_WHILE_BUSY) &&
./mmc/core/block.c:924:				mmc_hostname(card->host),
./mmc/core/block.c:943:	struct mmc_host *host = card->host;
./mmc/core/block.c:1073:		mmc_retune_recheck(card->host);
./mmc/core/block.c:1083:		if (mmc_detect_card_removed(card->host))
./mmc/core/block.c:1095:	if (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ)
./mmc/core/block.c:1170:			dev_get_drvdata(&host->card->dev);
./mmc/core/block.c:1213:	struct mmc_blk_data *main_md = dev_get_drvdata(&card->dev);
./mmc/core/block.c:1236:				 card->ext_csd.boot_ro_lock |
./mmc/core/block.c:1238:				 card->ext_csd.part_time);
./mmc/core/block.c:1243:			card->ext_csd.boot_ro_lock |=
./mmc/core/block.c:1289:		if (card->quirks & MMC_QUIRK_INAND_CMD38) {
./mmc/core/block.c:1299:	} while (err == -EIO && !mmc_blk_reset(md, card->host, type));
./mmc/core/block.c:1331:	if (card->quirks & MMC_QUIRK_INAND_CMD38) {
./mmc/core/block.c:1351:		if (card->quirks & MMC_QUIRK_INAND_CMD38) {
./mmc/core/block.c:1370:	if (err && !mmc_blk_reset(md, card->host, type))
./mmc/core/block.c:1399:	if (!(card->ext_csd.rel_param & EXT_CSD_WR_REL_PARAM_EN)) {
./mmc/core/block.c:1401:		if (!IS_ALIGNED(blk_rq_pos(req), card->ext_csd.rel_sectors))
./mmc/core/block.c:1404:		if (brq->data.blocks > card->ext_csd.rel_sectors)
./mmc/core/block.c:1405:			brq->data.blocks = card->ext_csd.rel_sectors;
./mmc/core/block.c:1406:		else if (brq->data.blocks < card->ext_csd.rel_sectors)
./mmc/core/block.c:1469:	int need_retune = card->host->need_retune;
./mmc/core/block.c:1516:	if (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ) {
./mmc/core/block.c:1616:	if (brq->data.blocks > card->host->max_blk_count)
./mmc/core/block.c:1617:		brq->data.blocks = card->host->max_blk_count;
./mmc/core/block.c:1625:		if (mmc_host_is_spi(card->host) && (rq_data_dir(req) == READ) &&
./mmc/core/block.c:1642:		if (card->host->ops->multi_io_quirk)
./mmc/core/block.c:1643:			brq->data.blocks = card->host->ops->multi_io_quirk(card,
./mmc/core/block.c:1656:	*do_data_tag = card->ext_csd.data_tag_unit_size &&
./mmc/core/block.c:1660:			card->ext_csd.data_tag_unit_size);
./mmc/core/block.c:1713:		if (!mmc_host_is_spi(card->host) ||
./mmc/core/block.c:1744:	    (do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23) ||
./mmc/core/block.c:1818:	mmc_start_areq(mq->card->host, &mqrq->areq, NULL);
./mmc/core/block.c:1862:		old_areq = mmc_start_areq(card->host, new_areq, &status);
./mmc/core/block.c:1906:			if (mmc_blk_reset(md, card->host, type)) {
./mmc/core/block.c:1926:			if (!mmc_blk_reset(md, card->host, type))
./mmc/core/block.c:1934:			err = mmc_blk_reset(md, card->host, type);
./mmc/core/block.c:1984:			mmc_start_areq(card->host,
./mmc/core/block.c:2053:			card->host->context_info.is_waiting_last_req = false;
./mmc/core/block.c:2059:		card->host->context_info.is_waiting_last_req = false;
./mmc/core/block.c:2070:	       !(card->csd.cmdclass & CCC_BLOCK_WRITE);
./mmc/core/block.c:2093:			dev_err(mmc_dev(card->host),
./mmc/core/block.c:2153:		 "mmcblk%u%s", card->host->index, subname ? subname : "");
./mmc/core/block.c:2157:					     card->ext_csd.data_sector_size);
./mmc/core/block.c:2163:	if (mmc_host_cmd23(card->host)) {
./mmc/core/block.c:2165:		     card->csd.mmca_vsn >= CSD_SPEC_VER_3) ||
./mmc/core/block.c:2167:		     card->scr.cmds & SD_SCR_CMD23_SUPPORT))
./mmc/core/block.c:2173:	    ((card->ext_csd.rel_param & EXT_CSD_WR_REL_PARAM_EN) ||
./mmc/core/block.c:2174:	     card->ext_csd.rel_sectors)) {
./mmc/core/block.c:2199:		size = card->ext_csd.sectors;
./mmc/core/block.c:2205:		size = (typeof(sector_t))card->csd.capacity
./mmc/core/block.c:2206:			<< (card->csd.read_blkbits - 9);
./mmc/core/block.c:2209:	return mmc_blk_alloc_req(card, &card->dev, size, false, NULL,
./mmc/core/block.c:2252:	for (idx = 0; idx < card->nr_parts; idx++) {
./mmc/core/block.c:2253:		if (card->part[idx].size) {
./mmc/core/block.c:2255:				card->part[idx].part_cfg,
./mmc/core/block.c:2256:				card->part[idx].size >> 9,
./mmc/core/block.c:2257:				card->part[idx].force_ro,
./mmc/core/block.c:2258:				card->part[idx].name,
./mmc/core/block.c:2259:				card->part[idx].area_type);
./mmc/core/block.c:2287:					card->ext_csd.boot_ro_lockable)
./mmc/core/block.c:2326:	     card->ext_csd.boot_ro_lockable) {
./mmc/core/block.c:2329:		if (card->ext_csd.boot_ro_lock & EXT_CSD_BOOT_WP_B_PWR_WP_DIS)
./mmc/core/block.c:2360:	struct mmc_blk_data *md = dev_get_drvdata(&card->dev);
./mmc/core/block.c:2389:	struct mmc_blk_data *md = dev_get_drvdata(&card->dev);
./mmc/core/block.c:2462:	if (!card->debugfs_root)
./mmc/core/block.c:2465:	root = card->debugfs_root;
./mmc/core/block.c:2489:	if (!card->debugfs_root)
./mmc/core/block.c:2525:	if (!(card->csd.cmdclass & CCC_BLOCK_READ))
./mmc/core/block.c:2543:	dev_set_drvdata(&card->dev, md);
./mmc/core/block.c:2556:	pm_runtime_set_autosuspend_delay(&card->dev, 3000);
./mmc/core/block.c:2557:	pm_runtime_use_autosuspend(&card->dev);
./mmc/core/block.c:2563:	if (card->type != MMC_TYPE_SD_COMBO) {
./mmc/core/block.c:2564:		pm_runtime_set_active(&card->dev);
./mmc/core/block.c:2565:		pm_runtime_enable(&card->dev);
./mmc/core/block.c:2578:	struct mmc_blk_data *md = dev_get_drvdata(&card->dev);
./mmc/core/block.c:2582:	pm_runtime_get_sync(&card->dev);
./mmc/core/block.c:2583:	mmc_claim_host(card->host);
./mmc/core/block.c:2585:	mmc_release_host(card->host);
./mmc/core/block.c:2586:	if (card->type != MMC_TYPE_SD_COMBO)
./mmc/core/block.c:2587:		pm_runtime_disable(&card->dev);
./mmc/core/block.c:2588:	pm_runtime_put_noidle(&card->dev);
./mmc/core/block.c:2590:	dev_set_drvdata(&card->dev, NULL);
./mmc/core/block.c:2596:	struct mmc_blk_data *md = dev_get_drvdata(&card->dev);
./mmc/core/sd_ops.c:30:	if (WARN_ON(card && card->host != host))
./mmc/core/sd_ops.c:36:		cmd.arg = card->rca << 16;
./mmc/core/sd_ops.c:139:	return mmc_wait_for_app_cmd(card->host, card, &cmd, MMC_CMD_RETRIES);
./mmc/core/sd_ops.c:246:	err = mmc_app_cmd(card->host, card);
./mmc/core/sd_ops.c:253:	scr = kmalloc(sizeof(card->raw_scr), GFP_KERNEL);
./mmc/core/sd_ops.c:274:	mmc_wait_for_req(card->host, &mrq);
./mmc/core/sd_ops.c:276:	card->raw_scr[0] = be32_to_cpu(scr[0]);
./mmc/core/sd_ops.c:277:	card->raw_scr[1] = be32_to_cpu(scr[1]);
./mmc/core/sd_ops.c:321:	mmc_wait_for_req(card->host, &mrq);
./mmc/core/sd_ops.c:341:	err = mmc_app_cmd(card->host, card);
./mmc/core/sd_ops.c:362:	mmc_wait_for_req(card->host, &mrq);
./mmc/core/sdio_cis.c:67:		card->num_info = nr_strings;
./mmc/core/sdio_cis.c:68:		card->info = (const char**)buffer;
./mmc/core/sdio_cis.c:89:		card->cis.vendor = vendor;
./mmc/core/sdio_cis.c:90:		card->cis.device = device;
./mmc/core/sdio_cis.c:136:			       mmc_hostname(card->host), tpl_descr, code, size);
./mmc/core/sdio_cis.c:154:	card->cis.blksize = buf[1] | (buf[2] << 8);
./mmc/core/sdio_cis.c:157:	card->cis.max_dtr = speed_val[(buf[3] >> 3) & 15] *
./mmc/core/sdio_cis.c:177:	vsn = func->card->cccr.sdio_vsn;
./mmc/core/sdio_cis.c:182:			mmc_hostname(card->host));
./mmc/core/sdio_cis.c:263:		prev = &card->tuples;
./mmc/core/sdio_cis.c:325:				       mmc_hostname(card->host),
./mmc/core/sdio_cis.c:348:		*prev = card->tuples;
./mmc/core/sdio_cis.c:362:	tuple = card->tuples;
./mmc/core/sdio_cis.c:370:	card->tuples = NULL;
./mmc/core/sdio_cis.c:385:	get_device(&func->card->dev);
./mmc/core/sdio_cis.c:392:		func->vendor = func->card->cis.vendor;
./mmc/core/sdio_cis.c:393:		func->device = func->card->cis.device;
./mmc/core/sdio_cis.c:405:	while (tuple && tuple != func->card->tuples) {
./mmc/core/sdio_cis.c:417:	put_device(&func->card->dev);
./mmc/core/queue.c:45:	struct mmc_context_info *cntx = &mq->card->host->context_info;
./mmc/core/queue.c:110:	cntx = &mq->card->host->context_info;
./mmc/core/queue.c:143:	q->limits.discard_granularity = card->pref_erase << 9;
./mmc/core/queue.c:145:	if (card->pref_erase > max_discard)
./mmc/core/queue.c:163:	struct mmc_host *host = card->host;
./mmc/core/queue.c:192:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:72:	u32 *resp = card->raw_cid;
./mmc/core/mmc.c:78:	switch (card->csd.mmca_vsn) {
./mmc/core/mmc.c:81:		card->cid.manfid	= UNSTUFF_BITS(resp, 104, 24);
./mmc/core/mmc.c:82:		card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
./mmc/core/mmc.c:83:		card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
./mmc/core/mmc.c:84:		card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
./mmc/core/mmc.c:85:		card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
./mmc/core/mmc.c:86:		card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
./mmc/core/mmc.c:87:		card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
./mmc/core/mmc.c:88:		card->cid.prod_name[6]	= UNSTUFF_BITS(resp, 48, 8);
./mmc/core/mmc.c:89:		card->cid.hwrev		= UNSTUFF_BITS(resp, 44, 4);
./mmc/core/mmc.c:90:		card->cid.fwrev		= UNSTUFF_BITS(resp, 40, 4);
./mmc/core/mmc.c:91:		card->cid.serial	= UNSTUFF_BITS(resp, 16, 24);
./mmc/core/mmc.c:92:		card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
./mmc/core/mmc.c:93:		card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
./mmc/core/mmc.c:99:		card->cid.manfid	= UNSTUFF_BITS(resp, 120, 8);
./mmc/core/mmc.c:100:		card->cid.oemid		= UNSTUFF_BITS(resp, 104, 16);
./mmc/core/mmc.c:101:		card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
./mmc/core/mmc.c:102:		card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
./mmc/core/mmc.c:103:		card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
./mmc/core/mmc.c:104:		card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
./mmc/core/mmc.c:105:		card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
./mmc/core/mmc.c:106:		card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
./mmc/core/mmc.c:107:		card->cid.prv		= UNSTUFF_BITS(resp, 48, 8);
./mmc/core/mmc.c:108:		card->cid.serial	= UNSTUFF_BITS(resp, 16, 32);
./mmc/core/mmc.c:109:		card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
./mmc/core/mmc.c:110:		card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
./mmc/core/mmc.c:115:			mmc_hostname(card->host), card->csd.mmca_vsn);
./mmc/core/mmc.c:124:	if (card->ext_csd.erase_group_def & 1)
./mmc/core/mmc.c:125:		card->erase_size = card->ext_csd.hc_erase_size;
./mmc/core/mmc.c:127:		card->erase_size = card->csd.erase_size;
./mmc/core/mmc.c:137:	struct mmc_csd *csd = &card->csd;
./mmc/core/mmc.c:139:	u32 *resp = card->raw_csd;
./mmc/core/mmc.c:149:			mmc_hostname(card->host), csd->structure);
./mmc/core/mmc.c:189:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:190:	u8 card_type = card->ext_csd.raw_card_type;
./mmc/core/mmc.c:244:	    card->ext_csd.strobe_support &&
./mmc/core/mmc.c:248:	card->ext_csd.hs_max_dtr = hs_max_dtr;
./mmc/core/mmc.c:249:	card->ext_csd.hs200_max_dtr = hs200_max_dtr;
./mmc/core/mmc.c:250:	card->mmc_avail_type = avail_type;
./mmc/core/mmc.c:260:	card->ext_csd.enhanced_area_offset = -EINVAL;
./mmc/core/mmc.c:261:	card->ext_csd.enhanced_area_size = -EINVAL;
./mmc/core/mmc.c:270:		if (card->ext_csd.partition_setting_completed) {
./mmc/core/mmc.c:279:			card->ext_csd.enhanced_area_offset =
./mmc/core/mmc.c:285:				card->ext_csd.enhanced_area_offset <<= 9;
./mmc/core/mmc.c:289:			card->ext_csd.enhanced_area_size =
./mmc/core/mmc.c:292:			card->ext_csd.enhanced_area_size *=
./mmc/core/mmc.c:294:			card->ext_csd.enhanced_area_size <<= 9;
./mmc/core/mmc.c:297:				mmc_hostname(card->host));
./mmc/core/mmc.c:306:	card->part[card->nr_parts].size = size;
./mmc/core/mmc.c:307:	card->part[card->nr_parts].part_cfg = part_cfg;
./mmc/core/mmc.c:308:	sprintf(card->part[card->nr_parts].name, name, idx);
./mmc/core/mmc.c:309:	card->part[card->nr_parts].force_ro = ro;
./mmc/core/mmc.c:310:	card->part[card->nr_parts].area_type = area_type;
./mmc/core/mmc.c:311:	card->nr_parts++;
./mmc/core/mmc.c:337:			if (card->ext_csd.partition_setting_completed == 0) {
./mmc/core/mmc.c:339:					mmc_hostname(card->host));
./mmc/core/mmc.c:372:	card->ext_csd.raw_ext_csd_structure = ext_csd[EXT_CSD_STRUCTURE];
./mmc/core/mmc.c:373:	if (card->csd.structure == 3) {
./mmc/core/mmc.c:374:		if (card->ext_csd.raw_ext_csd_structure > 2) {
./mmc/core/mmc.c:376:				"version %d\n", mmc_hostname(card->host),
./mmc/core/mmc.c:377:					card->ext_csd.raw_ext_csd_structure);
./mmc/core/mmc.c:383:	np = mmc_of_find_child_device(card->host, 0);
./mmc/core/mmc.c:393:	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
./mmc/core/mmc.c:398:	card->ext_csd.raw_sectors[0] = ext_csd[EXT_CSD_SEC_CNT + 0];
./mmc/core/mmc.c:399:	card->ext_csd.raw_sectors[1] = ext_csd[EXT_CSD_SEC_CNT + 1];
./mmc/core/mmc.c:400:	card->ext_csd.raw_sectors[2] = ext_csd[EXT_CSD_SEC_CNT + 2];
./mmc/core/mmc.c:401:	card->ext_csd.raw_sectors[3] = ext_csd[EXT_CSD_SEC_CNT + 3];
./mmc/core/mmc.c:402:	if (card->ext_csd.rev >= 2) {
./mmc/core/mmc.c:403:		card->ext_csd.sectors =
./mmc/core/mmc.c:410:		if (card->ext_csd.sectors > (2u * 1024 * 1024 * 1024) / 512)
./mmc/core/mmc.c:414:	card->ext_csd.strobe_support = ext_csd[EXT_CSD_STROBE_SUPPORT];
./mmc/core/mmc.c:415:	card->ext_csd.raw_card_type = ext_csd[EXT_CSD_CARD_TYPE];
./mmc/core/mmc.c:418:	card->ext_csd.raw_s_a_timeout = ext_csd[EXT_CSD_S_A_TIMEOUT];
./mmc/core/mmc.c:419:	card->ext_csd.raw_erase_timeout_mult =
./mmc/core/mmc.c:421:	card->ext_csd.raw_hc_erase_grp_size =
./mmc/core/mmc.c:423:	if (card->ext_csd.rev >= 3) {
./mmc/core/mmc.c:425:		card->ext_csd.part_config = ext_csd[EXT_CSD_PART_CONFIG];
./mmc/core/mmc.c:428:		card->ext_csd.part_time = 10 * ext_csd[EXT_CSD_PART_SWITCH_TIME];
./mmc/core/mmc.c:430:		if (card->ext_csd.part_time &&
./mmc/core/mmc.c:431:		    card->ext_csd.part_time < MMC_MIN_PART_SWITCH_TIME)
./mmc/core/mmc.c:432:			card->ext_csd.part_time = MMC_MIN_PART_SWITCH_TIME;
./mmc/core/mmc.c:436:			card->ext_csd.sa_timeout =
./mmc/core/mmc.c:438:		card->ext_csd.erase_group_def =
./mmc/core/mmc.c:440:		card->ext_csd.hc_erase_timeout = 300 *
./mmc/core/mmc.c:442:		card->ext_csd.hc_erase_size =
./mmc/core/mmc.c:445:		card->ext_csd.rel_sectors = ext_csd[EXT_CSD_REL_WR_SEC_C];
./mmc/core/mmc.c:451:		if (ext_csd[EXT_CSD_BOOT_MULT] && mmc_boot_partition_access(card->host)) {
./mmc/core/mmc.c:462:	card->ext_csd.raw_hc_erase_gap_size =
./mmc/core/mmc.c:464:	card->ext_csd.raw_sec_trim_mult =
./mmc/core/mmc.c:466:	card->ext_csd.raw_sec_erase_mult =
./mmc/core/mmc.c:468:	card->ext_csd.raw_sec_feature_support =
./mmc/core/mmc.c:470:	card->ext_csd.raw_trim_mult =
./mmc/core/mmc.c:472:	card->ext_csd.raw_partition_support = ext_csd[EXT_CSD_PARTITION_SUPPORT];
./mmc/core/mmc.c:473:	card->ext_csd.raw_driver_strength = ext_csd[EXT_CSD_DRIVER_STRENGTH];
./mmc/core/mmc.c:474:	if (card->ext_csd.rev >= 4) {
./mmc/core/mmc.c:477:			card->ext_csd.partition_setting_completed = 1;
./mmc/core/mmc.c:479:			card->ext_csd.partition_setting_completed = 0;
./mmc/core/mmc.c:485:		card->ext_csd.sec_trim_mult =
./mmc/core/mmc.c:487:		card->ext_csd.sec_erase_mult =
./mmc/core/mmc.c:489:		card->ext_csd.sec_feature_support =
./mmc/core/mmc.c:491:		card->ext_csd.trim_timeout = 300 *
./mmc/core/mmc.c:499:		card->ext_csd.boot_ro_lock = ext_csd[EXT_CSD_BOOT_WP];
./mmc/core/mmc.c:500:		card->ext_csd.boot_ro_lockable = true;
./mmc/core/mmc.c:503:		card->ext_csd.raw_pwr_cl_52_195 =
./mmc/core/mmc.c:505:		card->ext_csd.raw_pwr_cl_26_195 =
./mmc/core/mmc.c:507:		card->ext_csd.raw_pwr_cl_52_360 =
./mmc/core/mmc.c:509:		card->ext_csd.raw_pwr_cl_26_360 =
./mmc/core/mmc.c:511:		card->ext_csd.raw_pwr_cl_200_195 =
./mmc/core/mmc.c:513:		card->ext_csd.raw_pwr_cl_200_360 =
./mmc/core/mmc.c:515:		card->ext_csd.raw_pwr_cl_ddr_52_195 =
./mmc/core/mmc.c:517:		card->ext_csd.raw_pwr_cl_ddr_52_360 =
./mmc/core/mmc.c:519:		card->ext_csd.raw_pwr_cl_ddr_200_360 =
./mmc/core/mmc.c:523:	if (card->ext_csd.rev >= 5) {
./mmc/core/mmc.c:525:		if (card->cid.year < 2010)
./mmc/core/mmc.c:526:			card->cid.year += 16;
./mmc/core/mmc.c:531:			card->ext_csd.bkops = 1;
./mmc/core/mmc.c:532:			card->ext_csd.man_bkops_en =
./mmc/core/mmc.c:535:			card->ext_csd.raw_bkops_status =
./mmc/core/mmc.c:537:			if (card->ext_csd.man_bkops_en)
./mmc/core/mmc.c:539:					mmc_hostname(card->host));
./mmc/core/mmc.c:540:			card->ext_csd.auto_bkops_en =
./mmc/core/mmc.c:543:			if (card->ext_csd.auto_bkops_en)
./mmc/core/mmc.c:545:					mmc_hostname(card->host));
./mmc/core/mmc.c:551:			card->ext_csd.hpi = 1;
./mmc/core/mmc.c:553:				card->ext_csd.hpi_cmd =	MMC_STOP_TRANSMISSION;
./mmc/core/mmc.c:555:				card->ext_csd.hpi_cmd = MMC_SEND_STATUS;
./mmc/core/mmc.c:560:			card->ext_csd.out_of_int_time =
./mmc/core/mmc.c:564:		card->ext_csd.rel_param = ext_csd[EXT_CSD_WR_REL_PARAM];
./mmc/core/mmc.c:565:		card->ext_csd.rst_n_function = ext_csd[EXT_CSD_RST_N_FUNCTION];
./mmc/core/mmc.c:570:		card->ext_csd.raw_rpmb_size_mult = ext_csd[EXT_CSD_RPMB_MULT];
./mmc/core/mmc.c:571:		if (ext_csd[EXT_CSD_RPMB_MULT] && mmc_host_cmd23(card->host)) {
./mmc/core/mmc.c:579:	card->ext_csd.raw_erased_mem_count = ext_csd[EXT_CSD_ERASED_MEM_CONT];
./mmc/core/mmc.c:581:		card->erased_byte = 0xFF;
./mmc/core/mmc.c:583:		card->erased_byte = 0x0;
./mmc/core/mmc.c:586:	card->ext_csd.generic_cmd6_time = DEFAULT_CMD6_TIMEOUT_MS;
./mmc/core/mmc.c:587:	if (card->ext_csd.rev >= 6) {
./mmc/core/mmc.c:588:		card->ext_csd.feature_support |= MMC_DISCARD_FEATURE;
./mmc/core/mmc.c:590:		card->ext_csd.generic_cmd6_time = 10 *
./mmc/core/mmc.c:592:		card->ext_csd.power_off_longtime = 10 *
./mmc/core/mmc.c:595:		card->ext_csd.cache_size =
./mmc/core/mmc.c:602:			card->ext_csd.data_sector_size = 4096;
./mmc/core/mmc.c:604:			card->ext_csd.data_sector_size = 512;
./mmc/core/mmc.c:608:			card->ext_csd.data_tag_unit_size =
./mmc/core/mmc.c:610:			(card->ext_csd.data_sector_size);
./mmc/core/mmc.c:612:			card->ext_csd.data_tag_unit_size = 0;
./mmc/core/mmc.c:615:		card->ext_csd.max_packed_writes =
./mmc/core/mmc.c:617:		card->ext_csd.max_packed_reads =
./mmc/core/mmc.c:620:		card->ext_csd.data_sector_size = 512;
./mmc/core/mmc.c:624:	if (card->ext_csd.rev >= 7) {
./mmc/core/mmc.c:625:		memcpy(card->ext_csd.fwrev, &ext_csd[EXT_CSD_FIRMWARE_VERSION],
./mmc/core/mmc.c:627:		card->ext_csd.ffu_capable =
./mmc/core/mmc.c:631:		card->ext_csd.pre_eol_info = ext_csd[EXT_CSD_PRE_EOL_INFO];
./mmc/core/mmc.c:632:		card->ext_csd.device_life_time_est_typ_a =
./mmc/core/mmc.c:634:		card->ext_csd.device_life_time_est_typ_b =
./mmc/core/mmc.c:639:	if (card->ext_csd.rev >= 8) {
./mmc/core/mmc.c:640:		card->ext_csd.cmdq_support = ext_csd[EXT_CSD_CMDQ_SUPPORT] &
./mmc/core/mmc.c:642:		card->ext_csd.cmdq_depth = (ext_csd[EXT_CSD_CMDQ_DEPTH] &
./mmc/core/mmc.c:645:		if (card->ext_csd.cmdq_depth <= 2) {
./mmc/core/mmc.c:646:			card->ext_csd.cmdq_support = false;
./mmc/core/mmc.c:647:			card->ext_csd.cmdq_depth = 0;
./mmc/core/mmc.c:649:		if (card->ext_csd.cmdq_support) {
./mmc/core/mmc.c:651:				 mmc_hostname(card->host),
./mmc/core/mmc.c:652:				 card->ext_csd.cmdq_depth);
./mmc/core/mmc.c:680:		if (card->csd.capacity == (4096 * 512)) {
./mmc/core/mmc.c:682:				mmc_hostname(card->host));
./mmc/core/mmc.c:685:				mmc_hostname(card->host));
./mmc/core/mmc.c:710:	err = !((card->ext_csd.raw_partition_support ==
./mmc/core/mmc.c:712:		(card->ext_csd.raw_erased_mem_count ==
./mmc/core/mmc.c:714:		(card->ext_csd.rev ==
./mmc/core/mmc.c:716:		(card->ext_csd.raw_ext_csd_structure ==
./mmc/core/mmc.c:718:		(card->ext_csd.raw_card_type ==
./mmc/core/mmc.c:720:		(card->ext_csd.raw_s_a_timeout ==
./mmc/core/mmc.c:722:		(card->ext_csd.raw_hc_erase_gap_size ==
./mmc/core/mmc.c:724:		(card->ext_csd.raw_erase_timeout_mult ==
./mmc/core/mmc.c:726:		(card->ext_csd.raw_hc_erase_grp_size ==
./mmc/core/mmc.c:728:		(card->ext_csd.raw_sec_trim_mult ==
./mmc/core/mmc.c:730:		(card->ext_csd.raw_sec_erase_mult ==
./mmc/core/mmc.c:732:		(card->ext_csd.raw_sec_feature_support ==
./mmc/core/mmc.c:734:		(card->ext_csd.raw_trim_mult ==
./mmc/core/mmc.c:736:		(card->ext_csd.raw_sectors[0] ==
./mmc/core/mmc.c:738:		(card->ext_csd.raw_sectors[1] ==
./mmc/core/mmc.c:740:		(card->ext_csd.raw_sectors[2] ==
./mmc/core/mmc.c:742:		(card->ext_csd.raw_sectors[3] ==
./mmc/core/mmc.c:744:		(card->ext_csd.raw_pwr_cl_52_195 ==
./mmc/core/mmc.c:746:		(card->ext_csd.raw_pwr_cl_26_195 ==
./mmc/core/mmc.c:748:		(card->ext_csd.raw_pwr_cl_52_360 ==
./mmc/core/mmc.c:750:		(card->ext_csd.raw_pwr_cl_26_360 ==
./mmc/core/mmc.c:752:		(card->ext_csd.raw_pwr_cl_200_195 ==
./mmc/core/mmc.c:754:		(card->ext_csd.raw_pwr_cl_200_360 ==
./mmc/core/mmc.c:756:		(card->ext_csd.raw_pwr_cl_ddr_52_195 ==
./mmc/core/mmc.c:758:		(card->ext_csd.raw_pwr_cl_ddr_52_360 ==
./mmc/core/mmc.c:760:		(card->ext_csd.raw_pwr_cl_ddr_200_360 ==
./mmc/core/mmc.c:770:MMC_DEV_ATTR(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
./mmc/core/mmc.c:771:	card->raw_cid[2], card->raw_cid[3]);
./mmc/core/mmc.c:772:MMC_DEV_ATTR(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
./mmc/core/mmc.c:773:	card->raw_csd[2], card->raw_csd[3]);
./mmc/core/mmc.c:774:MMC_DEV_ATTR(date, "%02d/%04d\n", card->cid.month, card->cid.year);
./mmc/core/mmc.c:775:MMC_DEV_ATTR(erase_size, "%u\n", card->erase_size << 9);
./mmc/core/mmc.c:776:MMC_DEV_ATTR(preferred_erase_size, "%u\n", card->pref_erase << 9);
./mmc/core/mmc.c:777:MMC_DEV_ATTR(ffu_capable, "%d\n", card->ext_csd.ffu_capable);
./mmc/core/mmc.c:778:MMC_DEV_ATTR(hwrev, "0x%x\n", card->cid.hwrev);
./mmc/core/mmc.c:779:MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
./mmc/core/mmc.c:780:MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
./mmc/core/mmc.c:781:MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
./mmc/core/mmc.c:782:MMC_DEV_ATTR(prv, "0x%x\n", card->cid.prv);
./mmc/core/mmc.c:783:MMC_DEV_ATTR(pre_eol_info, "0x%02x\n", card->ext_csd.pre_eol_info);
./mmc/core/mmc.c:785:	card->ext_csd.device_life_time_est_typ_a,
./mmc/core/mmc.c:786:	card->ext_csd.device_life_time_est_typ_b);
./mmc/core/mmc.c:787:MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
./mmc/core/mmc.c:789:		card->ext_csd.enhanced_area_offset);
./mmc/core/mmc.c:790:MMC_DEV_ATTR(enhanced_area_size, "%u\n", card->ext_csd.enhanced_area_size);
./mmc/core/mmc.c:791:MMC_DEV_ATTR(raw_rpmb_size_mult, "%#x\n", card->ext_csd.raw_rpmb_size_mult);
./mmc/core/mmc.c:792:MMC_DEV_ATTR(rel_sectors, "%#x\n", card->ext_csd.rel_sectors);
./mmc/core/mmc.c:793:MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
./mmc/core/mmc.c:794:MMC_DEV_ATTR(cmdq_en, "%d\n", card->ext_csd.cmdq_en);
./mmc/core/mmc.c:802:	if (card->ext_csd.rev < 7) {
./mmc/core/mmc.c:803:		return sprintf(buf, "0x%x\n", card->cid.fwrev);
./mmc/core/mmc.c:806:			       card->ext_csd.fwrev);
./mmc/core/mmc.c:817:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:819:	if (card->csd.dsr_imp && host->dsr_req)
./mmc/core/mmc.c:868:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:869:	struct mmc_ext_csd *ext_csd = &card->ext_csd;
./mmc/core/mmc.c:922:				 card->ext_csd.generic_cmd6_time);
./mmc/core/mmc.c:930:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:943:	ddr = card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52;
./mmc/core/mmc.c:967:	     max_dtr > card->ext_csd.hs200_max_dtr)
./mmc/core/mmc.c:968:		max_dtr = card->ext_csd.hs200_max_dtr;
./mmc/core/mmc.c:969:	else if (mmc_card_hs(card) && max_dtr > card->ext_csd.hs_max_dtr)
./mmc/core/mmc.c:970:		max_dtr = card->ext_csd.hs_max_dtr;
./mmc/core/mmc.c:971:	else if (max_dtr > card->csd.max_dtr)
./mmc/core/mmc.c:972:		max_dtr = card->csd.max_dtr;
./mmc/core/mmc.c:977:	mmc_set_clock(card->host, max_dtr);
./mmc/core/mmc.c:995:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:1022:				 card->ext_csd.generic_cmd6_time);
./mmc/core/mmc.c:1060:			   card->ext_csd.generic_cmd6_time, MMC_TIMING_MMC_HS,
./mmc/core/mmc.c:1064:			mmc_hostname(card->host), err);
./mmc/core/mmc.c:1074:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:1078:	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52))
./mmc/core/mmc.c:1091:			   card->ext_csd.generic_cmd6_time,
./mmc/core/mmc.c:1125:	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_2V) {
./mmc/core/mmc.c:1131:	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_8V &&
./mmc/core/mmc.c:1144:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:1152:	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
./mmc/core/mmc.c:1160:			   card->ext_csd.generic_cmd6_time, 0,
./mmc/core/mmc.c:1169:	mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
./mmc/core/mmc.c:1172:	max_dtr = card->ext_csd.hs_max_dtr;
./mmc/core/mmc.c:1183:			 card->ext_csd.generic_cmd6_time);
./mmc/core/mmc.c:1192:	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
./mmc/core/mmc.c:1195:			   card->ext_csd.generic_cmd6_time, 0,
./mmc/core/mmc.c:1214:	pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
./mmc/core/mmc.c:1226:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:1232:	max_dtr = card->ext_csd.hs_max_dtr;
./mmc/core/mmc.c:1238:			   val, card->ext_csd.generic_cmd6_time, 0,
./mmc/core/mmc.c:1251:			   EXT_CSD_BUS_WIDTH_8, card->ext_csd.generic_cmd6_time,
./mmc/core/mmc.c:1264:	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
./mmc/core/mmc.c:1266:			   val, card->ext_csd.generic_cmd6_time, 0,
./mmc/core/mmc.c:1287:	pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
./mmc/core/mmc.c:1296:	card_drv_type = card->ext_csd.raw_driver_strength |
./mmc/core/mmc.c:1300:						   card->ext_csd.hs200_max_dtr,
./mmc/core/mmc.c:1303:	card->drive_strength = drive_strength;
./mmc/core/mmc.c:1306:		mmc_set_driver_type(card->host, drv_type);
./mmc/core/mmc.c:1311:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:1320:	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400_1_2V)
./mmc/core/mmc.c:1323:	if (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400_1_8V)
./mmc/core/mmc.c:1337:			   card->ext_csd.generic_cmd6_time, 0,
./mmc/core/mmc.c:1350:	mmc_set_clock(host, card->ext_csd.hs_max_dtr);
./mmc/core/mmc.c:1357:			 card->ext_csd.generic_cmd6_time);
./mmc/core/mmc.c:1368:	      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
./mmc/core/mmc.c:1371:			   card->ext_csd.generic_cmd6_time, 0,
./mmc/core/mmc.c:1394:	pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
./mmc/core/mmc.c:1408:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:1414:	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_2V)
./mmc/core/mmc.c:1417:	if (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_8V)
./mmc/core/mmc.c:1433:		      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
./mmc/core/mmc.c:1436:				   card->ext_csd.generic_cmd6_time, 0,
./mmc/core/mmc.c:1463:		pr_err("%s: %s failed, error %d\n", mmc_hostname(card->host),
./mmc/core/mmc.c:1479:	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400ES)
./mmc/core/mmc.c:1481:	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
./mmc/core/mmc.c:1483:	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)
./mmc/core/mmc.c:1504:	struct mmc_host *host = card->host;
./mmc/core/mmc.c:1510:	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
./mmc/core/mmc.c:1569:		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0) {
./mmc/core/mmc.c:1585:		card->ocr = ocr;
./mmc/core/mmc.c:1586:		card->type = MMC_TYPE_MMC;
./mmc/core/mmc.c:1587:		card->rca = 1;
./mmc/core/mmc.c:1588:		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
./mmc/core/mmc.c:1612:		err = mmc_send_csd(card, card->raw_csd);
./mmc/core/mmc.c:1628:	if (card->csd.dsr_imp && host->dsr_req)
./mmc/core/mmc.c:1660:	if (card->ext_csd.rev >= 3) {
./mmc/core/mmc.c:1663:				 card->ext_csd.generic_cmd6_time);
./mmc/core/mmc.c:1675:			card->ext_csd.enhanced_area_offset = -EINVAL;
./mmc/core/mmc.c:1676:			card->ext_csd.enhanced_area_size = -EINVAL;
./mmc/core/mmc.c:1678:			card->ext_csd.erase_group_def = 1;
./mmc/core/mmc.c:1691:	if (card->ext_csd.part_config & EXT_CSD_PART_CONFIG_ACC_MASK) {
./mmc/core/mmc.c:1692:		card->ext_csd.part_config &= ~EXT_CSD_PART_CONFIG_ACC_MASK;
./mmc/core/mmc.c:1694:				 card->ext_csd.part_config,
./mmc/core/mmc.c:1695:				 card->ext_csd.part_time);
./mmc/core/mmc.c:1703:	if (card->ext_csd.rev >= 6) {
./mmc/core/mmc.c:1707:				 card->ext_csd.generic_cmd6_time);
./mmc/core/mmc.c:1716:			card->ext_csd.power_off_notification = EXT_CSD_POWER_ON;
./mmc/core/mmc.c:1752:	if (card->ext_csd.hpi) {
./mmc/core/mmc.c:1755:				card->ext_csd.generic_cmd6_time);
./mmc/core/mmc.c:1760:				mmc_hostname(card->host));
./mmc/core/mmc.c:1763:			card->ext_csd.hpi_en = 1;
./mmc/core/mmc.c:1771:	    card->ext_csd.cache_size > 0) {
./mmc/core/mmc.c:1774:				card->ext_csd.generic_cmd6_time);
./mmc/core/mmc.c:1783:				mmc_hostname(card->host), err);
./mmc/core/mmc.c:1784:			card->ext_csd.cache_ctrl = 0;
./mmc/core/mmc.c:1787:			card->ext_csd.cache_ctrl = 1;
./mmc/core/mmc.c:1796:	card->reenable_cmdq = card->ext_csd.cmdq_en;
./mmc/core/mmc.c:1812:	return (card && card->ext_csd.rev >= 3);
./mmc/core/mmc.c:1819:	unsigned int timeout_ms = DIV_ROUND_UP(card->ext_csd.sa_timeout, 10000);
./mmc/core/mmc.c:1830:	cmd.arg = card->rca << 16;
./mmc/core/mmc.c:1868:		(card->ext_csd.power_off_notification == EXT_CSD_POWER_ON);
./mmc/core/mmc.c:1873:	unsigned int timeout = card->ext_csd.generic_cmd6_time;
./mmc/core/mmc.c:1878:		timeout = card->ext_csd.power_off_longtime;
./mmc/core/mmc.c:1885:		       mmc_hostname(card->host), timeout);
./mmc/core/mmc.c:1888:	card->ext_csd.power_off_notification = EXT_CSD_NO_POWER_NOTIFICATION;
./mmc/core/mmc.c:1983:		pm_runtime_disable(&host->card->dev);
./mmc/core/mmc.c:1984:		pm_runtime_set_suspended(&host->card->dev);
./mmc/core/mmc.c:2003:	mmc_power_up(host, host->card->ocr);
./mmc/core/mmc.c:2004:	err = mmc_init_card(host, host->card->ocr, host->card);
./mmc/core/mmc.c:2038:	pm_runtime_enable(&host->card->dev);
./mmc/core/mmc.c:2079:	rst_n_function = card->ext_csd.rst_n_function;
./mmc/core/mmc.c:2104:		mmc_power_cycle(host, card->ocr);
./mmc/core/mmc.c:2107:	return mmc_init_card(host, card->ocr, card);
./mmc/core/mmc_ops.c:64:	if (!mmc_host_is_spi(card->host))
./mmc/core/mmc_ops.c:65:		cmd.arg = card->rca << 16;
./mmc/core/mmc_ops.c:68:	err = mmc_wait_for_cmd(card->host, &cmd, retries);
./mmc/core/mmc_ops.c:95:		cmd.arg = card->rca << 16;
./mmc/core/mmc_ops.c:108:	return _mmc_select_card(card->host, card);
./mmc/core/mmc_ops.c:216:	cmd.arg = card->rca << 16;
./mmc/core/mmc_ops.c:219:	return mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
./mmc/core/mmc_ops.c:304:	ret = mmc_send_cxd_data(card, card->host, MMC_SEND_CSD, csd_tmp, 16);
./mmc/core/mmc_ops.c:318:	if (mmc_host_is_spi(card->host))
./mmc/core/mmc_ops.c:321:	return mmc_send_cxd_native(card->host, card->rca << 16,	csd,
./mmc/core/mmc_ops.c:373:	err = mmc_send_cxd_data(card, card->host, MMC_SEND_EXT_CSD, ext_csd,
./mmc/core/mmc_ops.c:441:	return mmc_switch_status_error(card->host, status);
./mmc/core/mmc_ops.c:452:	struct mmc_host *host = card->host;
./mmc/core/mmc_ops.c:527:	struct mmc_host *host = card->host;
./mmc/core/mmc_ops.c:795:	mmc_send_bus_test(card, card->host, MMC_BUS_TEST_W, width);
./mmc/core/mmc_ops.c:796:	return mmc_send_bus_test(card, card->host, MMC_BUS_TEST_R, width);
./mmc/core/mmc_ops.c:805:	if (!card->ext_csd.hpi) {
./mmc/core/mmc_ops.c:807:			mmc_hostname(card->host));
./mmc/core/mmc_ops.c:811:	opcode = card->ext_csd.hpi_cmd;
./mmc/core/mmc_ops.c:818:	cmd.arg = card->rca << 16 | 1;
./mmc/core/mmc_ops.c:820:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./mmc/core/mmc_ops.c:823:			"HPI command response %#x\n", mmc_hostname(card->host),
./mmc/core/mmc_ops.c:846:	if (!card->ext_csd.hpi_en) {
./mmc/core/mmc_ops.c:847:		pr_info("%s: HPI enable bit unset\n", mmc_hostname(card->host));
./mmc/core/mmc_ops.c:851:	mmc_claim_host(card->host);
./mmc/core/mmc_ops.c:854:		pr_err("%s: Get card status fail\n", mmc_hostname(card->host));
./mmc/core/mmc_ops.c:873:			mmc_hostname(card->host), R1_CURRENT_STATE(status));
./mmc/core/mmc_ops.c:882:	prg_wait = jiffies + msecs_to_jiffies(card->ext_csd.out_of_int_time);
./mmc/core/mmc_ops.c:893:	mmc_release_host(card->host);
./mmc/core/mmc_ops.c:899:	return (card && card->csd.mmca_vsn > CSD_SPEC_VER_3);
./mmc/core/mmc_ops.c:923:		mmc_retune_release(card->host);
./mmc/core/mmc_ops.c:935:	mmc_claim_host(card->host);
./mmc/core/mmc_ops.c:937:	mmc_release_host(card->host);
./mmc/core/mmc_ops.c:941:	card->ext_csd.raw_bkops_status = ext_csd[EXT_CSD_BKOPS_STATUS];
./mmc/core/mmc_ops.c:942:	card->ext_csd.raw_exception_status = ext_csd[EXT_CSD_EXP_EVENTS_STATUS];
./mmc/core/mmc_ops.c:963:	if (!card->ext_csd.man_bkops_en || mmc_card_doing_bkops(card))
./mmc/core/mmc_ops.c:969:		       mmc_hostname(card->host), err);
./mmc/core/mmc_ops.c:973:	if (!card->ext_csd.raw_bkops_status)
./mmc/core/mmc_ops.c:976:	if (card->ext_csd.raw_bkops_status < EXT_CSD_BKOPS_LEVEL_2 &&
./mmc/core/mmc_ops.c:980:	mmc_claim_host(card->host);
./mmc/core/mmc_ops.c:981:	if (card->ext_csd.raw_bkops_status >= EXT_CSD_BKOPS_LEVEL_2) {
./mmc/core/mmc_ops.c:989:	mmc_retune_hold(card->host);
./mmc/core/mmc_ops.c:996:			mmc_hostname(card->host), err);
./mmc/core/mmc_ops.c:997:		mmc_retune_release(card->host);
./mmc/core/mmc_ops.c:1009:		mmc_retune_release(card->host);
./mmc/core/mmc_ops.c:1011:	mmc_release_host(card->host);
./mmc/core/mmc_ops.c:1022:			(card->ext_csd.cache_size > 0) &&
./mmc/core/mmc_ops.c:1023:			(card->ext_csd.cache_ctrl & 1)) {
./mmc/core/mmc_ops.c:1028:					mmc_hostname(card->host), err);
./mmc/core/mmc_ops.c:1040:	if (!card->ext_csd.cmdq_support)
./mmc/core/mmc_ops.c:1044:			 val, card->ext_csd.generic_cmd6_time);
./mmc/core/mmc_ops.c:1046:		card->ext_csd.cmdq_en = enable;
./mmc/core/sdio.c:78:	if (!(card->quirks & MMC_QUIRK_NONSTD_SDIO)) {
./mmc/core/sdio.c:87:		func->vendor = func->card->cis.vendor;
./mmc/core/sdio.c:88:		func->device = func->card->cis.device;
./mmc/core/sdio.c:89:		func->max_blksize = func->card->cis.blksize;
./mmc/core/sdio.c:92:	card->sdio_func[fn - 1] = func;
./mmc/core/sdio.c:121:			mmc_hostname(card->host), cccr_vsn);
./mmc/core/sdio.c:125:	card->cccr.sdio_vsn = (data & 0xf0) >> 4;
./mmc/core/sdio.c:132:		card->cccr.multi_block = 1;
./mmc/core/sdio.c:134:		card->cccr.low_speed = 1;
./mmc/core/sdio.c:136:		card->cccr.wide_bus = 1;
./mmc/core/sdio.c:144:			card->cccr.high_power = 1;
./mmc/core/sdio.c:152:		card->scr.sda_spec3 = 0;
./mmc/core/sdio.c:153:		card->sw_caps.sd3_bus_mode = 0;
./mmc/core/sdio.c:154:		card->sw_caps.sd3_drv_type = 0;
./mmc/core/sdio.c:156:			card->scr.sda_spec3 = 1;
./mmc/core/sdio.c:162:			if (mmc_host_uhs(card->host)) {
./mmc/core/sdio.c:164:					card->sw_caps.sd3_bus_mode
./mmc/core/sdio.c:168:					card->sw_caps.sd3_bus_mode
./mmc/core/sdio.c:172:					card->sw_caps.sd3_bus_mode
./mmc/core/sdio.c:182:				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_A;
./mmc/core/sdio.c:184:				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_C;
./mmc/core/sdio.c:186:				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_D;
./mmc/core/sdio.c:190:		if (!card->sw_caps.sd3_bus_mode) {
./mmc/core/sdio.c:192:				card->cccr.high_speed = 1;
./mmc/core/sdio.c:193:				card->sw_caps.hs_max_dtr = 50000000;
./mmc/core/sdio.c:195:				card->cccr.high_speed = 0;
./mmc/core/sdio.c:196:				card->sw_caps.hs_max_dtr = 25000000;
./mmc/core/sdio.c:210:	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
./mmc/core/sdio.c:213:	if (card->cccr.low_speed && !card->cccr.wide_bus)
./mmc/core/sdio.c:222:			mmc_hostname(card->host), ctrl);
./mmc/core/sdio.c:267:	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
./mmc/core/sdio.c:270:	if (card->cccr.low_speed && !card->cccr.wide_bus)
./mmc/core/sdio.c:287:	mmc_set_bus_width(card->host, MMC_BUS_WIDTH_1);
./mmc/core/sdio.c:297:	if (card->type == MMC_TYPE_SDIO)
./mmc/core/sdio.c:299:	else if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
./mmc/core/sdio.c:300:		 (card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
./mmc/core/sdio.c:311:		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
./mmc/core/sdio.c:327:	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
./mmc/core/sdio.c:330:	if (!card->cccr.high_speed)
./mmc/core/sdio.c:357:	if (ret <= 0 || card->type == MMC_TYPE_SDIO)
./mmc/core/sdio.c:380:		max_dtr = card->cis.max_dtr;
./mmc/core/sdio.c:383:	if (card->type == MMC_TYPE_SD_COMBO)
./mmc/core/sdio.c:411:	card->drive_strength = 0;
./mmc/core/sdio.c:413:	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
./mmc/core/sdio.c:416:						   card->sw_caps.uhs_max_dtr,
./mmc/core/sdio.c:434:		card->drive_strength = drive_strength;
./mmc/core/sdio.c:438:		mmc_set_driver_type(card->host, drv_type);
./mmc/core/sdio.c:452:	if (!mmc_host_uhs(card->host))
./mmc/core/sdio.c:457:	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
./mmc/core/sdio.c:458:	    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {
./mmc/core/sdio.c:461:			card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
./mmc/core/sdio.c:462:			card->sd_bus_speed = UHS_SDR104_BUS_SPEED;
./mmc/core/sdio.c:463:	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
./mmc/core/sdio.c:464:		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {
./mmc/core/sdio.c:467:			card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
./mmc/core/sdio.c:468:			card->sd_bus_speed = UHS_DDR50_BUS_SPEED;
./mmc/core/sdio.c:469:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./mmc/core/sdio.c:470:		    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &
./mmc/core/sdio.c:474:			card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
./mmc/core/sdio.c:475:			card->sd_bus_speed = UHS_SDR50_BUS_SPEED;
./mmc/core/sdio.c:476:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./mmc/core/sdio.c:478:		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {
./mmc/core/sdio.c:481:			card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
./mmc/core/sdio.c:482:			card->sd_bus_speed = UHS_SDR25_BUS_SPEED;
./mmc/core/sdio.c:483:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./mmc/core/sdio.c:485:		    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &
./mmc/core/sdio.c:489:			card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
./mmc/core/sdio.c:490:			card->sd_bus_speed = UHS_SDR12_BUS_SPEED;
./mmc/core/sdio.c:504:		mmc_set_timing(card->host, timing);
./mmc/core/sdio.c:505:		mmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);
./mmc/core/sdio.c:518:	if (!card->scr.sda_spec3)
./mmc/core/sdio.c:524:	if (card->host->caps & MMC_CAP_4_BIT_DATA)
./mmc/core/sdio.c:539:	if (!mmc_host_is_spi(card->host) &&
./mmc/core/sdio.c:540:	    ((card->host->ios.timing == MMC_TIMING_UHS_SDR50) ||
./mmc/core/sdio.c:541:	      (card->host->ios.timing == MMC_TIMING_UHS_SDR104)))
./mmc/core/sdio.c:611:	    mmc_sd_get_cid(host, ocr & rocr, card->raw_cid, NULL) == 0) {
./mmc/core/sdio.c:612:		card->type = MMC_TYPE_SD_COMBO;
./mmc/core/sdio.c:614:		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||
./mmc/core/sdio.c:615:		    memcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {
./mmc/core/sdio.c:620:		card->type = MMC_TYPE_SDIO;
./mmc/core/sdio.c:622:		if (oldcard && oldcard->type != MMC_TYPE_SDIO) {
./mmc/core/sdio.c:660:		err = mmc_send_relative_addr(host, &card->rca);
./mmc/core/sdio.c:670:			oldcard->rca = card->rca;
./mmc/core/sdio.c:676:	if (!oldcard && card->type == MMC_TYPE_SD_COMBO) {
./mmc/core/sdio.c:693:	if (card->quirks & MMC_QUIRK_NONSTD_SDIO) {
./mmc/core/sdio.c:700:		mmc_set_clock(host, card->cis.max_dtr);
./mmc/core/sdio.c:702:		if (card->cccr.high_speed) {
./mmc/core/sdio.c:703:			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
./mmc/core/sdio.c:733:		int same = (card->cis.vendor == oldcard->cis.vendor &&
./mmc/core/sdio.c:734:			    card->cis.device == oldcard->cis.device);
./mmc/core/sdio.c:741:	card->ocr = ocr_card;
./mmc/core/sdio.c:744:	if (card->type == MMC_TYPE_SD_COMBO) {
./mmc/core/sdio.c:752:			card->type = MMC_TYPE_SDIO;
./mmc/core/sdio.c:754:			card->dev.type = &sd_type;
./mmc/core/sdio.c:766:	if ((ocr & R4_18V_PRESENT) && card->sw_caps.sd3_bus_mode) {
./mmc/core/sdio.c:776:			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
./mmc/core/sdio.c:812:	for (i = 0;i < host->card->sdio_funcs;i++) {
./mmc/core/sdio.c:813:		if (host->card->sdio_func[i]) {
./mmc/core/sdio.c:814:			sdio_remove_func(host->card->sdio_func[i]);
./mmc/core/sdio.c:815:			host->card->sdio_func[i] = NULL;
./mmc/core/sdio.c:840:		err = pm_runtime_get_sync(&host->card->dev);
./mmc/core/sdio.c:842:			pm_runtime_put_noidle(&host->card->dev);
./mmc/core/sdio.c:868:		pm_runtime_put_sync(&host->card->dev);
./mmc/core/sdio.c:890:	for (i = 0; i < host->card->sdio_funcs; i++) {
./mmc/core/sdio.c:891:		struct sdio_func *func = host->card->sdio_func[i];
./mmc/core/sdio.c:936:		mmc_power_up(host, host->card->ocr);
./mmc/core/sdio.c:944:			pm_runtime_disable(&host->card->dev);
./mmc/core/sdio.c:945:			pm_runtime_set_active(&host->card->dev);
./mmc/core/sdio.c:946:			pm_runtime_enable(&host->card->dev);
./mmc/core/sdio.c:954:		mmc_send_if_cond(host, host->card->ocr);
./mmc/core/sdio.c:957:			err = mmc_sdio_init_card(host, host->card->ocr,
./mmc/core/sdio.c:1003:	mmc_send_if_cond(host, host->card->ocr);
./mmc/core/sdio.c:1009:	ret = mmc_sdio_init_card(host, host->card->ocr, host->card,
./mmc/core/sdio.c:1036:	mmc_power_up(host, host->card->ocr);
./mmc/core/sdio.c:1045:	mmc_power_cycle(host, host->card->ocr);
./mmc/core/sdio.c:1110:		pm_runtime_get_noresume(&card->dev);
./mmc/core/sdio.c:1115:		err = pm_runtime_set_active(&card->dev);
./mmc/core/sdio.c:1122:		pm_runtime_enable(&card->dev);
./mmc/core/sdio.c:1130:	card->sdio_funcs = 0;
./mmc/core/sdio.c:1135:	for (i = 0; i < funcs; i++, card->sdio_funcs++) {
./mmc/core/sdio.c:1144:			pm_runtime_enable(&card->sdio_func[i]->dev);
./mmc/core/sdio.c:1159:		err = sdio_add_func(host->card->sdio_func[i]);
./mmc/core/sdio.c:1165:		pm_runtime_put(&card->dev);
./mmc/core/core.c:737:		mult <<= card->csd.r2w_factor;
./mmc/core/core.c:739:	data->timeout_ns = card->csd.taac_ns * mult;
./mmc/core/core.c:740:	data->timeout_clks = card->csd.taac_clks * mult;
./mmc/core/core.c:749:		if (card->host->ios.clock)
./mmc/core/core.c:751:				(card->host->ios.clock / 1000);
./mmc/core/core.c:796:	if (mmc_host_is_spi(card->host)) {
./mmc/core/core.c:918:	pm_runtime_get_sync(&card->dev);
./mmc/core/core.c:919:	mmc_claim_host(card->host);
./mmc/core/core.c:929:	mmc_release_host(card->host);
./mmc/core/core.c:930:	pm_runtime_mark_last_busy(&card->dev);
./mmc/core/core.c:931:	pm_runtime_put_autosuspend(&card->dev);
./mmc/core/core.c:978:	struct mmc_host *host = card->host;
./mmc/core/core.c:1586:	struct mmc_host *host = card->host;
./mmc/core/core.c:1810:	if (is_power_of_2(card->erase_size))
./mmc/core/core.c:1811:		card->erase_shift = ffs(card->erase_size) - 1;
./mmc/core/core.c:1813:		card->erase_shift = 0;
./mmc/core/core.c:1830:	if (mmc_card_sd(card) && card->ssr.au) {
./mmc/core/core.c:1831:		card->pref_erase = card->ssr.au;
./mmc/core/core.c:1832:		card->erase_shift = ffs(card->ssr.au) - 1;
./mmc/core/core.c:1833:	} else if (card->erase_size) {
./mmc/core/core.c:1834:		sz = (card->csd.capacity << (card->csd.read_blkbits - 9)) >> 11;
./mmc/core/core.c:1836:			card->pref_erase = 512 * 1024 / 512;
./mmc/core/core.c:1838:			card->pref_erase = 1024 * 1024 / 512;
./mmc/core/core.c:1840:			card->pref_erase = 2 * 1024 * 1024 / 512;
./mmc/core/core.c:1842:			card->pref_erase = 4 * 1024 * 1024 / 512;
./mmc/core/core.c:1843:		if (card->pref_erase < card->erase_size)
./mmc/core/core.c:1844:			card->pref_erase = card->erase_size;
./mmc/core/core.c:1846:			sz = card->pref_erase % card->erase_size;
./mmc/core/core.c:1848:				card->pref_erase += card->erase_size - sz;
./mmc/core/core.c:1851:		card->pref_erase = 0;
./mmc/core/core.c:1860:	    (arg == MMC_TRIM_ARG && card->ext_csd.rev >= 6)) {
./mmc/core/core.c:1861:		erase_timeout = card->ext_csd.trim_timeout;
./mmc/core/core.c:1862:	} else if (card->ext_csd.erase_group_def & 1) {
./mmc/core/core.c:1865:			erase_timeout = card->ext_csd.trim_timeout;
./mmc/core/core.c:1867:			erase_timeout = card->ext_csd.hc_erase_timeout;
./mmc/core/core.c:1870:		unsigned int mult = (10 << card->csd.r2w_factor);
./mmc/core/core.c:1871:		unsigned int timeout_clks = card->csd.taac_clks * mult;
./mmc/core/core.c:1875:		if (card->csd.taac_ns < 1000000)
./mmc/core/core.c:1876:			timeout_us = (card->csd.taac_ns * mult) / 1000;
./mmc/core/core.c:1878:			timeout_us = (card->csd.taac_ns / 1000) * mult;
./mmc/core/core.c:1886:			      (card->host->ios.clock / 1000);
./mmc/core/core.c:1901:			erase_timeout *= card->ext_csd.sec_erase_mult;
./mmc/core/core.c:1903:			erase_timeout *= card->ext_csd.sec_trim_mult;
./mmc/core/core.c:1912:	if (mmc_host_is_spi(card->host) && erase_timeout < 1000)
./mmc/core/core.c:1924:	if (card->ssr.erase_timeout) {
./mmc/core/core.c:1926:		erase_timeout = card->ssr.erase_timeout * qty +
./mmc/core/core.c:1927:				card->ssr.erase_offset;
./mmc/core/core.c:1962:	mmc_retune_hold(card->host);
./mmc/core/core.c:1980:	if (card->erase_shift)
./mmc/core/core.c:1981:		qty += ((to >> card->erase_shift) -
./mmc/core/core.c:1982:			(from >> card->erase_shift)) + 1;
./mmc/core/core.c:1986:		qty += ((to / card->erase_size) -
./mmc/core/core.c:1987:			(from / card->erase_size)) + 1;
./mmc/core/core.c:2000:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./mmc/core/core.c:2015:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./mmc/core/core.c:2033:	if (card->host->max_busy_timeout &&
./mmc/core/core.c:2034:	    busy_timeout > card->host->max_busy_timeout) {
./mmc/core/core.c:2042:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./mmc/core/core.c:2050:	if (mmc_host_is_spi(card->host))
./mmc/core/core.c:2057:	if ((card->host->caps & MMC_CAP_WAIT_WHILE_BUSY) && use_r1b_resp)
./mmc/core/core.c:2064:		cmd.arg = card->rca << 16;
./mmc/core/core.c:2067:		err = mmc_wait_for_cmd(card->host, &cmd, 0);
./mmc/core/core.c:2080:				mmc_hostname(card->host), __func__);
./mmc/core/core.c:2088:	mmc_retune_release(card->host);
./mmc/core/core.c:2100:	 * When the 'card->erase_size' is power of 2, we can use round_up/down()
./mmc/core/core.c:2103:	if (is_power_of_2(card->erase_size)) {
./mmc/core/core.c:2106:		from_new = round_up(temp, card->erase_size);
./mmc/core/core.c:2114:		nr_new = round_down(nr_new, card->erase_size);
./mmc/core/core.c:2116:		rem = from_new % card->erase_size;
./mmc/core/core.c:2118:			rem = card->erase_size - rem;
./mmc/core/core.c:2126:		rem = nr_new % card->erase_size;
./mmc/core/core.c:2155:	if (!(card->host->caps & MMC_CAP_ERASE) ||
./mmc/core/core.c:2156:	    !(card->csd.cmdclass & CCC_ERASE))
./mmc/core/core.c:2159:	if (!card->erase_size)
./mmc/core/core.c:2166:	    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN))
./mmc/core/core.c:2170:	    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN))
./mmc/core/core.c:2174:		if (from % card->erase_size || nr % card->erase_size)
./mmc/core/core.c:2196:	 * identified by the card->eg_boundary flag.
./mmc/core/core.c:2198:	rem = card->erase_size - (from % card->erase_size);
./mmc/core/core.c:2199:	if ((arg & MMC_TRIM_ARGS) && (card->eg_boundary) && (nr > rem)) {
./mmc/core/core.c:2212:	if ((card->host->caps & MMC_CAP_ERASE) &&
./mmc/core/core.c:2213:	    (card->csd.cmdclass & CCC_ERASE) && card->erase_size)
./mmc/core/core.c:2221:	if ((card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN) &&
./mmc/core/core.c:2222:	    (!(card->quirks & MMC_QUIRK_TRIM_BROKEN)))
./mmc/core/core.c:2234:	if (card->ext_csd.feature_support & MMC_DISCARD_FEATURE)
./mmc/core/core.c:2244:	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_SANITIZE)
./mmc/core/core.c:2252:	if ((card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN) &&
./mmc/core/core.c:2253:	    !(card->quirks & MMC_QUIRK_SEC_ERASE_TRIM_BROKEN))
./mmc/core/core.c:2262:	if (!card->erase_size)
./mmc/core/core.c:2264:	if (from % card->erase_size || nr % card->erase_size)
./mmc/core/core.c:2273:	struct mmc_host *host = card->host;
./mmc/core/core.c:2279:	if (card->erase_shift) {
./mmc/core/core.c:2280:		max_qty = UINT_MAX >> card->erase_shift;
./mmc/core/core.c:2281:		min_qty = card->pref_erase >> card->erase_shift;
./mmc/core/core.c:2284:		min_qty = card->pref_erase;
./mmc/core/core.c:2286:		max_qty = UINT_MAX / card->erase_size;
./mmc/core/core.c:2287:		min_qty = card->pref_erase / card->erase_size;
./mmc/core/core.c:2296:	 * Here we set 'card->pref_erase' as the minimal discard sectors no
./mmc/core/core.c:2333:		card->eg_boundary = 1;
./mmc/core/core.c:2338:	if (card->erase_shift)
./mmc/core/core.c:2339:		max_discard = qty << card->erase_shift;
./mmc/core/core.c:2343:		max_discard = qty * card->erase_size;
./mmc/core/core.c:2350:	struct mmc_host *host = card->host;
./mmc/core/core.c:2358:	if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))
./mmc/core/core.c:2359:		return card->pref_erase;
./mmc/core/core.c:2366:	} else if (max_discard < card->erase_size) {
./mmc/core/core.c:2393:	return mmc_wait_for_cmd(card->host, &cmd, 5);
./mmc/core/core.c:2407:	return mmc_wait_for_cmd(card->host, &cmd, 5);
./mmc/core/core.c:2714:	mmc_power_up(host, host->card->ocr);
./mmc/core/sdio_bus.c:151:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {
./mmc/core/sdio_bus.c:172:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
./mmc/core/sdio_bus.c:185:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
./mmc/core/sdio_bus.c:199:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
./mmc/core/sdio_bus.c:203:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
./mmc/core/sdio_bus.c:299:	func->dev.parent = &card->dev;
./mmc/core/sdio_bus.c:309:	struct mmc_host *host = func->card->host;
./mmc/core/sdio_bus.c:320:	struct mmc_host *host = func->card->host;
./mmc/core/debugfs.c:286:	struct mmc_host	*host = card->host;
./mmc/core/debugfs.c:301:	card->debugfs_root = root;
./mmc/core/debugfs.c:303:	if (!debugfs_create_x32("state", S_IRUSR, root, &card->state))
./mmc/core/debugfs.c:310:	card->debugfs_root = NULL;
./mmc/core/debugfs.c:311:	dev_err(&card->dev, "failed to initialize debugfs\n");
./mmc/core/debugfs.c:316:	debugfs_remove_recursive(card->debugfs_root);
./mmc/core/debugfs.c:317:	card->debugfs_root = NULL;
./mmc/core/slot-gpio.c:2: * Generic GPIO card-detect helper
./mmc/core/slot-gpio.c:160: * the card-detect GPIO.
./mmc/core/slot-gpio.c:173: * mmc_gpio_request_cd - request a gpio for card-detection
./mmc/core/slot-gpio.c:217: * mmc_gpiod_request_cd - request a gpio descriptor for card-detection
./mmc/core/sdio_io.c:34:	mmc_claim_host(func->card->host);
./mmc/core/sdio_io.c:50:	mmc_release_host(func->card->host);
./mmc/core/sdio_io.c:165:	if (blksz > func->card->host->max_blk_size)
./mmc/core/sdio_io.c:169:		blksz = min(func->max_blksize, func->card->host->max_blk_size);
./mmc/core/sdio_io.c:193:	unsigned mval =	func->card->host->max_blk_size;
./mmc/core/sdio_io.c:242:	if (func->card->cccr.multi_block) {
./mmc/core/sdio_io.c:316:	if (func->card->cccr.multi_block && (size > sdio_max_byte_size(func))) {
./mmc/core/sdio_io.c:319:		max_blocks = min(func->card->host->max_blk_count, 511u);
./mmc/core/sdio_io.c:695:	return func->card->host->pm_caps;
./mmc/core/sdio_io.c:718:	host = func->card->host;
./mmc/core/quirks.h:146:		     f->manfid == card->cid.manfid) &&
./mmc/core/quirks.h:148:		     f->oemid == card->cid.oemid) &&
./mmc/core/quirks.h:150:		     !strncmp(f->name, card->cid.prod_name,
./mmc/core/quirks.h:151:			      sizeof(card->cid.prod_name))) &&
./mmc/core/quirks.h:152:		    (f->cis_vendor == card->cis.vendor ||
./mmc/core/quirks.h:154:		    (f->cis_device == card->cis.device ||
./mmc/core/quirks.h:157:		     f->ext_csd_rev == card->ext_csd.rev) &&
./mmc/core/quirks.h:159:			dev_dbg(&card->dev, "calling %pf\n", f->vendor_fixup);
./mmc/core/mmc_test.c:194:	       (mmc_card_sd(card) && card->scr.cmds & SD_SCR_CMD23_SUPPORT);
./mmc/core/mmc_test.c:202:	if (!mrq->sbc || !mmc_host_cmd23(card->host) ||
./mmc/core/mmc_test.c:204:	    (card->quirks & MMC_QUIRK_BLK_NO_CMD23)) {
./mmc/core/mmc_test.c:276:		cmd.arg = test->card->rca << 16;
./mmc/core/mmc_test.c:279:		ret = mmc_wait_for_cmd(test->card->host, &cmd, 0);
./mmc/core/mmc_test.c:285:			if (test->card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
./mmc/core/mmc_test.c:287:					mmc_hostname(test->card->host));
./mmc/core/mmc_test.c:315:	mmc_wait_for_req(test->card->host, &mrq);
./mmc/core/mmc_test.c:582:			 mmc_hostname(test->card->host), sectors, sectors >> 1,
./mmc/core/mmc_test.c:609:			 mmc_hostname(test->card->host), count, sectors, count,
./mmc/core/mmc_test.c:624:		return card->ext_csd.sectors;
./mmc/core/mmc_test.c:626:		return card->csd.capacity << (card->csd.read_blkbits - 9);
./mmc/core/mmc_test.c:709:		mrq->cmd->arg = test->card->rca << 16;
./mmc/core/mmc_test.c:867:		done_areq = mmc_start_areq(test->card->host, cur_areq, &status);
./mmc/core/mmc_test.c:882:	done_areq = mmc_start_areq(test->card->host, NULL, &status);
./mmc/core/mmc_test.c:911:	mmc_wait_for_req(test->card->host, &mrq);
./mmc/core/mmc_test.c:940:	mmc_wait_for_req(test->card->host, &mrq);
./mmc/core/mmc_test.c:1087:	if (test->card->host->max_blk_count == 1)
./mmc/core/mmc_test.c:1091:	size = min(size, test->card->host->max_req_size);
./mmc/core/mmc_test.c:1092:	size = min(size, test->card->host->max_seg_size);
./mmc/core/mmc_test.c:1093:	size = min(size, test->card->host->max_blk_count * 512);
./mmc/core/mmc_test.c:1108:	if (test->card->host->max_blk_count == 1)
./mmc/core/mmc_test.c:1112:	size = min(size, test->card->host->max_req_size);
./mmc/core/mmc_test.c:1113:	size = min(size, test->card->host->max_seg_size);
./mmc/core/mmc_test.c:1114:	size = min(size, test->card->host->max_blk_count * 512);
./mmc/core/mmc_test.c:1129:	if (!test->card->csd.write_partial)
./mmc/core/mmc_test.c:1147:	if (!test->card->csd.read_partial)
./mmc/core/mmc_test.c:1165:	if (!test->card->csd.write_partial)
./mmc/core/mmc_test.c:1183:	if (!test->card->csd.read_partial)
./mmc/core/mmc_test.c:1232:	if (test->card->host->max_blk_count == 1)
./mmc/core/mmc_test.c:1236:	size = min(size, test->card->host->max_req_size);
./mmc/core/mmc_test.c:1237:	size = min(size, test->card->host->max_seg_size);
./mmc/core/mmc_test.c:1238:	size = min(size, test->card->host->max_blk_count * 512);
./mmc/core/mmc_test.c:1259:	if (test->card->host->max_blk_count == 1)
./mmc/core/mmc_test.c:1263:	size = min(size, test->card->host->max_req_size);
./mmc/core/mmc_test.c:1264:	size = min(size, test->card->host->max_seg_size);
./mmc/core/mmc_test.c:1265:	size = min(size, test->card->host->max_blk_count * 512);
./mmc/core/mmc_test.c:1306:	if (test->card->host->max_blk_count == 1)
./mmc/core/mmc_test.c:1320:	if (test->card->host->max_blk_count == 1)
./mmc/core/mmc_test.c:1357:	if (test->card->host->max_blk_count == 1)
./mmc/core/mmc_test.c:1361:	size = min(size, test->card->host->max_req_size);
./mmc/core/mmc_test.c:1362:	size = min(size, test->card->host->max_seg_size);
./mmc/core/mmc_test.c:1363:	size = min(size, test->card->host->max_blk_count * 512);
./mmc/core/mmc_test.c:1379:	if (test->card->host->max_blk_count == 1)
./mmc/core/mmc_test.c:1383:	size = min(size, test->card->host->max_req_size);
./mmc/core/mmc_test.c:1384:	size = min(size, test->card->host->max_seg_size);
./mmc/core/mmc_test.c:1385:	size = min(size, test->card->host->max_blk_count * 512);
./mmc/core/mmc_test.c:1401:	       mmc_hostname(test->card->host));
./mmc/core/mmc_test.c:1428:		       mmc_hostname(test->card->host));
./mmc/core/mmc_test.c:1563:	sz = (unsigned long)test->card->pref_erase << 9;
./mmc/core/mmc_test.c:1570:	t->max_segs = test->card->host->max_segs;
./mmc/core/mmc_test.c:1571:	t->max_seg_sz = test->card->host->max_seg_size;
./mmc/core/mmc_test.c:1575:	if (t->max_tfr >> 9 > test->card->host->max_blk_count)
./mmc/core/mmc_test.c:1576:		t->max_tfr = test->card->host->max_blk_count << 9;
./mmc/core/mmc_test.c:1577:	if (t->max_tfr > test->card->host->max_req_size)
./mmc/core/mmc_test.c:1578:		t->max_tfr = test->card->host->max_req_size;
./mmc/core/mmc_test.c:1921:	range1 = rnd_addr / test->card->pref_erase;
./mmc/core/mmc_test.c:1934:		dev_addr = rnd_addr + test->card->pref_erase * ea +
./mmc/core/mmc_test.c:2137:	void *pre_req = test->card->host->ops->pre_req;
./mmc/core/mmc_test.c:2138:	void *post_req = test->card->host->ops->post_req;
./mmc/core/mmc_test.c:2327:	struct mmc_host *host = card->host;
./mmc/core/mmc_test.c:2336:		if (card->ext_csd.cmdq_en)
./mmc/core/mmc_test.c:2352:	if (!mmc_host_is_spi(test->card->host))
./mmc/core/mmc_test.c:2353:		cmd->arg = test->card->rca << 16;
./mmc/core/mmc_test.c:2356:	return mmc_wait_for_cmd(test->card->host, cmd, 0);
./mmc/core/mmc_test.c:2364:	struct mmc_host *host = test->card->host;
./mmc/core/mmc_test.c:2440:		mmc_wait_for_req_done(test->card->host, mrq);
./mmc/core/mmc_test.c:2459:			mmc_hostname(test->card->host), status, cmd_ret);
./mmc/core/mmc_test.c:2472:			mmc_hostname(test->card->host), count, t->blocks);
./mmc/core/mmc_test.c:2489:	if (!(test->card->host->caps & MMC_CAP_CMD_DURING_TFR))
./mmc/core/mmc_test.c:2949:		mmc_hostname(test->card->host), mmc_card_id(test->card));
./mmc/core/mmc_test.c:2951:	mmc_claim_host(test->card->host);
./mmc/core/mmc_test.c:2960:			mmc_hostname(test->card->host), i + 1,
./mmc/core/mmc_test.c:2967:					mmc_hostname(test->card->host),
./mmc/core/mmc_test.c:2995:				mmc_hostname(test->card->host));
./mmc/core/mmc_test.c:2999:				mmc_hostname(test->card->host));
./mmc/core/mmc_test.c:3003:				mmc_hostname(test->card->host));
./mmc/core/mmc_test.c:3007:				mmc_hostname(test->card->host));
./mmc/core/mmc_test.c:3011:				mmc_hostname(test->card->host), ret);
./mmc/core/mmc_test.c:3022:					mmc_hostname(test->card->host),
./mmc/core/mmc_test.c:3028:	mmc_release_host(test->card->host);
./mmc/core/mmc_test.c:3031:		mmc_hostname(test->card->host));
./mmc/core/mmc_test.c:3201:	if (card->debugfs_root)
./mmc/core/mmc_test.c:3202:		file = debugfs_create_file(name, mode, card->debugfs_root,
./mmc/core/mmc_test.c:3206:		dev_err(&card->dev,
./mmc/core/mmc_test.c:3258:	if (card->ext_csd.cmdq_en) {
./mmc/core/mmc_test.c:3259:		mmc_claim_host(card->host);
./mmc/core/mmc_test.c:3261:		mmc_release_host(card->host);
./mmc/core/mmc_test.c:3266:	dev_info(&card->dev, "Card claimed for testing.\n");
./mmc/core/mmc_test.c:3273:	if (card->reenable_cmdq) {
./mmc/core/mmc_test.c:3274:		mmc_claim_host(card->host);
./mmc/core/mmc_test.c:3276:		mmc_release_host(card->host);
./mmc/core/host.c:228:	 * MMC_CAP_NONREMOVABLE capability is set and no card-detection
./mmc/core/bus.c:38:	switch (card->type) {
./mmc/core/bus.c:76:	switch (card->type) {
./mmc/core/bus.c:134:	struct mmc_host *host = card->host;
./mmc/core/bus.c:152:	struct mmc_host *host = card->host;
./mmc/core/bus.c:169:	struct mmc_host *host = card->host;
./mmc/core/bus.c:186:	struct mmc_host *host = card->host;
./mmc/core/bus.c:194:	struct mmc_host *host = card->host;
./mmc/core/bus.c:256:	kfree(card->info);
./mmc/core/bus.c:272:	card->host = host;
./mmc/core/bus.c:274:	device_initialize(&card->dev);
./mmc/core/bus.c:276:	card->dev.parent = mmc_classdev(host);
./mmc/core/bus.c:277:	card->dev.bus = &mmc_bus_type;
./mmc/core/bus.c:278:	card->dev.release = mmc_release_card;
./mmc/core/bus.c:279:	card->dev.type = type;
./mmc/core/bus.c:301:	dev_set_name(&card->dev, "%s:%04x", mmc_hostname(card->host), card->rca);
./mmc/core/bus.c:303:	switch (card->type) {
./mmc/core/bus.c:330:		(card->sd_bus_speed < ARRAY_SIZE(uhs_speeds)))
./mmc/core/bus.c:331:		uhs_bus_speed_mode = uhs_speeds[card->sd_bus_speed];
./mmc/core/bus.c:333:	if (mmc_host_is_spi(card->host)) {
./mmc/core/bus.c:335:			mmc_hostname(card->host),
./mmc/core/bus.c:341:			mmc_hostname(card->host),
./mmc/core/bus.c:348:			uhs_bus_speed_mode, type, card->rca);
./mmc/core/bus.c:354:	mmc_init_context_info(card->host);
./mmc/core/bus.c:356:	card->dev.of_node = mmc_of_find_child_device(card->host, 0);
./mmc/core/bus.c:358:	device_enable_async_suspend(&card->dev);
./mmc/core/bus.c:360:	ret = device_add(&card->dev);
./mmc/core/bus.c:380:		if (mmc_host_is_spi(card->host)) {
./mmc/core/bus.c:382:				mmc_hostname(card->host));
./mmc/core/bus.c:385:				mmc_hostname(card->host), card->rca);
./mmc/core/bus.c:387:		device_del(&card->dev);
./mmc/core/bus.c:388:		of_node_put(card->dev.of_node);
./mmc/core/bus.c:391:	put_device(&card->dev);
./mmc/core/card.h:134:	cid_rev(card->cid.hwrev,		\
./mmc/core/card.h:135:		    card->cid.fwrev,		\
./mmc/core/card.h:136:		    card->cid.year,		\
./mmc/core/card.h:137:		    card->cid.month)
./mmc/core/card.h:144:	card->quirks |= data;
./mmc/core/card.h:149:	card->quirks &= ~data;
./mmc/core/card.h:158:		card->quirks |= data;
./mmc/core/card.h:165:		card->quirks &= ~data;
./mmc/core/card.h:174:		card->quirks |= data;
./mmc/core/card.h:181:		card->quirks &= ~data;
./mmc/core/sdio_irq.c:46:	func = card->sdio_single_irq;
./mmc/core/sdio_irq.c:73:			func = card->sdio_func[i - 1];
./mmc/core/sdio_irq.c:210:	struct mmc_host *host = card->host;
./mmc/core/sdio_irq.c:235:	struct mmc_host *host = card->host;
./mmc/core/sdio_irq.c:260:	card->sdio_single_irq = NULL;
./mmc/core/sdio_irq.c:261:	if ((card->host->caps & MMC_CAP_SDIO_IRQ) &&
./mmc/core/sdio_irq.c:262:	    card->host->sdio_irqs == 1)
./mmc/core/sdio_irq.c:263:		for (i = 0; i < card->sdio_funcs; i++) {
./mmc/core/sdio_irq.c:264:		       func = card->sdio_func[i];
./mmc/core/sdio_irq.c:266:			       card->sdio_single_irq = func;
./mmc/core/sdio_ops.c:115:	return mmc_io_rw_direct_host(card->host, write, fn, addr, in, out);
./mmc/core/sdio_ops.c:127:	unsigned int seg_size = card->host->max_seg_size;
./mmc/core/sdio_ops.c:177:	mmc_wait_for_req(card->host, &mrq);
./mmc/core/sdio_ops.c:187:	if (mmc_host_is_spi(card->host)) {
./mmc/core/sd.c:77:	u32 *resp = card->raw_cid;
./mmc/core/sd.c:83:	card->cid.manfid		= UNSTUFF_BITS(resp, 120, 8);
./mmc/core/sd.c:84:	card->cid.oemid			= UNSTUFF_BITS(resp, 104, 16);
./mmc/core/sd.c:85:	card->cid.prod_name[0]		= UNSTUFF_BITS(resp, 96, 8);
./mmc/core/sd.c:86:	card->cid.prod_name[1]		= UNSTUFF_BITS(resp, 88, 8);
./mmc/core/sd.c:87:	card->cid.prod_name[2]		= UNSTUFF_BITS(resp, 80, 8);
./mmc/core/sd.c:88:	card->cid.prod_name[3]		= UNSTUFF_BITS(resp, 72, 8);
./mmc/core/sd.c:89:	card->cid.prod_name[4]		= UNSTUFF_BITS(resp, 64, 8);
./mmc/core/sd.c:90:	card->cid.hwrev			= UNSTUFF_BITS(resp, 60, 4);
./mmc/core/sd.c:91:	card->cid.fwrev			= UNSTUFF_BITS(resp, 56, 4);
./mmc/core/sd.c:92:	card->cid.serial		= UNSTUFF_BITS(resp, 24, 32);
./mmc/core/sd.c:93:	card->cid.year			= UNSTUFF_BITS(resp, 12, 8);
./mmc/core/sd.c:94:	card->cid.month			= UNSTUFF_BITS(resp, 8, 4);
./mmc/core/sd.c:96:	card->cid.year += 2000; /* SD cards year offset */
./mmc/core/sd.c:104:	struct mmc_csd *csd = &card->csd;
./mmc/core/sd.c:106:	u32 *resp = card->raw_csd;
./mmc/core/sd.c:178:			mmc_hostname(card->host), csd_struct);
./mmc/core/sd.c:182:	card->erase_size = csd->erase_size;
./mmc/core/sd.c:192:	struct sd_scr *scr = &card->scr;
./mmc/core/sd.c:196:	resp[3] = card->raw_scr[1];
./mmc/core/sd.c:197:	resp[2] = card->raw_scr[0];
./mmc/core/sd.c:202:			mmc_hostname(card->host), scr_struct);
./mmc/core/sd.c:213:		card->erased_byte = 0xFF;
./mmc/core/sd.c:215:		card->erased_byte = 0x0;
./mmc/core/sd.c:231:	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
./mmc/core/sd.c:233:			mmc_hostname(card->host));
./mmc/core/sd.c:237:	raw_ssr = kmalloc(sizeof(card->raw_ssr), GFP_KERNEL);
./mmc/core/sd.c:243:			mmc_hostname(card->host));
./mmc/core/sd.c:249:		card->raw_ssr[i] = be32_to_cpu(raw_ssr[i]);
./mmc/core/sd.c:257:	au = UNSTUFF_BITS(card->raw_ssr, 428 - 384, 4);
./mmc/core/sd.c:259:		if (au <= 9 || card->scr.sda_spec3) {
./mmc/core/sd.c:260:			card->ssr.au = sd_au_size[au];
./mmc/core/sd.c:261:			es = UNSTUFF_BITS(card->raw_ssr, 408 - 384, 16);
./mmc/core/sd.c:262:			et = UNSTUFF_BITS(card->raw_ssr, 402 - 384, 6);
./mmc/core/sd.c:264:				eo = UNSTUFF_BITS(card->raw_ssr, 400 - 384, 2);
./mmc/core/sd.c:265:				card->ssr.erase_timeout = (et * 1000) / es;
./mmc/core/sd.c:266:				card->ssr.erase_offset = eo * 1000;
./mmc/core/sd.c:270:				mmc_hostname(card->host));
./mmc/core/sd.c:285:	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
./mmc/core/sd.c:288:	if (!(card->csd.cmdclass & CCC_SWITCH)) {
./mmc/core/sd.c:290:			mmc_hostname(card->host));
./mmc/core/sd.c:315:			mmc_hostname(card->host));
./mmc/core/sd.c:322:		card->sw_caps.hs_max_dtr = HIGH_SPEED_MAX_DTR;
./mmc/core/sd.c:324:	if (card->scr.sda_spec3) {
./mmc/core/sd.c:325:		card->sw_caps.sd3_bus_mode = status[13];
./mmc/core/sd.c:327:		card->sw_caps.sd3_drv_type = status[9];
./mmc/core/sd.c:328:		card->sw_caps.sd3_curr_limit = status[7] | status[6] << 8;
./mmc/core/sd.c:345:	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
./mmc/core/sd.c:348:	if (!(card->csd.cmdclass & CCC_SWITCH))
./mmc/core/sd.c:351:	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
./mmc/core/sd.c:354:	if (card->sw_caps.hs_max_dtr == 0)
./mmc/core/sd.c:367:			mmc_hostname(card->host));
./mmc/core/sd.c:384:	card->drive_strength = 0;
./mmc/core/sd.c:386:	card_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;
./mmc/core/sd.c:389:						   card->sw_caps.uhs_max_dtr,
./mmc/core/sd.c:398:				mmc_hostname(card->host));
./mmc/core/sd.c:401:		card->drive_strength = drive_strength;
./mmc/core/sd.c:405:		mmc_set_driver_type(card->host, drv_type);
./mmc/core/sd.c:416:	if (!mmc_host_uhs(card->host)) {
./mmc/core/sd.c:417:		card->sd_bus_speed = 0;
./mmc/core/sd.c:421:	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
./mmc/core/sd.c:422:	    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {
./mmc/core/sd.c:423:			card->sd_bus_speed = UHS_SDR104_BUS_SPEED;
./mmc/core/sd.c:424:	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
./mmc/core/sd.c:425:		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {
./mmc/core/sd.c:426:			card->sd_bus_speed = UHS_DDR50_BUS_SPEED;
./mmc/core/sd.c:427:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./mmc/core/sd.c:428:		    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &
./mmc/core/sd.c:430:			card->sd_bus_speed = UHS_SDR50_BUS_SPEED;
./mmc/core/sd.c:431:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./mmc/core/sd.c:433:		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {
./mmc/core/sd.c:434:			card->sd_bus_speed = UHS_SDR25_BUS_SPEED;
./mmc/core/sd.c:435:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./mmc/core/sd.c:437:		    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &
./mmc/core/sd.c:439:			card->sd_bus_speed = UHS_SDR12_BUS_SPEED;
./mmc/core/sd.c:448:	switch (card->sd_bus_speed) {
./mmc/core/sd.c:451:		card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
./mmc/core/sd.c:455:		card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
./mmc/core/sd.c:459:		card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
./mmc/core/sd.c:463:		card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
./mmc/core/sd.c:467:		card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
./mmc/core/sd.c:473:	err = mmc_sd_switch(card, 1, 0, card->sd_bus_speed, status);
./mmc/core/sd.c:477:	if ((status[16] & 0xF) != card->sd_bus_speed)
./mmc/core/sd.c:479:			mmc_hostname(card->host));
./mmc/core/sd.c:481:		mmc_set_timing(card->host, timing);
./mmc/core/sd.c:482:		mmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);
./mmc/core/sd.c:524:	if ((card->sd_bus_speed != UHS_SDR50_BUS_SPEED) &&
./mmc/core/sd.c:525:	    (card->sd_bus_speed != UHS_SDR104_BUS_SPEED) &&
./mmc/core/sd.c:526:	    (card->sd_bus_speed != UHS_DDR50_BUS_SPEED))
./mmc/core/sd.c:533:	max_current = sd_get_host_max_current(card->host);
./mmc/core/sd.c:551:	    card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_800)
./mmc/core/sd.c:554:		 card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_600)
./mmc/core/sd.c:557:		 card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_400)
./mmc/core/sd.c:560:		 card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_200)
./mmc/core/sd.c:570:				mmc_hostname(card->host));
./mmc/core/sd.c:585:	if (!card->scr.sda_spec3)
./mmc/core/sd.c:588:	if (!(card->csd.cmdclass & CCC_SWITCH))
./mmc/core/sd.c:596:	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
./mmc/core/sd.c:597:	    (card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
./mmc/core/sd.c:602:		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
./mmc/core/sd.c:630:	if (!mmc_host_is_spi(card->host) &&
./mmc/core/sd.c:631:		(card->host->ios.timing == MMC_TIMING_UHS_SDR50 ||
./mmc/core/sd.c:632:		 card->host->ios.timing == MMC_TIMING_UHS_DDR50 ||
./mmc/core/sd.c:633:		 card->host->ios.timing == MMC_TIMING_UHS_SDR104)) {
./mmc/core/sd.c:643:		if (err && card->host->ios.timing == MMC_TIMING_UHS_DDR50) {
./mmc/core/sd.c:645:				mmc_hostname(card->host));
./mmc/core/sd.c:656:MMC_DEV_ATTR(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
./mmc/core/sd.c:657:	card->raw_cid[2], card->raw_cid[3]);
./mmc/core/sd.c:658:MMC_DEV_ATTR(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
./mmc/core/sd.c:659:	card->raw_csd[2], card->raw_csd[3]);
./mmc/core/sd.c:660:MMC_DEV_ATTR(scr, "%08x%08x\n", card->raw_scr[0], card->raw_scr[1]);
./mmc/core/sd.c:663:		card->raw_ssr[0], card->raw_ssr[1], card->raw_ssr[2],
./mmc/core/sd.c:664:		card->raw_ssr[3], card->raw_ssr[4], card->raw_ssr[5],
./mmc/core/sd.c:665:		card->raw_ssr[6], card->raw_ssr[7], card->raw_ssr[8],
./mmc/core/sd.c:666:		card->raw_ssr[9], card->raw_ssr[10], card->raw_ssr[11],
./mmc/core/sd.c:667:		card->raw_ssr[12], card->raw_ssr[13], card->raw_ssr[14],
./mmc/core/sd.c:668:		card->raw_ssr[15]);
./mmc/core/sd.c:669:MMC_DEV_ATTR(date, "%02d/%04d\n", card->cid.month, card->cid.year);
./mmc/core/sd.c:670:MMC_DEV_ATTR(erase_size, "%u\n", card->erase_size << 9);
./mmc/core/sd.c:671:MMC_DEV_ATTR(preferred_erase_size, "%u\n", card->pref_erase << 9);
./mmc/core/sd.c:672:MMC_DEV_ATTR(fwrev, "0x%x\n", card->cid.fwrev);
./mmc/core/sd.c:673:MMC_DEV_ATTR(hwrev, "0x%x\n", card->cid.hwrev);
./mmc/core/sd.c:674:MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
./mmc/core/sd.c:675:MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
./mmc/core/sd.c:676:MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
./mmc/core/sd.c:677:MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
./mmc/core/sd.c:678:MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
./mmc/core/sd.c:686:       struct mmc_host *host = card->host;
./mmc/core/sd.c:688:       if (card->csd.dsr_imp && host->dsr_req)
./mmc/core/sd.c:802:	err = mmc_send_csd(card, card->raw_csd);
./mmc/core/sd.c:902:		if (max_dtr > card->sw_caps.hs_max_dtr)
./mmc/core/sd.c:903:			max_dtr = card->sw_caps.hs_max_dtr;
./mmc/core/sd.c:904:	} else if (max_dtr > card->csd.max_dtr) {
./mmc/core/sd.c:905:		max_dtr = card->csd.max_dtr;
./mmc/core/sd.c:932:		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0)
./mmc/core/sd.c:944:		card->ocr = ocr;
./mmc/core/sd.c:945:		card->type = MMC_TYPE_SD;
./mmc/core/sd.c:946:		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
./mmc/core/sd.c:959:		err = mmc_send_relative_addr(host, &card->rca);
./mmc/core/sd.c:976:	if (card->csd.dsr_imp && host->dsr_req)
./mmc/core/sd.c:1003:			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
./mmc/core/sd.c:1016:			(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
./mmc/core/sd.c:1110:		pm_runtime_disable(&host->card->dev);
./mmc/core/sd.c:1111:		pm_runtime_set_suspended(&host->card->dev);
./mmc/core/sd.c:1130:	mmc_power_up(host, host->card->ocr);
./mmc/core/sd.c:1131:	err = mmc_sd_init_card(host, host->card->ocr, host->card);
./mmc/core/sd.c:1144:	pm_runtime_enable(&host->card->dev);
./mmc/core/sd.c:1183:	mmc_power_cycle(host, host->card->ocr);
./mmc/core/sd.c:1184:	return mmc_sd_init_card(host, host->card->ocr, host->card);
./tty/cyclades.c:297:	cy_writeb(port->u.cyy.base_addr + (reg << card->bus_index), val);
./tty/cyclades.c:304:	return readb(port->u.cyy.base_addr + (reg << card->bus_index));
./tty/cyclades.c:309:	return card->num_chips == (unsigned int)-1;
./tty/cyclades.c:319:	return __cyz_fpga_loaded(card->ctl_addr.p9060);
./tty/cyclades.c:324:	struct FIRM_ID __iomem *fw_id = card->base_addr + ID_ADDRESS;
./tty/cyclades.c:326:	return (card->hw_ver == ZO_V1 || cyz_fpga_loaded(card)) &&
./tty/cyclades.c:384:			port->card->bus_index);
./tty/cyclades.c:824:	int channel = info->line - card->first_line;
./tty/cyclades.c:1205:	__u32 channel = info->line - card->first_line;
./tty/cyclades.c:1208:	spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1214:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1272:	channel = info->line - card->first_line;
./tty/cyclades.c:1278:	spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1293:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1300:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1321:			"base_addr %p\n", card, channel, card->base_addr);
./tty/cyclades.c:1323:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1375:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1383:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1392:	int channel = info->line - card->first_line;
./tty/cyclades.c:1395:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1398:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1403:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1409:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1430:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1450:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1453:		int channel = info->line - card->first_line;
./tty/cyclades.c:1455:			"base_addr %p\n", card, channel, card->base_addr);
./tty/cyclades.c:1461:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1476:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1676:	channel = info->line - card->first_line;
./tty/cyclades.c:1678:	spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1680:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1684:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1690:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1705:	channel = info->line - card->first_line;
./tty/cyclades.c:1706:	spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1715:			spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1717:			spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1732:			spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1734:			spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:1738:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:1782:	spin_lock_irqsave(&info->card->card_lock, flags);
./tty/cyclades.c:1798:	spin_unlock_irqrestore(&info->card->card_lock, flags);
./tty/cyclades.c:1831:	spin_lock_irqsave(&info->card->card_lock, flags);
./tty/cyclades.c:1833:		spin_unlock_irqrestore(&info->card->card_lock, flags);
./tty/cyclades.c:1842:	spin_unlock_irqrestore(&info->card->card_lock, flags);
./tty/cyclades.c:1979:	channel = info->line - card->first_line;
./tty/cyclades.c:2091:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2139:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2359:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2361:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2383:		int channel = info->line - card->first_line;
./tty/cyclades.c:2386:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2390:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2436:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2438:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2441:		int retval, channel = info->line - card->first_line;
./tty/cyclades.c:2447:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2468:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2492:	spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2501:					spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2503:					spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2510:					spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2512:					spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2519:				info->line - card->first_line,
./tty/cyclades.c:2527:				info->line - card->first_line,
./tty/cyclades.c:2536:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2549:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2552:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2575:		spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2577:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2601:	spin_lock_irqsave(&info->card->card_lock, flags);
./tty/cyclades.c:2603:	spin_unlock_irqrestore(&info->card->card_lock, flags);
./tty/cyclades.c:2719:		spin_lock_irqsave(&info->card->card_lock, flags);
./tty/cyclades.c:2722:		spin_unlock_irqrestore(&info->card->card_lock, flags);
./tty/cyclades.c:2750:	spin_lock_irqsave(&info->card->card_lock, flags);
./tty/cyclades.c:2752:	spin_unlock_irqrestore(&info->card->card_lock, flags);
./tty/cyclades.c:2818:	channel = info->line - card->first_line;
./tty/cyclades.c:2857:			spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2859:			spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:2895:			spin_lock_irqsave(&card->card_lock, flags);
./tty/cyclades.c:2897:			spin_unlock_irqrestore(&card->card_lock, flags);
./tty/cyclades.c:3304:			if (card->base_addr == NULL)
./tty/cyclades.c:3327:		card->base_addr = cy_isa_address;
./tty/cyclades.c:3328:		card->ctl_addr.p9050 = NULL;
./tty/cyclades.c:3329:		card->irq = (int)cy_isa_irq;
./tty/cyclades.c:3330:		card->bus_index = 0;
./tty/cyclades.c:3331:		card->first_line = cy_next_channel;
./tty/cyclades.c:3332:		card->num_chips = cy_isa_nchan / CyPORTS_PER_CHIP;
./tty/cyclades.c:3333:		card->nports = cy_isa_nchan;
./tty/cyclades.c:3335:			card->base_addr = NULL;
./tty/cyclades.c:3350:			tty_port_register_device(&card->ports[k].port,
./tty/cyclades.c:3787:		if (card->base_addr == NULL)
./tty/cyclades.c:3806:		card->num_chips = nchan / CyPORTS_PER_CHIP;
./tty/cyclades.c:3813:		card->hw_ver = mailbox;
./tty/cyclades.c:3814:		card->num_chips = (unsigned int)-1;
./tty/cyclades.c:3815:		card->board_ctrl = &zfw_ctrl->board_ctrl;
./tty/cyclades.c:3830:	card->base_addr = addr2;
./tty/cyclades.c:3831:	card->ctl_addr.p9050 = addr0;
./tty/cyclades.c:3832:	card->irq = irq;
./tty/cyclades.c:3833:	card->bus_index = 1;
./tty/cyclades.c:3834:	card->first_line = cy_next_channel;
./tty/cyclades.c:3835:	card->nports = nchan;
./tty/cyclades.c:3867:		tty_port_register_device(&card->ports[j].port,
./tty/cyclades.c:3873:	card->base_addr = NULL;
./tty/cyclades.c:4110:		if (card->base_addr) {
./tty/cyclades.c:4112:			cy_writeb(card->base_addr + Cy_ClrIntr, 0);
./tty/cyclades.c:4113:			iounmap(card->base_addr);
./tty/cyclades.c:4114:			if (card->ctl_addr.p9050)
./tty/cyclades.c:4115:				iounmap(card->ctl_addr.p9050);
./tty/cyclades.c:4116:			if (card->irq
./tty/cyclades.c:4121:				free_irq(card->irq, card);
./tty/cyclades.c:4122:			for (e1 = card->first_line; e1 < card->first_line +
./tty/cyclades.c:4123:					card->nports; e1++)
./tty/cyclades.c:4125:			kfree(card->ports);
./tty/serial/8250/8250_pnp.c:430:	    (dev->card && check_name(dev->card->name))))
./tty/serial/ioc3_serial.c:473:	port->ip_card->ic_enable &= ~hooks->intr_clear;
./tty/serial/ioc3_serial.c:486:	if ((port->ip_card->ic_enable & mask) != mask) {
./tty/serial/ioc3_serial.c:487:		port->ip_card->ic_enable |= mask;
./tty/serial/ioc3_serial.c:764:	if (port->ip_card->ic_enable & mask) {
./tty/serial/ioc3_serial.c:766:		port->ip_card->ic_enable &= ~mask;
./tty/serial/ioc3_serial.c:812:	else if (!(port->ip_card->ic_enable & hooks->intr_tx_mt))
./tty/serial/rp2.c:261:	spin_lock_irqsave(&up->card->card_lock, flags);
./tty/serial/rp2.c:270:	spin_unlock_irqrestore(&up->card->card_lock, flags);
./tty/serial/rp2.c:490:	void __iomem *base = card->bar1 + RP2_ASIC_OFFSET(asic_id);
./tty/serial/rp2.c:496:		rp2_ch_interrupt(&card->ports[ch]);
./tty/serial/rp2.c:508:	if (card->n_ports >= PORTS_PER_ASIC)
./tty/serial/rp2.c:603:	void __iomem *base = card->bar1 + RP2_ASIC_OFFSET(asic_id);
./tty/serial/rp2.c:623:	writel(4, card->bar0 + RP2_FPGA_CTL0);
./tty/serial/rp2.c:624:	writel(0, card->bar0 + RP2_FPGA_CTL1);
./tty/serial/rp2.c:627:	if (card->n_ports >= PORTS_PER_ASIC)
./tty/serial/rp2.c:630:	writel(RP2_IRQ_MASK_EN_m, card->bar0 + RP2_IRQ_MASK);
./tty/serial/rp2.c:665:	for (i = 0; i < card->initialized_ports; i++)
./tty/serial/rp2.c:666:		uart_remove_one_port(&rp2_uart_driver, &card->ports[i].port);
./tty/serial/rp2.c:667:	card->initialized_ports = 0;
./tty/serial/rp2.c:677:		dev_err(&card->pdev->dev, "cannot find '%s' firmware image\n",
./tty/serial/rp2.c:682:	phys_base = pci_resource_start(card->pdev, 1);
./tty/serial/rp2.c:684:	for (i = 0; i < card->n_ports; i++) {
./tty/serial/rp2.c:685:		struct rp2_uart_port *rp = &card->ports[i];
./tty/serial/rp2.c:689:		rp->asic_base = card->bar1;
./tty/serial/rp2.c:690:		rp->base = card->bar1 + RP2_PORT_BASE + j*RP2_PORT_SPACING;
./tty/serial/rp2.c:691:		rp->ucode = card->bar1 + RP2_UCODE_BASE + j*RP2_UCODE_SPACING;
./tty/serial/rp2.c:696:		p->line = card->minor_start + i;
./tty/serial/rp2.c:697:		p->dev = &card->pdev->dev;
./tty/serial/rp2.c:704:		p->irq = card->pdev->irq;
./tty/serial/rp2.c:718:			dev_err(&card->pdev->dev,
./tty/serial/rp2.c:723:		card->initialized_ports++;
./tty/serial/rp2.c:735:		dev_warn(&card->pdev->dev, "driver initialization failed\n");
./tty/serial/rp2.c:737:	complete(&card->fw_loaded);
./tty/serial/rp2.c:752:	spin_lock_init(&card->card_lock);
./tty/serial/rp2.c:753:	init_completion(&card->fw_loaded);
./tty/serial/rp2.c:764:	card->bar0 = bars[0];
./tty/serial/rp2.c:765:	card->bar1 = bars[1];
./tty/serial/rp2.c:766:	card->pdev = pdev;
./tty/serial/rp2.c:768:	rp2_decode_cap(id, &card->n_ports, &card->smpte);
./tty/serial/rp2.c:769:	dev_info(&pdev->dev, "found new card with %d ports\n", card->n_ports);
./tty/serial/rp2.c:771:	card->minor_start = rp2_alloc_ports(card->n_ports);
./tty/serial/rp2.c:772:	if (card->minor_start < 0) {
./tty/serial/rp2.c:780:	ports = devm_kzalloc(&pdev->dev, sizeof(*ports) * card->n_ports,
./tty/serial/rp2.c:784:	card->ports = ports;
./tty/serial/rp2.c:809:	wait_for_completion(&card->fw_loaded);
./tty/isicom.c:239:	unsigned long base = card->base;
./tty/isicom.c:243:		spin_lock_irqsave(&card->card_lock, card->flags);
./tty/isicom.c:249:		spin_unlock_irqrestore(&card->card_lock, card->flags);
./tty/isicom.c:252:	pr_warn("Failed to lock Card (0x%lx)\n", card->base);
./tty/isicom.c:259:	spin_unlock_irqrestore(&card->card_lock, card->flags);
./tty/isicom.c:266:/* card->lock HAS to be held */
./tty/isicom.c:270:	unsigned long base = card->base;
./tty/isicom.c:276:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./tty/isicom.c:282:/* card->lock HAS to be held */
./tty/isicom.c:286:	unsigned long base = card->base;
./tty/isicom.c:292:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./tty/isicom.c:298:/* card->lock HAS to be held */
./tty/isicom.c:302:	unsigned long base = card->base;
./tty/isicom.c:308:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./tty/isicom.c:314:/* card->lock HAS to be held */
./tty/isicom.c:318:	unsigned long base = card->base;
./tty/isicom.c:324:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./tty/isicom.c:330:/* card->lock MUST NOT be held */
./tty/isicom.c:336:	unsigned long base = card->base;
./tty/isicom.c:343:		outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./tty/isicom.c:348:		outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./tty/isicom.c:356:/* card->lock HAS to be held */
./tty/isicom.c:360:	unsigned long base = card->base;
./tty/isicom.c:366:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./tty/isicom.c:525:	if (!card || !(card->status & FIRMWARE_LOADED))
./tty/isicom.c:528:	base = card->base;
./tty/isicom.c:534:	spin_lock(&card->card_lock);
./tty/isicom.c:545:	channel = (header & 0x7800) >> card->shift_count;
./tty/isicom.c:548:	if (channel + 1 > card->port_count) {
./tty/isicom.c:552:		spin_unlock(&card->card_lock);
./tty/isicom.c:555:	port = card->ports + channel;
./tty/isicom.c:558:		spin_unlock(&card->card_lock);
./tty/isicom.c:572:		spin_unlock(&card->card_lock);
./tty/isicom.c:677:	spin_unlock(&card->card_lock);
./tty/isicom.c:688:	unsigned long base = card->base;
./tty/isicom.c:690:		shift_count = card->shift_count;
./tty/isicom.c:782:		card->port_status |= (1 << channel);
./tty/isicom.c:783:		outw(card->port_status, base + 0x02);
./tty/isicom.c:815:	spin_lock_irqsave(&card->card_lock, flags);
./tty/isicom.c:821:	if (WaitTillCardIsFree(card->base) == 0) {
./tty/isicom.c:822:		outw(0x8000 | (port->channel << card->shift_count) | 0x02,
./tty/isicom.c:823:				card->base);
./tty/isicom.c:824:		outw(((ISICOM_KILLTX | ISICOM_KILLRX) << 8) | 0x06, card->base);
./tty/isicom.c:825:		InterruptTheCard(card->base);
./tty/isicom.c:828:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/isicom.c:849:	if (!(card->status & FIRMWARE_LOADED))
./tty/isicom.c:853:	if (line > ((board * 16) + card->port_count - 1))
./tty/isicom.c:879:/* card->lock HAS to be held */
./tty/isicom.c:884:	if (--card->count < 0) {
./tty/isicom.c:886:			 __func__, card->base, card->count);
./tty/isicom.c:887:		card->count = 0;
./tty/isicom.c:890:	if (!card->count)
./tty/isicom.c:891:		card->status &= BOARD_ACTIVE;
./tty/isicom.c:903:	spin_lock_irqsave(&card->card_lock, flags);
./tty/isicom.c:905:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/isicom.c:918:	spin_lock_irqsave(&card->card_lock, flags);
./tty/isicom.c:919:	card->port_status &= ~(1 << ip->channel);
./tty/isicom.c:920:	outw(card->port_status, card->base + 0x02);
./tty/isicom.c:922:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/isicom.c:952:	spin_lock_irqsave(&card->card_lock, flags);
./tty/isicom.c:970:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/isicom.c:984:	spin_lock_irqsave(&card->card_lock, flags);
./tty/isicom.c:986:		spin_unlock_irqrestore(&card->card_lock, flags);
./tty/isicom.c:993:	spin_unlock_irqrestore(&card->card_lock, flags);
./tty/isicom.c:1043:	unsigned long base = card->base;
./tty/isicom.c:1051:	outw(0x8000 | ((port->channel) << (card->shift_count)) | 0x3, base);
./tty/isicom.c:1086:	spin_lock_irqsave(&port->card->card_lock, flags);
./tty/isicom.c:1096:	spin_unlock_irqrestore(&port->card->card_lock, flags);
./tty/isicom.c:1133:		spin_lock_irqsave(&port->card->card_lock, flags);
./tty/isicom.c:1135:		spin_unlock_irqrestore(&port->card->card_lock, flags);
./tty/isicom.c:1150:	out_info.port = port->card->base;
./tty/isicom.c:1151:	out_info.irq = port->card->irq;
./tty/isicom.c:1198:	spin_lock_irqsave(&port->card->card_lock, flags);
./tty/isicom.c:1200:	spin_unlock_irqrestore(&port->card->card_lock, flags);
./tty/isicom.c:1218:	card->port_status &= ~(1 << port->channel);
./tty/isicom.c:1219:	outw(card->port_status, card->base + 0x02);
./tty/isicom.c:1232:	card->port_status |= (1 << port->channel);
./tty/isicom.c:1233:	outw(card->port_status, card->base + 0x02);
./staging/rts5208/ms.c:35:	ms_card->err_code = err_code;
./staging/rts5208/ms.c:42:	return (ms_card->err_code == err_code);
./staging/rts5208/ms.c:377:			ms_card->ms_clock = chip->asic_ms_hg_clk;
./staging/rts5208/ms.c:379:			ms_card->ms_clock = chip->fpga_ms_hg_clk;
./staging/rts5208/ms.c:383:			ms_card->ms_clock = chip->asic_ms_4bit_clk;
./staging/rts5208/ms.c:385:			ms_card->ms_clock = chip->fpga_ms_4bit_clk;
./staging/rts5208/ms.c:389:			ms_card->ms_clock = chip->asic_ms_1bit_clk;
./staging/rts5208/ms.c:391:			ms_card->ms_clock = chip->fpga_ms_1bit_clk;
./staging/rts5208/ms.c:394:	retval = switch_clock(chip, ms_card->ms_clock);
./staging/rts5208/ms.c:420:	retval = switch_clock(chip, ms_card->ms_clock);
./staging/rts5208/ms.c:554:	ms_card->ms_type = 0;
./staging/rts5208/ms.c:555:	ms_card->check_ms_flow = 0;
./staging/rts5208/ms.c:556:	ms_card->switch_8bit_fail = 0;
./staging/rts5208/ms.c:557:	ms_card->delay_write.delay_write_flag = 0;
./staging/rts5208/ms.c:559:	ms_card->pro_under_formatting = 0;
./staging/rts5208/ms.c:696:			ms_card->check_ms_flow = 1;
./staging/rts5208/ms.c:709:		ms_card->check_ms_flow = 1;
./staging/rts5208/ms.c:734:		ms_card->check_ms_flow = 1;
./staging/rts5208/ms.c:739:	ms_card->ms_type |= TYPE_MSPRO;
./staging/rts5208/ms.c:748:		ms_card->ms_type &= 0x0F;
./staging/rts5208/ms.c:751:			ms_card->ms_type |= MS_HG;
./staging/rts5208/ms.c:753:			ms_card->ms_type &= 0x0F;
./staging/rts5208/ms.c:866:	ms_card->ms_type |= MS_8BIT;
./staging/rts5208/ms.c:950:			ms_card->switch_8bit_fail = 1;
./staging/rts5208/ms.c:1161:				ms_card->ms_type |= MS_XC;
./staging/rts5208/ms.c:1244:	memcpy(ms_card->raw_sys_info, buf + sys_info_addr, 96);
./staging/rts5208/ms.c:1246:	memcpy(ms_card->raw_model_name, buf + model_name_addr, 48);
./staging/rts5208/ms.c:1291:			ms_card->capacity = xc_total_blk * xc_blk_size;
./staging/rts5208/ms.c:1294:			ms_card->capacity = total_blk * blk_size;
./staging/rts5208/ms.c:1297:	ms_card->capacity = total_blk * blk_size;
./staging/rts5208/ms.c:1298:	chip->capacity[chip->card2lun[MS_CARD]] = ms_card->capacity;
./staging/rts5208/ms.c:1329:		if (ms_card->switch_8bit_fail) {
./staging/rts5208/ms.c:1366:				(ms_card->raw_sys_info[46] & 0x18) >> 3;
./staging/rts5208/ms.c:2177:	ms_card->ms_type |= TYPE_MS;
./staging/rts5208/ms.c:2220:				ms_card->boot_block = i;
./staging/rts5208/ms.c:2234:		retval = ms_read_page(chip, ms_card->boot_block, j);
./staging/rts5208/ms.c:2237:				i = ms_card->boot_block + 1;
./staging/rts5208/ms.c:2244:	retval = ms_read_page(chip, ms_card->boot_block, 0);
./staging/rts5208/ms.c:2263:	memcpy(ms_card->raw_sys_info, ptr, 96);
./staging/rts5208/ms.c:2296:		i = ms_card->boot_block + 1;
./staging/rts5208/ms.c:2304:		i = ms_card->boot_block + 1;
./staging/rts5208/ms.c:2315:		ms_card->block_shift = 5;
./staging/rts5208/ms.c:2316:		ms_card->page_off = 0x1F;
./staging/rts5208/ms.c:2319:		ms_card->block_shift = 4;
./staging/rts5208/ms.c:2320:		ms_card->page_off = 0x0F;
./staging/rts5208/ms.c:2324:	ms_card->total_block = ((u16)ptr[8] << 8) | ptr[9];
./staging/rts5208/ms.c:2329:	if (ms_card->block_shift == 4)  { /* 4MB or 8MB */
./staging/rts5208/ms.c:2331:			ms_card->capacity = 0x1EE0;
./staging/rts5208/ms.c:2333:			ms_card->capacity = 0x3DE0;
./staging/rts5208/ms.c:2337:			ms_card->capacity = 0x7BC0;
./staging/rts5208/ms.c:2339:			ms_card->capacity = 0xF7C0;
./staging/rts5208/ms.c:2341:			ms_card->capacity = 0x1EF80;
./staging/rts5208/ms.c:2343:			ms_card->capacity = 0x3DF00;
./staging/rts5208/ms.c:2350:	ms_card->capacity = ((u32)eblock_cnt - 2) << ms_card->block_shift;
./staging/rts5208/ms.c:2353:	chip->capacity[chip->card2lun[MS_CARD]] = ms_card->capacity;
./staging/rts5208/ms.c:2391:		ms_card->ms_type |= MS_4BIT;
./staging/rts5208/ms.c:2409:	ms_card->segment_cnt = ms_card->total_block >> 9;
./staging/rts5208/ms.c:2410:	dev_dbg(rtsx_dev(chip), "ms_card->segment_cnt = %d\n",
./staging/rts5208/ms.c:2411:		ms_card->segment_cnt);
./staging/rts5208/ms.c:2413:	size = ms_card->segment_cnt * sizeof(struct zone_entry);
./staging/rts5208/ms.c:2414:	ms_card->segment = vzalloc(size);
./staging/rts5208/ms.c:2415:	if (!ms_card->segment) {
./staging/rts5208/ms.c:2420:	retval = ms_read_page(chip, ms_card->boot_block, 1);
./staging/rts5208/ms.c:2427:	for (i = 0; i < (((ms_card->total_block >> 9) * 10) + 1); i++) {
./staging/rts5208/ms.c:2448:		block_no = ms_card->segment[seg_no].disable_count++;
./staging/rts5208/ms.c:2449:		ms_card->segment[seg_no].defect_list[block_no] = defect_block;
./staging/rts5208/ms.c:2452:	for (i = 0; i < ms_card->segment_cnt; i++) {
./staging/rts5208/ms.c:2453:		ms_card->segment[i].build_flag = 0;
./staging/rts5208/ms.c:2454:		ms_card->segment[i].l2p_table = NULL;
./staging/rts5208/ms.c:2455:		ms_card->segment[i].free_table = NULL;
./staging/rts5208/ms.c:2456:		ms_card->segment[i].get_index = 0;
./staging/rts5208/ms.c:2457:		ms_card->segment[i].set_index = 0;
./staging/rts5208/ms.c:2458:		ms_card->segment[i].unused_blk_cnt = 0;
./staging/rts5208/ms.c:2461:			i, ms_card->segment[i].disable_count);
./staging/rts5208/ms.c:2467:	vfree(ms_card->segment);
./staging/rts5208/ms.c:2468:	ms_card->segment = NULL;
./staging/rts5208/ms.c:2478:	if (!ms_card->segment)
./staging/rts5208/ms.c:2481:	segment = &ms_card->segment[seg_no];
./staging/rts5208/ms.c:2495:	if (!ms_card->segment)
./staging/rts5208/ms.c:2498:	segment = &ms_card->segment[seg_no];
./staging/rts5208/ms.c:2510:	segment = &ms_card->segment[seg_no];
./staging/rts5208/ms.c:2525:	segment = &ms_card->segment[seg_no];
./staging/rts5208/ms.c:2554:	segment = &ms_card->segment[seg_no];
./staging/rts5208/ms.c:2599:	if (!ms_card->segment) {
./staging/rts5208/ms.c:2607:	if (ms_card->segment[seg_no].build_flag) {
./staging/rts5208/ms.c:2618:	segment = &ms_card->segment[seg_no];
./staging/rts5208/ms.c:2670:		if (seg_no == ms_card->segment_cnt - 1) {
./staging/rts5208/ms.c:2738:	if (seg_no == ms_card->segment_cnt - 1) {
./staging/rts5208/ms.c:2765:			if (seg_no == ms_card->segment_cnt - 1) {
./staging/rts5208/ms.c:2783:			if (tmp_blk < ms_card->boot_block) {
./staging/rts5208/ms.c:2792:						      ms_card->page_off + 1);
./staging/rts5208/ms.c:2840:	ms_card->ms_type = 0;
./staging/rts5208/ms.c:2844:		if (ms_card->check_ms_flow) {
./staging/rts5208/ms.c:2866:		retval = ms_build_l2p_tbl(chip, ms_card->total_block / 512 - 1);
./staging/rts5208/ms.c:2873:	dev_dbg(rtsx_dev(chip), "ms_card->ms_type = 0x%x\n", ms_card->ms_type);
./staging/rts5208/ms.c:2912:	if (ms_card->seq_mode) {
./staging/rts5208/ms.c:2917:		ms_card->seq_mode = 0;
./staging/rts5208/ms.c:2918:		ms_card->total_sec_cnt = 0;
./staging/rts5208/ms.c:2931:		if (ms_card->ms_clock > 30)
./staging/rts5208/ms.c:2932:			ms_card->ms_clock -= 20;
./staging/rts5208/ms.c:2934:		if (ms_card->ms_clock == CLK_80)
./staging/rts5208/ms.c:2935:			ms_card->ms_clock = CLK_60;
./staging/rts5208/ms.c:2936:		else if (ms_card->ms_clock == CLK_60)
./staging/rts5208/ms.c:2937:			ms_card->ms_clock = CLK_40;
./staging/rts5208/ms.c:2961:	ms_card->cleanup_counter = 0;
./staging/rts5208/ms.c:3009:	if (ms_card->seq_mode) {
./staging/rts5208/ms.c:3010:		if ((ms_card->pre_dir != srb->sc_data_direction) ||
./staging/rts5208/ms.c:3011:		    ((ms_card->pre_sec_addr + ms_card->pre_sec_cnt) !=
./staging/rts5208/ms.c:3013:		    (mode_2k && (ms_card->seq_mode & MODE_512_SEQ)) ||
./staging/rts5208/ms.c:3014:		    (!mode_2k && (ms_card->seq_mode & MODE_2K_SEQ)) ||
./staging/rts5208/ms.c:3016:		    ((ms_card->total_sec_cnt + sector_cnt) > 0xFE00)) {
./staging/rts5208/ms.c:3017:			ms_card->seq_mode = 0;
./staging/rts5208/ms.c:3018:			ms_card->total_sec_cnt = 0;
./staging/rts5208/ms.c:3032:	if (!ms_card->seq_mode) {
./staging/rts5208/ms.c:3033:		ms_card->total_sec_cnt = 0;
./staging/rts5208/ms.c:3035:			if ((ms_card->capacity - start_sector) > 0xFE00)
./staging/rts5208/ms.c:3038:				count = (u16)(ms_card->capacity - start_sector);
./staging/rts5208/ms.c:3042:					ms_card->seq_mode = MODE_2K_SEQ;
./staging/rts5208/ms.c:3044:					ms_card->seq_mode = MODE_512_SEQ;
./staging/rts5208/ms.c:3051:			ms_card->seq_mode = 0;
./staging/rts5208/ms.c:3061:		ms_card->seq_mode = 0;
./staging/rts5208/ms.c:3086:	if (ms_card->seq_mode) {
./staging/rts5208/ms.c:3087:		ms_card->pre_sec_addr = start_sector;
./staging/rts5208/ms.c:3088:		ms_card->pre_sec_cnt = sector_cnt;
./staging/rts5208/ms.c:3089:		ms_card->pre_dir = srb->sc_data_direction;
./staging/rts5208/ms.c:3090:		ms_card->total_sec_cnt += sector_cnt;
./staging/rts5208/ms.c:3110:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3117:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3125:			ms_card->format_status = FORMAT_SUCCESS;
./staging/rts5208/ms.c:3128:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3141:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3149:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3163:		ms_card->progress = 0;
./staging/rts5208/ms.c:3168:		ms_card->progress = (u16)ulltmp;
./staging/rts5208/ms.c:3170:	dev_dbg(rtsx_dev(chip), "progress = %d\n", ms_card->progress);
./staging/rts5208/ms.c:3175:			ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3188:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3194:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3200:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3206:		ms_card->format_status = FORMAT_SUCCESS;
./staging/rts5208/ms.c:3207:		ms_card->pro_under_formatting = 0;
./staging/rts5208/ms.c:3209:		ms_card->format_status = FORMAT_IN_PROGRESS;
./staging/rts5208/ms.c:3211:		ms_card->format_status = FORMAT_FAIL;
./staging/rts5208/ms.c:3212:		ms_card->pro_under_formatting = 0;
./staging/rts5208/ms.c:3225:	if (ms_card->pro_under_formatting &&
./staging/rts5208/ms.c:3231:			if (ms_card->format_status != FORMAT_IN_PROGRESS)
./staging/rts5208/ms.c:3308:		ms_card->pro_under_formatting = 1;
./staging/rts5208/ms.c:3309:		ms_card->progress = 0;
./staging/rts5208/ms.c:3310:		ms_card->format_status = FORMAT_IN_PROGRESS;
./staging/rts5208/ms.c:3315:		ms_card->pro_under_formatting = 0;
./staging/rts5208/ms.c:3316:		ms_card->progress = 0;
./staging/rts5208/ms.c:3317:		ms_card->format_status = FORMAT_SUCCESS;
./staging/rts5208/ms.c:3723:			    (page_addr == ms_card->page_off)) {
./staging/rts5208/ms.c:3747:			      page_off, ms_card->page_off + 1);
./staging/rts5208/ms.c:3790:	struct ms_delay_write_tag *delay_write = &ms_card->delay_write;
./staging/rts5208/ms.c:3836:	struct ms_delay_write_tag *delay_write = &ms_card->delay_write;
./staging/rts5208/ms.c:3841:	ms_card->cleanup_counter = 0;
./staging/rts5208/ms.c:3852:	log_blk = (u16)(start_sector >> ms_card->block_shift);
./staging/rts5208/ms.c:3853:	start_page = (u8)(start_sector & ms_card->page_off);
./staging/rts5208/ms.c:3860:	if (ms_card->segment[seg_no].build_flag == 0) {
./staging/rts5208/ms.c:3964:		if ((start_page + total_sec_cnt) > (ms_card->page_off + 1))
./staging/rts5208/ms.c:3965:			end_page = ms_card->page_off + 1;
./staging/rts5208/ms.c:4000:			if (end_page == (ms_card->page_off + 1)) {
./staging/rts5208/ms.c:4026:		if (ms_card->segment[seg_no].build_flag == 0) {
./staging/rts5208/ms.c:4061:		if (end_page < (ms_card->page_off + 1)) {
./staging/rts5208/ms.c:4115:	if (ms_card->segment) {
./staging/rts5208/ms.c:4116:		for (i = 0; i < ms_card->segment_cnt; i++) {
./staging/rts5208/ms.c:4117:			vfree(ms_card->segment[i].l2p_table);
./staging/rts5208/ms.c:4118:			ms_card->segment[i].l2p_table = NULL;
./staging/rts5208/ms.c:4119:			vfree(ms_card->segment[i].free_table);
./staging/rts5208/ms.c:4120:			ms_card->segment[i].free_table = NULL;
./staging/rts5208/ms.c:4122:		vfree(ms_card->segment);
./staging/rts5208/ms.c:4123:		ms_card->segment = NULL;
./staging/rts5208/ms.c:4405:	memcpy(ms_card->magic_gate_id, buf, 16);
./staging/rts5208/ms.c:4446:	ms_card->mg_auth = 0;
./staging/rts5208/ms.c:4493:	memcpy(buf2 + 4, ms_card->magic_gate_id, 16);
./staging/rts5208/ms.c:4558:	ms_card->mg_auth = 1;
./staging/rts5208/ms.c:4590:	retval = mg_send_ex_cmd(chip, MG_GET_IBD, ms_card->mg_entry_num);
./staging/rts5208/ms.c:4649:	retval = mg_send_ex_cmd(chip, MG_SET_IBD, ms_card->mg_entry_num);
./staging/rts5208/ms.c:4651:		if (ms_card->mg_auth == 0) {
./staging/rts5208/ms.c:4691:			if (ms_card->mg_auth == 0) {
./staging/rts5208/ms.c:4713:		if (ms_card->mg_auth == 0) {
./staging/rts5208/ms.c:4741:		if (ms_card->seq_mode) {
./staging/rts5208/ms.c:4744:			ms_card->cleanup_counter = 0;
./staging/rts5208/ms.c:4753:		 ms_card->delay_write.delay_write_flag) {
./staging/rts5208/ms.c:4756:		ms_card->cleanup_counter = 0;
./staging/rts5208/ms.c:4808:	ms_card->delay_write.delay_write_flag = 0;
./staging/rts5208/ms.c:4810:	ms_card->pro_under_formatting = 0;
./staging/rts5208/ms.c:4818:	memset(ms_card->raw_sys_info, 0, 96);
./staging/rts5208/ms.c:4820:	memset(ms_card->raw_model_name, 0, 48);
./staging/rts5208/xd.c:42:	xd_card->err_code = err_code;
./staging/rts5208/xd.c:49:	return (xd_card->err_code == err_code);
./staging/rts5208/xd.c:58:		xd_card->xd_clock = 47;
./staging/rts5208/xd.c:60:		xd_card->xd_clock = CLK_50;
./staging/rts5208/xd.c:62:	retval = switch_clock(chip, xd_card->xd_clock);
./staging/rts5208/xd.c:82:	retval = switch_clock(chip, xd_card->xd_clock);
./staging/rts5208/xd.c:136:			     xd_card->addr_cycle |
./staging/rts5208/xd.c:148:			     (xd_card->addr_cycle - 1) | XD_CALC_ECC |
./staging/rts5208/xd.c:661:		xd_card->device_code = id_buf[1];
./staging/rts5208/xd.c:664:		switch (xd_card->device_code) {
./staging/rts5208/xd.c:667:			xd_card->block_shift = 4;
./staging/rts5208/xd.c:668:			xd_card->page_off = 0x0F;
./staging/rts5208/xd.c:669:			xd_card->addr_cycle = 3;
./staging/rts5208/xd.c:670:			xd_card->zone_cnt = 1;
./staging/rts5208/xd.c:671:			xd_card->capacity = 8000;
./staging/rts5208/xd.c:675:			xd_card->block_shift = 4;
./staging/rts5208/xd.c:676:			xd_card->page_off = 0x0F;
./staging/rts5208/xd.c:677:			xd_card->addr_cycle = 3;
./staging/rts5208/xd.c:678:			xd_card->zone_cnt = 1;
./staging/rts5208/xd.c:679:			xd_card->capacity = 16000;
./staging/rts5208/xd.c:683:			xd_card->addr_cycle = 3;
./staging/rts5208/xd.c:684:			xd_card->zone_cnt = 1;
./staging/rts5208/xd.c:685:			xd_card->capacity = 32000;
./staging/rts5208/xd.c:689:			xd_card->addr_cycle = 3;
./staging/rts5208/xd.c:690:			xd_card->zone_cnt = 2;
./staging/rts5208/xd.c:691:			xd_card->capacity = 64000;
./staging/rts5208/xd.c:695:			xd_card->addr_cycle = 4;
./staging/rts5208/xd.c:696:			xd_card->zone_cnt = 4;
./staging/rts5208/xd.c:697:			xd_card->capacity = 128000;
./staging/rts5208/xd.c:701:			xd_card->addr_cycle = 4;
./staging/rts5208/xd.c:702:			xd_card->zone_cnt = 8;
./staging/rts5208/xd.c:703:			xd_card->capacity = 256000;
./staging/rts5208/xd.c:707:			xd_card->addr_cycle = 4;
./staging/rts5208/xd.c:708:			xd_card->zone_cnt = 16;
./staging/rts5208/xd.c:709:			xd_card->capacity = 512000;
./staging/rts5208/xd.c:713:			xd_card->addr_cycle = 4;
./staging/rts5208/xd.c:714:			xd_card->zone_cnt = 32;
./staging/rts5208/xd.c:715:			xd_card->capacity = 1024000;
./staging/rts5208/xd.c:719:			xd_card->addr_cycle = 4;
./staging/rts5208/xd.c:720:			xd_card->zone_cnt = 64;
./staging/rts5208/xd.c:721:			xd_card->capacity = 2048000;
./staging/rts5208/xd.c:725:			xd_card->addr_cycle = 4;
./staging/rts5208/xd.c:726:			xd_card->zone_cnt = 128;
./staging/rts5208/xd.c:727:			xd_card->capacity = 4096000;
./staging/rts5208/xd.c:741:			if (id_buf[1] != xd_card->device_code)
./staging/rts5208/xd.c:750:		xd_card->block_shift = 0;
./staging/rts5208/xd.c:751:		xd_card->page_off = 0;
./staging/rts5208/xd.c:752:		xd_card->addr_cycle = 0;
./staging/rts5208/xd.c:753:		xd_card->capacity = 0;
./staging/rts5208/xd.c:780:		page_addr = (u32)i << xd_card->block_shift;
./staging/rts5208/xd.c:827:				xd_card->cis_block = (u16)i;
./staging/rts5208/xd.c:834:	dev_dbg(rtsx_dev(chip), "CIS block: 0x%x\n", xd_card->cis_block);
./staging/rts5208/xd.c:835:	if (xd_card->cis_block == 0xFFFF) {
./staging/rts5208/xd.c:840:	chip->capacity[chip->card2lun[XD_CARD]] = xd_card->capacity;
./staging/rts5208/xd.c:889:		xd_card->zone_cnt);
./staging/rts5208/xd.c:891:	if (xd_card->zone_cnt < 1) {
./staging/rts5208/xd.c:896:	size = xd_card->zone_cnt * sizeof(struct zone_entry);
./staging/rts5208/xd.c:899:	xd_card->zone = vmalloc(size);
./staging/rts5208/xd.c:900:	if (!xd_card->zone) {
./staging/rts5208/xd.c:905:	for (i = 0; i < xd_card->zone_cnt; i++) {
./staging/rts5208/xd.c:906:		xd_card->zone[i].build_flag = 0;
./staging/rts5208/xd.c:907:		xd_card->zone[i].l2p_table = NULL;
./staging/rts5208/xd.c:908:		xd_card->zone[i].free_table = NULL;
./staging/rts5208/xd.c:909:		xd_card->zone[i].get_index = 0;
./staging/rts5208/xd.c:910:		xd_card->zone[i].set_index = 0;
./staging/rts5208/xd.c:911:		xd_card->zone[i].unused_blk_cnt = 0;
./staging/rts5208/xd.c:939:	if (zone_no >= xd_card->zone_cnt) {
./staging/rts5208/xd.c:941:			zone_no, xd_card->zone_cnt);
./staging/rts5208/xd.c:944:	zone = &xd_card->zone[zone_no];
./staging/rts5208/xd.c:973:	if (zone_no >= xd_card->zone_cnt) {
./staging/rts5208/xd.c:975:			zone_no, xd_card->zone_cnt);
./staging/rts5208/xd.c:978:	zone = &xd_card->zone[zone_no];
./staging/rts5208/xd.c:1011:	zone = &xd_card->zone[zone_no];
./staging/rts5208/xd.c:1021:	zone = &xd_card->zone[zone_no];
./staging/rts5208/xd.c:1048:					      0, xd_card->page_off + 1);
./staging/rts5208/xd.c:1071:	xd_card->block_shift = 0;
./staging/rts5208/xd.c:1072:	xd_card->page_off = 0;
./staging/rts5208/xd.c:1073:	xd_card->addr_cycle = 0;
./staging/rts5208/xd.c:1074:	xd_card->capacity = 0;
./staging/rts5208/xd.c:1075:	xd_card->zone_cnt = 0;
./staging/rts5208/xd.c:1076:	xd_card->cis_block = 0xFFFF;
./staging/rts5208/xd.c:1077:	xd_card->delay_write.delay_write_flag = 0;
./staging/rts5208/xd.c:1127:	page_addr = phy_blk << xd_card->block_shift;
./staging/rts5208/xd.c:1132:		     xd_card->page_off + 1);
./staging/rts5208/xd.c:1181:	page_addr = (phy_blk << xd_card->block_shift) + start_page;
./staging/rts5208/xd.c:1234:	old_page = (old_blk << xd_card->block_shift) + start_page;
./staging/rts5208/xd.c:1235:	new_page = (new_blk << xd_card->block_shift) + start_page;
./staging/rts5208/xd.c:1379:	page_addr = phy_blk << xd_card->block_shift;
./staging/rts5208/xd.c:1440:	if (!xd_card->zone) {
./staging/rts5208/xd.c:1446:	if (xd_card->zone[zone_no].build_flag) {
./staging/rts5208/xd.c:1452:	zone = &xd_card->zone[zone_no];
./staging/rts5208/xd.c:1473:		if (xd_card->cis_block == 0xFFFF)
./staging/rts5208/xd.c:1476:			start = xd_card->cis_block + 1;
./staging/rts5208/xd.c:1498:		u32 page_addr = i << xd_card->block_shift;
./staging/rts5208/xd.c:1537:		page_addr = ((i + 1) << xd_card->block_shift) - 1;
./staging/rts5208/xd.c:1548:				xd_card->block_shift) - 1;
./staging/rts5208/xd.c:1659:			page_addr = ((u32)i) << xd_card->block_shift;
./staging/rts5208/xd.c:1672:	page_addr = (phy_blk << xd_card->block_shift) + start_page;
./staging/rts5208/xd.c:1748:				      xd_card->page_off + 1);
./staging/rts5208/xd.c:1783:	if (page_off > xd_card->page_off) {
./staging/rts5208/xd.c:1793:				      page_off, xd_card->page_off + 1);
./staging/rts5208/xd.c:1803:				      page_off, xd_card->page_off + 1);
./staging/rts5208/xd.c:1874:	page_addr = (new_blk << xd_card->block_shift) + start_page;
./staging/rts5208/xd.c:1920:	if (end_page == (xd_card->page_off + 1)) {
./staging/rts5208/xd.c:1921:		xd_card->delay_write.delay_write_flag = 0;
./staging/rts5208/xd.c:1962:	struct xd_delay_write_tag *delay_write = &xd_card->delay_write;
./staging/rts5208/xd.c:1995:	struct xd_delay_write_tag *delay_write = &xd_card->delay_write;
./staging/rts5208/xd.c:2006:	xd_card->cleanup_counter = 0;
./staging/rts5208/xd.c:2026:	log_blk = start_sector >> xd_card->block_shift;
./staging/rts5208/xd.c:2027:	start_page = (u8)start_sector & xd_card->page_off;
./staging/rts5208/xd.c:2031:	if (xd_card->zone[zone_no].build_flag == 0) {
./staging/rts5208/xd.c:2141:		if ((start_page + total_sec_cnt) > (xd_card->page_off + 1))
./staging/rts5208/xd.c:2142:			end_page = xd_card->page_off + 1;
./staging/rts5208/xd.c:2181:		if (xd_card->zone[zone_no].build_flag == 0) {
./staging/rts5208/xd.c:2219:	    (end_page != (xd_card->page_off + 1))) {
./staging/rts5208/xd.c:2260:	if (xd_card->zone) {
./staging/rts5208/xd.c:2261:		for (i = 0; i < xd_card->zone_cnt; i++) {
./staging/rts5208/xd.c:2262:			vfree(xd_card->zone[i].l2p_table);
./staging/rts5208/xd.c:2263:			xd_card->zone[i].l2p_table = NULL;
./staging/rts5208/xd.c:2264:			vfree(xd_card->zone[i].free_table);
./staging/rts5208/xd.c:2265:			xd_card->zone[i].free_table = NULL;
./staging/rts5208/xd.c:2267:		vfree(xd_card->zone);
./staging/rts5208/xd.c:2268:		xd_card->zone = NULL;
./staging/rts5208/xd.c:2277:	if (xd_card->delay_write.delay_write_flag) {
./staging/rts5208/xd.c:2280:		xd_card->cleanup_counter = 0;
./staging/rts5208/xd.c:2337:	xd_card->delay_write.delay_write_flag = 0;
./staging/rts5208/rtsx_card.h:1036:	    (sd_card->sd_lock_status & SD_LOCKED))
./staging/rts5208/rtsx_chip.c:1166:	if (!sd_card->sd_erase_status)
./staging/rts5208/rtsx_chip.c:1172:			sd_card->sd_erase_status = SD_NOT_ERASE;
./staging/rts5208/rtsx_chip.c:1173:			sd_card->sd_lock_notify = 1;
./staging/rts5208/rtsx_chip.c:1177:		sd_card->sd_erase_status = SD_NOT_ERASE;
./staging/rts5208/rtsx.c:518:	sd_card->cleanup_counter = 0;
./staging/rts5208/rtsx.c:519:	xd_card->cleanup_counter = 0;
./staging/rts5208/rtsx.c:520:	ms_card->cleanup_counter = 0;
./staging/rts5208/rtsx_card.c:43:		if (sd_card->seq_mode) {
./staging/rts5208/rtsx_card.c:45:			sd_card->cleanup_counter++;
./staging/rts5208/rtsx_card.c:47:			sd_card->cleanup_counter = 0;
./staging/rts5208/rtsx_card.c:53:		if (xd_card->delay_write.delay_write_flag) {
./staging/rts5208/rtsx_card.c:55:			xd_card->cleanup_counter++;
./staging/rts5208/rtsx_card.c:57:			xd_card->cleanup_counter = 0;
./staging/rts5208/rtsx_card.c:64:			if (ms_card->seq_mode) {
./staging/rts5208/rtsx_card.c:66:				ms_card->cleanup_counter++;
./staging/rts5208/rtsx_card.c:68:				ms_card->cleanup_counter = 0;
./staging/rts5208/rtsx_card.c:72:			if (ms_card->delay_write.delay_write_flag) {
./staging/rts5208/rtsx_card.c:74:				ms_card->cleanup_counter++;
./staging/rts5208/rtsx_card.c:76:				ms_card->cleanup_counter = 0;
./staging/rts5208/rtsx_card.c:82:	if (sd_card->cleanup_counter > POLLING_WAIT_CNT)
./staging/rts5208/rtsx_card.c:85:	if (xd_card->cleanup_counter > POLLING_WAIT_CNT)
./staging/rts5208/rtsx_card.c:88:	if (ms_card->cleanup_counter > POLLING_WAIT_CNT)
./staging/rts5208/rtsx_scsi.c:441:		if (sd_card->sd_lock_notify) {
./staging/rts5208/rtsx_scsi.c:442:			sd_card->sd_lock_notify = 0;
./staging/rts5208/rtsx_scsi.c:445:		} else if (sd_card->sd_lock_status & SD_LOCKED) {
./staging/rts5208/rtsx_scsi.c:624:	    ms_card->pro_under_formatting) {
./staging/rts5208/rtsx_scsi.c:625:		if (ms_card->format_status == FORMAT_SUCCESS) {
./staging/rts5208/rtsx_scsi.c:627:			ms_card->pro_under_formatting = 0;
./staging/rts5208/rtsx_scsi.c:628:			ms_card->progress = 0;
./staging/rts5208/rtsx_scsi.c:629:		} else if (ms_card->format_status == FORMAT_IN_PROGRESS) {
./staging/rts5208/rtsx_scsi.c:632:				       0, (u16)(ms_card->progress));
./staging/rts5208/rtsx_scsi.c:636:			ms_card->pro_under_formatting = 0;
./staging/rts5208/rtsx_scsi.c:637:			ms_card->progress = 0;
./staging/rts5208/rtsx_scsi.c:750:		memcpy(buf + sys_info_offset, ms_card->raw_sys_info, len);
./staging/rts5208/rtsx_scsi.c:885:	if (sd_card->sd_erase_status) {
./staging/rts5208/rtsx_scsi.c:896:		if (sd_card->sd_lock_status & SD_LOCKED) {
./staging/rts5208/rtsx_scsi.c:1366:	rtsx_stor_set_xfer_buf(sd_card->raw_csd, scsi_bufflen(srb), srb);
./staging/rts5208/rtsx_scsi.c:1532:			xd_card->xd_clock = srb->cmnd[5];
./staging/rts5208/rtsx_scsi.c:1536:			sd_card->sd_clock = srb->cmnd[5];
./staging/rts5208/rtsx_scsi.c:1540:			ms_card->ms_clock = srb->cmnd[5];
./staging/rts5208/rtsx_scsi.c:1597:			tmp = (u8)(xd_card->xd_clock);
./staging/rts5208/rtsx_scsi.c:1601:			tmp = (u8)(sd_card->sd_clock);
./staging/rts5208/rtsx_scsi.c:1605:			tmp = (u8)(ms_card->ms_clock);
./staging/rts5208/rtsx_scsi.c:1723:				if (sd_card->capacity > 0x4000000)
./staging/rts5208/rtsx_scsi.c:1773:		if (sd_card->sd_erase_status)
./staging/rts5208/rtsx_scsi.c:1775:		if (sd_card->sd_lock_status & SD_LOCKED) {
./staging/rts5208/rtsx_scsi.c:1779:		if (sd_card->sd_lock_status & SD_PWD_EXIST)
./staging/rts5208/rtsx_scsi.c:3077:		memcpy(buf + i, ms_card->raw_sys_info, 96);
./staging/rts5208/rtsx_scsi.c:3080:		memcpy(buf + i, ms_card->raw_model_name, 48);
./staging/rts5208/rtsx_scsi.c:3253:		ms_card->mg_entry_num = srb->cmnd[5];
./staging/rts5208/rtsx_scsi.c:3389:		ms_card->mg_entry_num = srb->cmnd[5];
./staging/rts5208/rtsx_scsi.c:3432:	if (sd_card->sd_erase_status) {
./staging/rts5208/rtsx_scsi.c:3450:	    (ms_card->format_status == FORMAT_IN_PROGRESS)) {
./staging/rts5208/rtsx_scsi.c:3455:				       0, (u16)(ms_card->progress));
./staging/rts5208/sd.c:61:	sd_card->err_code |= err_code;
./staging/rts5208/sd.c:68:	sd_card->err_code = 0;
./staging/rts5208/sd.c:75:	return sd_card->err_code & err_code;
./staging/rts5208/sd.c:272:				sd_card->sd_data_buf_ready = 1;
./staging/rts5208/sd.c:274:				sd_card->sd_data_buf_ready = 0;
./staging/rts5208/sd.c:337:			sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:415:			sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:441:		retval = sd_send_cmd_get_rsp(chip, SEND_CSD, sd_card->sd_addr,
./staging/rts5208/sd.c:452:	memcpy(sd_card->raw_csd, rsp + 1, 15);
./staging/rts5208/sd.c:455:	dev_dbg(rtsx_dev(chip), "%*ph\n", 16, sd_card->raw_csd);
./staging/rts5208/sd.c:464:				sd_card->sd_clock = 47;
./staging/rts5208/sd.c:466:				sd_card->sd_clock = CLK_50;
./staging/rts5208/sd.c:470:				sd_card->sd_clock = 39;
./staging/rts5208/sd.c:472:				sd_card->sd_clock = CLK_40;
./staging/rts5208/sd.c:476:				sd_card->sd_clock = 29;
./staging/rts5208/sd.c:478:				sd_card->sd_clock = CLK_30;
./staging/rts5208/sd.c:482:				sd_card->sd_clock = 23;
./staging/rts5208/sd.c:484:				sd_card->sd_clock = CLK_20;
./staging/rts5208/sd.c:488:				sd_card->sd_clock = 19;
./staging/rts5208/sd.c:490:				sd_card->sd_clock = CLK_20;
./staging/rts5208/sd.c:501:		sd_card->capacity = 0;
./staging/rts5208/sd.c:513:			sd_card->capacity = (((u32)(c_size + 1)) *
./staging/rts5208/sd.c:521:			sd_card->capacity = (total_sector + 1) << 10;
./staging/rts5208/sd.c:581:			sd_card->sd_clock = chip->asic_sd_sdr104_clk;
./staging/rts5208/sd.c:583:			sd_card->sd_clock = chip->fpga_sd_sdr104_clk;
./staging/rts5208/sd.c:587:			sd_card->sd_clock = chip->asic_sd_ddr50_clk;
./staging/rts5208/sd.c:589:			sd_card->sd_clock = chip->fpga_sd_ddr50_clk;
./staging/rts5208/sd.c:593:			sd_card->sd_clock = chip->asic_sd_sdr50_clk;
./staging/rts5208/sd.c:595:			sd_card->sd_clock = chip->fpga_sd_sdr50_clk;
./staging/rts5208/sd.c:599:			sd_card->sd_clock = chip->asic_sd_hs_clk;
./staging/rts5208/sd.c:601:			sd_card->sd_clock = chip->fpga_sd_hs_clk;
./staging/rts5208/sd.c:605:			sd_card->sd_clock = chip->asic_mmc_52m_clk;
./staging/rts5208/sd.c:607:			sd_card->sd_clock = chip->fpga_mmc_52m_clk;
./staging/rts5208/sd.c:611:			sd_card->sd_clock = 48;
./staging/rts5208/sd.c:613:			sd_card->sd_clock = CLK_50;
./staging/rts5208/sd.c:652:	retval = switch_clock(chip, sd_card->sd_clock);
./staging/rts5208/sd.c:671:		addr = sd_card->sd_addr;
./staging/rts5208/sd.c:694:	retval = sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:702:		sd_card->sd_lock_status |= SD_LOCKED;
./staging/rts5208/sd.c:704:		sd_card->sd_lock_status &= ~SD_LOCKED;
./staging/rts5208/sd.c:706:	dev_dbg(rtsx_dev(chip), "sd_card->sd_lock_status = 0x%x\n",
./staging/rts5208/sd.c:707:		sd_card->sd_lock_status);
./staging/rts5208/sd.c:727:					     sd_card->sd_addr, SD_RSP_TYPE_R1,
./staging/rts5208/sd.c:1071:	retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./staging/rts5208/sd.c:1092:	memcpy(sd_card->raw_scr, buf, 8);
./staging/rts5208/sd.c:1264:		sd_card->func_group1_mask = buf[0x0D];
./staging/rts5208/sd.c:1265:		sd_card->func_group2_mask = buf[0x0B];
./staging/rts5208/sd.c:1266:		sd_card->func_group3_mask = buf[0x09];
./staging/rts5208/sd.c:1267:		sd_card->func_group4_mask = buf[0x07];
./staging/rts5208/sd.c:1401:	sd_card->func_group1_mask &= ~(sd_card->sd_switch_fail);
./staging/rts5208/sd.c:1407:			if ((sd_card->func_group1_mask & SDR104_SUPPORT_MASK) &&
./staging/rts5208/sd.c:1414:			if ((sd_card->func_group1_mask & DDR50_SUPPORT_MASK) &&
./staging/rts5208/sd.c:1421:			if ((sd_card->func_group1_mask & SDR50_SUPPORT_MASK) &&
./staging/rts5208/sd.c:1428:			if (sd_card->func_group1_mask & HS_SUPPORT_MASK)
./staging/rts5208/sd.c:1444:	if ((sd_card->sd_lock_status & SD_SDR_RST) &&
./staging/rts5208/sd.c:1446:	    (sd_card->func_group1_mask & SDR50_SUPPORT_MASK)) {
./staging/rts5208/sd.c:1457:				sd_card->sd_switch_fail = SDR104_SUPPORT_MASK;
./staging/rts5208/sd.c:1459:				sd_card->sd_switch_fail = SDR104_SUPPORT_MASK |
./staging/rts5208/sd.c:1462:				sd_card->sd_switch_fail = SDR104_SUPPORT_MASK |
./staging/rts5208/sd.c:1506:			if (sd_card->func_group4_mask & CURRENT_LIMIT_800_MASK)
./staging/rts5208/sd.c:1512:			if (sd_card->func_group4_mask & CURRENT_LIMIT_600_MASK)
./staging/rts5208/sd.c:1518:			if (sd_card->func_group4_mask & CURRENT_LIMIT_400_MASK)
./staging/rts5208/sd.c:1524:			if (sd_card->func_group4_mask & CURRENT_LIMIT_200_MASK)
./staging/rts5208/sd.c:1631:	retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./staging/rts5208/sd.c:1715:	retval = sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:1779:			       bus_width, sd_card->raw_csd, 16, 100);
./staging/rts5208/sd.c:1794:	sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr, SD_RSP_TYPE_R1,
./staging/rts5208/sd.c:2010:					     sd_card->sd_addr, SD_RSP_TYPE_R1,
./staging/rts5208/sd.c:2211:	retval = switch_clock(chip, sd_card->sd_clock);
./staging/rts5208/sd.c:2243:		sd_card->sd_clock = 29;
./staging/rts5208/sd.c:2245:		sd_card->sd_clock = CLK_30;
./staging/rts5208/sd.c:2247:	sd_card->sd_type = 0;
./staging/rts5208/sd.c:2248:	sd_card->seq_mode = 0;
./staging/rts5208/sd.c:2249:	sd_card->sd_data_buf_ready = 0;
./staging/rts5208/sd.c:2250:	sd_card->capacity = 0;
./staging/rts5208/sd.c:2253:	sd_card->sd_lock_status = 0;
./staging/rts5208/sd.c:2254:	sd_card->sd_erase_status = 0;
./staging/rts5208/sd.c:2531:	retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./staging/rts5208/sd.c:2549:		sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:2596:	if (sd_card->sd_lock_status & SD_UNLOCK_POW_ON)
./staging/rts5208/sd.c:2732:		sd_card->sd_addr = (u32)rsp[1] << 24;
./staging/rts5208/sd.c:2733:		sd_card->sd_addr += (u32)rsp[2] << 16;
./staging/rts5208/sd.c:2735:		if (sd_card->sd_addr)
./staging/rts5208/sd.c:2753:	if (sd_card->sd_lock_status & SD_LOCKED) {
./staging/rts5208/sd.c:2754:		sd_card->sd_lock_status |= (SD_LOCK_1BIT_MODE | SD_PWD_EXIST);
./staging/rts5208/sd.c:2756:	} else if (!(sd_card->sd_lock_status & SD_UNLOCK_POW_ON)) {
./staging/rts5208/sd.c:2757:		sd_card->sd_lock_status &= ~SD_PWD_EXIST;
./staging/rts5208/sd.c:2761:	retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./staging/rts5208/sd.c:2772:		retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./staging/rts5208/sd.c:2796:	if (!(sd_card->raw_csd[4] & 0x40))
./staging/rts5208/sd.c:2804:			sd_card->sd_switch_fail = SDR104_SUPPORT_MASK |
./staging/rts5208/sd.c:2831:		retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./staging/rts5208/sd.c:2843:	sd_card->sd_lock_status &= ~SD_LOCK_1BIT_MODE;
./staging/rts5208/sd.c:2879:		sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:2913:	if (sd_card->sd_lock_status & SD_UNLOCK_POW_ON) {
./staging/rts5208/sd.c:3109:			sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:3118:		sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:3125:		sd_card->capacity = ((u32)ptr[5] << 24) | ((u32)ptr[4] << 16) |
./staging/rts5208/sd.c:3152:	retval = switch_clock(chip, sd_card->sd_clock);
./staging/rts5208/sd.c:3164:		sd_card->sd_lock_status &= ~SD_LOCK_1BIT_MODE;
./staging/rts5208/sd.c:3172:			sd_card->sd_lock_status &= ~SD_LOCK_1BIT_MODE;
./staging/rts5208/sd.c:3199:	if (sd_card->sd_lock_status & SD_UNLOCK_POW_ON)
./staging/rts5208/sd.c:3274:	sd_card->sd_addr = 0x00100000;
./staging/rts5208/sd.c:3275:	retval = sd_send_cmd_get_rsp(chip, SET_RELATIVE_ADDR, sd_card->sd_addr,
./staging/rts5208/sd.c:3288:	spec_ver = (sd_card->raw_csd[0] & 0x3C) >> 2;
./staging/rts5208/sd.c:3320:	if (!sd_card->mmc_dont_switch_bus) {
./staging/rts5208/sd.c:3330:				sd_card->mmc_dont_switch_bus = 1;
./staging/rts5208/sd.c:3336:		if (CHK_MMC_SECTOR_MODE(sd_card) && (sd_card->capacity == 0)) {
./staging/rts5208/sd.c:3380:	if (sd_card->sd_lock_status & SD_UNLOCK_POW_ON) {
./staging/rts5208/sd.c:3504:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity;
./staging/rts5208/sd.c:3512:	dev_dbg(rtsx_dev(chip), "sd_card->sd_type = 0x%x\n", sd_card->sd_type);
./staging/rts5208/sd.c:3522:	sd_card->sd_type = 0;
./staging/rts5208/sd.c:3523:	sd_card->seq_mode = 0;
./staging/rts5208/sd.c:3524:	sd_card->sd_data_buf_ready = 0;
./staging/rts5208/sd.c:3525:	sd_card->capacity = 0;
./staging/rts5208/sd.c:3526:	sd_card->sd_switch_fail = 0;
./staging/rts5208/sd.c:3529:	sd_card->sd_lock_status = 0;
./staging/rts5208/sd.c:3530:	sd_card->sd_erase_status = 0;
./staging/rts5208/sd.c:3533:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity = 0;
./staging/rts5208/sd.c:3570:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity;
./staging/rts5208/sd.c:3578:	dev_dbg(rtsx_dev(chip), "In %s, sd_card->sd_type = 0x%x\n",
./staging/rts5208/sd.c:3579:		__func__, sd_card->sd_type);
./staging/rts5208/sd.c:3598:		sd_card->sd_data_buf_ready = 0;
./staging/rts5208/sd.c:3601:					     sd_card->sd_addr, SD_RSP_TYPE_R1,
./staging/rts5208/sd.c:3608:		if (sd_card->sd_data_buf_ready) {
./staging/rts5208/sd.c:3610:				sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./staging/rts5208/sd.c:3625:	if (sd_card->seq_mode) {
./staging/rts5208/sd.c:3639:		sd_card->seq_mode = 0;
./staging/rts5208/sd.c:3651:		if (sd_card->sd_clock > 30)
./staging/rts5208/sd.c:3652:			sd_card->sd_clock -= 20;
./staging/rts5208/sd.c:3654:		switch (sd_card->sd_clock) {
./staging/rts5208/sd.c:3656:			sd_card->sd_clock = CLK_150;
./staging/rts5208/sd.c:3660:			sd_card->sd_clock = CLK_120;
./staging/rts5208/sd.c:3664:			sd_card->sd_clock = CLK_100;
./staging/rts5208/sd.c:3668:			sd_card->sd_clock = CLK_80;
./staging/rts5208/sd.c:3672:			sd_card->sd_clock = CLK_60;
./staging/rts5208/sd.c:3676:			sd_card->sd_clock = CLK_50;
./staging/rts5208/sd.c:3711:	sd_card->cleanup_counter = 0;
./staging/rts5208/sd.c:3714:		sd_card->seq_mode = 0;
./staging/rts5208/sd.c:3744:	if (sd_card->seq_mode &&
./staging/rts5208/sd.c:3745:	    ((sd_card->pre_dir != srb->sc_data_direction) ||
./staging/rts5208/sd.c:3746:	    ((sd_card->pre_sec_addr + sd_card->pre_sec_cnt) !=
./staging/rts5208/sd.c:3748:		if ((sd_card->pre_sec_cnt < 0x80) &&
./staging/rts5208/sd.c:3749:		    (sd_card->pre_dir == DMA_FROM_DEVICE) &&
./staging/rts5208/sd.c:3753:			sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:3766:		sd_card->seq_mode = 0;
./staging/rts5208/sd.c:3775:		if ((sd_card->pre_sec_cnt < 0x80) &&
./staging/rts5208/sd.c:3779:			sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./staging/rts5208/sd.c:3805:	if (sd_card->seq_mode) {
./staging/rts5208/sd.c:3903:		sd_card->seq_mode = 1;
./staging/rts5208/sd.c:3913:		sd_card->seq_mode = 0;
./staging/rts5208/sd.c:3957:	sd_card->pre_sec_addr = start_sector;
./staging/rts5208/sd.c:3958:	sd_card->pre_sec_cnt = sector_cnt;
./staging/rts5208/sd.c:3959:	sd_card->pre_dir = srb->sc_data_direction;
./staging/rts5208/sd.c:3964:	sd_card->seq_mode = 0;
./staging/rts5208/sd.c:3975:			sd_card->mmc_dont_switch_bus = 1;
./staging/rts5208/sd.c:3977:			sd_card->mmc_dont_switch_bus = 0;
./staging/rts5208/sd.c:3979:			sd_card->need_retune = 1;
./staging/rts5208/sd.c:4208:	sd_card->pre_cmd_err = 0;
./staging/rts5208/sd.c:4228:		sd_card->sd_pass_thru_en = 0;
./staging/rts5208/sd.c:4232:		sd_card->sd_pass_thru_en = 1;
./staging/rts5208/sd.c:4245:	buf[6] = (u8)(sd_card->sd_addr >> 16);
./staging/rts5208/sd.c:4246:	buf[7] = (u8)(sd_card->sd_addr >> 24);
./staging/rts5208/sd.c:4304:	if (!sd_card->sd_pass_thru_en) {
./staging/rts5208/sd.c:4316:	if (sd_card->pre_cmd_err) {
./staging/rts5208/sd.c:4317:		sd_card->pre_cmd_err = 0;
./staging/rts5208/sd.c:4339:	sd_card->last_rsp_type = rsp_type;
./staging/rts5208/sd.c:4348:	if ((sd_card->sd_lock_status & SD_LOCK_1BIT_MODE) == 0) {
./staging/rts5208/sd.c:4384:						 sd_card->sd_addr,
./staging/rts5208/sd.c:4394:					 sd_card->rsp, rsp_len, false);
./staging/rts5208/sd.c:4420:	sd_card->pre_cmd_err = 1;
./staging/rts5208/sd.c:4441:	if (!sd_card->sd_pass_thru_en) {
./staging/rts5208/sd.c:4447:	if (sd_card->pre_cmd_err) {
./staging/rts5208/sd.c:4448:		sd_card->pre_cmd_err = 0;
./staging/rts5208/sd.c:4479:	sd_card->last_rsp_type = rsp_type;
./staging/rts5208/sd.c:4488:	if ((sd_card->sd_lock_status & SD_LOCK_1BIT_MODE) == 0) {
./staging/rts5208/sd.c:4523:						 sd_card->sd_addr,
./staging/rts5208/sd.c:4618:	retval = ext_sd_get_rsp(chip, rsp_len, sd_card->rsp, rsp_type);
./staging/rts5208/sd.c:4669:						 sd_card->sd_addr,
./staging/rts5208/sd.c:4684:	sd_card->pre_cmd_err = 1;
./staging/rts5208/sd.c:4713:	if (!sd_card->sd_pass_thru_en) {
./staging/rts5208/sd.c:4719:	if (sd_card->pre_cmd_err) {
./staging/rts5208/sd.c:4720:		sd_card->pre_cmd_err = 0;
./staging/rts5208/sd.c:4749:		sd_lock_state = sd_card->sd_lock_status;
./staging/rts5208/sd.c:4760:	sd_card->last_rsp_type = rsp_type;
./staging/rts5208/sd.c:4769:	if ((sd_card->sd_lock_status & SD_LOCK_1BIT_MODE) == 0) {
./staging/rts5208/sd.c:4815:						 sd_card->sd_addr,
./staging/rts5208/sd.c:4825:					 sd_card->rsp, rsp_len, false);
./staging/rts5208/sd.c:4948:			sd_card->sd_erase_status = SD_UNDER_ERASING;
./staging/rts5208/sd.c:5011:						 sd_card->sd_addr,
./staging/rts5208/sd.c:5028:				sd_card->sd_lock_status &= ~SD_PWD_EXIST;
./staging/rts5208/sd.c:5031:				sd_card->sd_lock_status |= SD_PWD_EXIST;
./staging/rts5208/sd.c:5034:		dev_dbg(rtsx_dev(chip), "sd_lock_state = 0x%x, sd_card->sd_lock_status = 0x%x\n",
./staging/rts5208/sd.c:5035:			sd_lock_state, sd_card->sd_lock_status);
./staging/rts5208/sd.c:5036:		if (sd_lock_state ^ (sd_card->sd_lock_status & SD_LOCKED)) {
./staging/rts5208/sd.c:5037:			sd_card->sd_lock_notify = 1;
./staging/rts5208/sd.c:5039:				if (sd_card->sd_lock_status & SD_LOCK_1BIT_MODE) {
./staging/rts5208/sd.c:5040:					sd_card->sd_lock_status |= (
./staging/rts5208/sd.c:5045:							sd_card->sd_lock_status &= ~(SD_UNLOCK_POW_ON | SD_SDR_RST);
./staging/rts5208/sd.c:5051:					sd_card->sd_lock_status &= ~(SD_UNLOCK_POW_ON | SD_SDR_RST);
./staging/rts5208/sd.c:5069:	sd_card->pre_cmd_err = 1;
./staging/rts5208/sd.c:5090:	if (!sd_card->sd_pass_thru_en) {
./staging/rts5208/sd.c:5096:	if (sd_card->pre_cmd_err) {
./staging/rts5208/sd.c:5097:		sd_card->pre_cmd_err = 0;
./staging/rts5208/sd.c:5105:	if (sd_card->last_rsp_type == SD_RSP_TYPE_R0) {
./staging/rts5208/sd.c:5109:	} else if (sd_card->last_rsp_type == SD_RSP_TYPE_R2) {
./staging/rts5208/sd.c:5114:	rtsx_stor_set_xfer_buf(sd_card->rsp, count, srb);
./staging/rts5208/sd.c:5118:		sd_card->rsp[0], sd_card->rsp[1],
./staging/rts5208/sd.c:5119:		sd_card->rsp[2], sd_card->rsp[3]);
./staging/rts5208/sd.c:5131:	if (!sd_card->sd_pass_thru_en) {
./staging/rts5208/sd.c:5137:	if (sd_card->pre_cmd_err) {
./staging/rts5208/sd.c:5138:		sd_card->pre_cmd_err = 0;
./staging/rts5208/sd.c:5157:			sd_card->sd_lock_status |= SD_SDR_RST;
./staging/rts5208/sd.c:5162:			sd_card->sd_lock_status &= ~SD_SDR_RST;
./staging/rts5208/sd.c:5165:			sd_card->pre_cmd_err = 1;
./staging/rts5208/sd.c:5170:		sd_card->sd_lock_status &= ~SD_SDR_RST;
./staging/rts5208/sd.c:5178:			sd_card->pre_cmd_err = 1;
./staging/rts5208/sd.c:5199:	if (sd_card->seq_mode) {
./staging/rts5208/sd.c:5202:		sd_card->cleanup_counter = 0;
./staging/rts5208/sd.c:5264:	sd_card->sd_lock_status = 0;
./staging/rts5208/sd.c:5265:	sd_card->sd_erase_status = 0;
./staging/rts5208/sd.c:5268:	memset(sd_card->raw_csd, 0, 16);
./staging/rts5208/sd.c:5269:	memset(sd_card->raw_scr, 0, 8);
./staging/vme/devices/vme_pio2_cntr.c:29:	data = PIO2_CNTR_SC_DEV[id] | PIO2_CNTR_RW_BOTH | card->cntr[id].mode;
./staging/vme/devices/vme_pio2_cntr.c:30:	retval = vme_master_write(card->window, &data, 1, PIO2_CNTR_CTRL[id]);
./staging/vme/devices/vme_pio2_cntr.c:34:	data = card->cntr[id].count & 0xFF;
./staging/vme/devices/vme_pio2_cntr.c:35:	retval = vme_master_write(card->window, &data, 1, PIO2_CNTR_DATA[id]);
./staging/vme/devices/vme_pio2_cntr.c:39:	data = (card->cntr[id].count >> 8) & 0xFF;
./staging/vme/devices/vme_pio2_cntr.c:40:	retval = vme_master_write(card->window, &data, 1, PIO2_CNTR_DATA[id]);
./staging/vme/devices/vme_pio2_cntr.c:54:		card->cntr[i].mode = PIO2_CNTR_MODE5;
./staging/vme/devices/vme_pio2_cntr.c:55:		card->cntr[i].count = 0;
./staging/vme/devices/vme_pio2_cntr.c:63:		retval = vme_master_read(card->window, &reg, 1,
./staging/vme/devices/vme_pio2_core.c:49:	return card->led;
./staging/vme/devices/vme_pio2_core.c:57:	reg = card->irq_level;
./staging/vme/devices/vme_pio2_core.c:66:	retval = vme_master_write(card->window, &reg, 1, PIO2_REGS_CTRL);
./staging/vme/devices/vme_pio2_core.c:70:	card->led = state ? 1 : 0;
./staging/vme/devices/vme_pio2_core.c:85:		dev_warn(&card->vdev->dev, "Spurious Interrupt\n");
./staging/vme/devices/vme_pio2_core.c:92:		retval = vme_master_read(card->window, &reg, 1,
./staging/vme/devices/vme_pio2_core.c:95:			dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:102:				dev_info(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:114:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:130:	retval = vme_master_write(card->window, &data, 1, PIO2_REGS_CTRL);
./staging/vme/devices/vme_pio2_core.c:135:	retval = vme_master_write(card->window, &data, 1, PIO2_REGS_VME_VECTOR);
./staging/vme/devices/vme_pio2_core.c:222:	card->id = vdev->num;
./staging/vme/devices/vme_pio2_core.c:223:	card->bus = bus[card->id];
./staging/vme/devices/vme_pio2_core.c:224:	card->base = base[card->id];
./staging/vme/devices/vme_pio2_core.c:225:	card->irq_vector = vector[card->id];
./staging/vme/devices/vme_pio2_core.c:226:	card->irq_level = level[card->id] & PIO2_VME_INT_MASK;
./staging/vme/devices/vme_pio2_core.c:227:	strncpy(card->variant, variant[card->id], PIO2_VARIANT_LENGTH);
./staging/vme/devices/vme_pio2_core.c:228:	card->vdev = vdev;
./staging/vme/devices/vme_pio2_core.c:231:		if (!isdigit(card->variant[i])) {
./staging/vme/devices/vme_pio2_core.c:232:			dev_err(&card->vdev->dev, "Variant invalid\n");
./staging/vme/devices/vme_pio2_core.c:241:	if (card->irq_vector & ~PIO2_VME_VECTOR_MASK) {
./staging/vme/devices/vme_pio2_core.c:242:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:256:		switch (card->variant[i]) {
./staging/vme/devices/vme_pio2_core.c:258:			card->bank[i - 1].config = NOFIT;
./staging/vme/devices/vme_pio2_core.c:264:			card->bank[i - 1].config = INPUT;
./staging/vme/devices/vme_pio2_core.c:267:			card->bank[i - 1].config = OUTPUT;
./staging/vme/devices/vme_pio2_core.c:273:			card->bank[i - 1].config = BOTH;
./staging/vme/devices/vme_pio2_core.c:279:	card->window = vme_master_request(vdev, VME_A24, VME_SCT, VME_D16);
./staging/vme/devices/vme_pio2_core.c:280:	if (!card->window) {
./staging/vme/devices/vme_pio2_core.c:281:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:286:	retval = vme_master_set(card->window, 1, card->base, 0x10000, VME_A24,
./staging/vme/devices/vme_pio2_core.c:289:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:300:	retval = vme_master_read(card->window, &reg, 1, PIO2_REGS_ID);
./staging/vme/devices/vme_pio2_core.c:302:		dev_err(&card->vdev->dev, "Unable to read from device\n");
./staging/vme/devices/vme_pio2_core.c:306:	dev_dbg(&card->vdev->dev, "ID Register:%x\n", reg);
./staging/vme/devices/vme_pio2_core.c:315:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:322:	reg = card->irq_level;
./staging/vme/devices/vme_pio2_core.c:327:	retval = vme_master_write(card->window, &reg, 1, PIO2_REGS_CTRL);
./staging/vme/devices/vme_pio2_core.c:332:	retval = vme_master_write(card->window, &card->irq_vector, 1,
./staging/vme/devices/vme_pio2_core.c:338:	vec = card->irq_vector | PIO2_VME_VECTOR_SPUR;
./staging/vme/devices/vme_pio2_core.c:340:	retval = vme_irq_request(vdev, card->irq_level, vec,
./staging/vme/devices/vme_pio2_core.c:343:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:345:			 vec, card->irq_level);
./staging/vme/devices/vme_pio2_core.c:351:		vec = card->irq_vector | PIO2_VECTOR_BANK[i];
./staging/vme/devices/vme_pio2_core.c:353:		retval = vme_irq_request(vdev, card->irq_level, vec,
./staging/vme/devices/vme_pio2_core.c:356:			dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:358:				 vec, card->irq_level);
./staging/vme/devices/vme_pio2_core.c:365:		vec = card->irq_vector | PIO2_VECTOR_CNTR[i];
./staging/vme/devices/vme_pio2_core.c:367:		retval = vme_irq_request(vdev, card->irq_level, vec,
./staging/vme/devices/vme_pio2_core.c:370:			dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:372:				vec, card->irq_level);
./staging/vme/devices/vme_pio2_core.c:380:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:388:		dev_err(&card->vdev->dev, "Unable to set LED\n");
./staging/vme/devices/vme_pio2_core.c:392:	dev_set_drvdata(&card->vdev->dev, card);
./staging/vme/devices/vme_pio2_core.c:394:	dev_info(&card->vdev->dev,
./staging/vme/devices/vme_pio2_core.c:395:		 "PIO2 (variant %s) configured at 0x%lx\n", card->variant,
./staging/vme/devices/vme_pio2_core.c:396:		card->base);
./staging/vme/devices/vme_pio2_core.c:407:		vec = card->irq_vector | PIO2_VECTOR_CNTR[i];
./staging/vme/devices/vme_pio2_core.c:408:		vme_irq_free(vdev, card->irq_level, vec);
./staging/vme/devices/vme_pio2_core.c:415:		vec = card->irq_vector | PIO2_VECTOR_BANK[i];
./staging/vme/devices/vme_pio2_core.c:416:		vme_irq_free(vdev, card->irq_level, vec);
./staging/vme/devices/vme_pio2_core.c:419:	vec = (card->irq_vector & PIO2_VME_VECTOR_MASK) | PIO2_VME_VECTOR_SPUR;
./staging/vme/devices/vme_pio2_core.c:420:	vme_irq_free(vdev, card->irq_level, vec);
./staging/vme/devices/vme_pio2_core.c:425:	vme_master_set(card->window, 0, 0, 0, VME_A16, 0, VME_D16);
./staging/vme/devices/vme_pio2_core.c:427:	vme_master_free(card->window);
./staging/vme/devices/vme_pio2_core.c:441:		vec = card->irq_vector | PIO2_VECTOR_CNTR[i];
./staging/vme/devices/vme_pio2_core.c:442:		vme_irq_free(vdev, card->irq_level, vec);
./staging/vme/devices/vme_pio2_core.c:446:		vec = card->irq_vector | PIO2_VECTOR_BANK[i];
./staging/vme/devices/vme_pio2_core.c:447:		vme_irq_free(vdev, card->irq_level, vec);
./staging/vme/devices/vme_pio2_core.c:450:	vec = (card->irq_vector & PIO2_VME_VECTOR_MASK) | PIO2_VME_VECTOR_SPUR;
./staging/vme/devices/vme_pio2_core.c:451:	vme_irq_free(vdev, card->irq_level, vec);
./staging/vme/devices/vme_pio2_core.c:455:	vme_master_set(card->window, 0, 0, 0, VME_A16, 0, VME_D16);
./staging/vme/devices/vme_pio2_core.c:457:	vme_master_free(card->window);
./staging/vme/devices/vme_pio2_gpio.c:34:	if ((card->bank[PIO2_CHANNEL_BANK[offset]].config == OUTPUT) |
./staging/vme/devices/vme_pio2_gpio.c:35:	    (card->bank[PIO2_CHANNEL_BANK[offset]].config == NOFIT)) {
./staging/vme/devices/vme_pio2_gpio.c:36:		dev_err(&card->vdev->dev, "Channel not available as input\n");
./staging/vme/devices/vme_pio2_gpio.c:40:	retval = vme_master_read(card->window, &reg, 1,
./staging/vme/devices/vme_pio2_gpio.c:43:		dev_err(&card->vdev->dev, "Unable to read from GPIO\n");
./staging/vme/devices/vme_pio2_gpio.c:52:		if (card->bank[PIO2_CHANNEL_BANK[offset]].config != BOTH)
./staging/vme/devices/vme_pio2_gpio.c:58:	if (card->bank[PIO2_CHANNEL_BANK[offset]].config != BOTH)
./staging/vme/devices/vme_pio2_gpio.c:71:	if ((card->bank[PIO2_CHANNEL_BANK[offset]].config == INPUT) |
./staging/vme/devices/vme_pio2_gpio.c:72:	    (card->bank[PIO2_CHANNEL_BANK[offset]].config == NOFIT)) {
./staging/vme/devices/vme_pio2_gpio.c:73:		dev_err(&card->vdev->dev, "Channel not available as output\n");
./staging/vme/devices/vme_pio2_gpio.c:78:		reg = card->bank[PIO2_CHANNEL_BANK[offset]].value |
./staging/vme/devices/vme_pio2_gpio.c:81:		reg = card->bank[PIO2_CHANNEL_BANK[offset]].value &
./staging/vme/devices/vme_pio2_gpio.c:84:	retval = vme_master_write(card->window, &reg, 1,
./staging/vme/devices/vme_pio2_gpio.c:87:		dev_err(&card->vdev->dev, "Unable to write to GPIO\n");
./staging/vme/devices/vme_pio2_gpio.c:91:	card->bank[PIO2_CHANNEL_BANK[offset]].value = reg;
./staging/vme/devices/vme_pio2_gpio.c:100:	if ((card->bank[PIO2_CHANNEL_BANK[offset]].config == OUTPUT) |
./staging/vme/devices/vme_pio2_gpio.c:101:	    (card->bank[PIO2_CHANNEL_BANK[offset]].config == NOFIT)) {
./staging/vme/devices/vme_pio2_gpio.c:102:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_gpio.c:120:	if ((card->bank[PIO2_CHANNEL_BANK[offset]].config == INPUT) |
./staging/vme/devices/vme_pio2_gpio.c:121:	    (card->bank[PIO2_CHANNEL_BANK[offset]].config == NOFIT)) {
./staging/vme/devices/vme_pio2_gpio.c:122:		dev_err(&card->vdev->dev,
./staging/vme/devices/vme_pio2_gpio.c:146:		retval = vme_master_write(card->window, &data, 1,
./staging/vme/devices/vme_pio2_gpio.c:150:		card->bank[i].value = 0;
./staging/vme/devices/vme_pio2_gpio.c:155:		retval = vme_master_write(card->window, &data, 1,
./staging/vme/devices/vme_pio2_gpio.c:160:		retval = vme_master_write(card->window, &data, 1,
./staging/vme/devices/vme_pio2_gpio.c:166:			card->bank[i].irq[j] = NONE;
./staging/vme/devices/vme_pio2_gpio.c:172:			retval = vme_master_read(card->window, &data, 1,
./staging/vme/devices/vme_pio2_gpio.c:188:			  "%s@%s", driver_name, dev_name(&card->vdev->dev));
./staging/vme/devices/vme_pio2_gpio.c:192:	card->gc.label = label;
./staging/vme/devices/vme_pio2_gpio.c:194:	card->gc.ngpio = PIO2_NUM_CHANNELS;
./staging/vme/devices/vme_pio2_gpio.c:196:	card->gc.base = -1;
./staging/vme/devices/vme_pio2_gpio.c:198:	card->gc.direction_input = pio2_gpio_dir_in;
./staging/vme/devices/vme_pio2_gpio.c:199:	card->gc.direction_output = pio2_gpio_dir_out;
./staging/vme/devices/vme_pio2_gpio.c:200:	card->gc.get = pio2_gpio_get;
./staging/vme/devices/vme_pio2_gpio.c:201:	card->gc.set = pio2_gpio_set;
./staging/vme/devices/vme_pio2_gpio.c:204:	retval = gpiochip_add_data(&card->gc, card);
./staging/vme/devices/vme_pio2_gpio.c:206:		dev_err(&card->vdev->dev, "Unable to register GPIO\n");
./staging/vme/devices/vme_pio2_gpio.c:207:		kfree(card->gc.label);
./staging/vme/devices/vme_pio2_gpio.c:215:	const char *label = card->gc.label;
./staging/vme/devices/vme_pio2_gpio.c:217:	gpiochip_remove(&card->gc);
./staging/comedi/drivers/ni_daq_dio24.c:74:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x475c),	/* daqcard-dio24 */
./staging/comedi/drivers/ni_labpc_cs.c:2: * Driver for National Instruments daqcard-1200 boards
./staging/comedi/drivers/ni_labpc_cs.c:26: * Devices: [National Instruments] DAQCard-1200 (daqcard-1200)
./staging/comedi/drivers/ni_labpc_cs.c:30: * helping to debug daqcard-1200 support.
./staging/comedi/drivers/ni_labpc_cs.c:40: * The daqcard-1200 has quirky chanlist requirements when scanning multiple
./staging/comedi/drivers/ni_labpc_cs.c:46: *   340988a (daqcard-1200)
./staging/comedi/drivers/ni_labpc_cs.c:57:		.name			= "daqcard-1200",
./staging/comedi/drivers/ni_labpc_cs.c:105:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x0103),	/* daqcard-1200 */
./staging/comedi/drivers/ni_labpc_cs.c:111:	.name		= "daqcard-1200",
./staging/comedi/drivers/ni_daq_700.c:29: * The daqcard-700 appears in Comedi as a  digital I/O subdevice (0) with
./staging/comedi/drivers/ni_daq_700.c:33: * Digital:  The channel 0 corresponds to the daqcard-700's output
./staging/comedi/drivers/ni_labpc_common.c:925:	 * NOTE: hardware bug in daqcard-1200 means pacing cannot
./staging/most/aim-sound/sound.c:603:	channel = card->private_data;
./staging/most/aim-sound/sound.c:614:	snprintf(card->driver, sizeof(card->driver), "%s", DRIVER_NAME);
./staging/most/aim-sound/sound.c:615:	snprintf(card->shortname, sizeof(card->shortname), "Microchip MOST:%d",
./staging/most/aim-sound/sound.c:616:		 card->number);
./staging/most/aim-sound/sound.c:617:	snprintf(card->longname, sizeof(card->longname), "%s at %s, ch %d",
./staging/most/aim-sound/sound.c:618:		 card->shortname, iface->description, channel_id);
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:167:	if (!card || !card->handle) {
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:174:	handle = card->handle;
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:207:	card->func = func;
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:214:	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:217:	func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:797:	func = card->func;
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:811:	ret = sdio_set_block_size(card->func, MLAN_SDIO_BLOCK_SIZE);
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:852:	struct mmc_host *host = cardp->func->card->host;
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:890:	sdio_claim_host(card->func);
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:894:			sdio_writeb(card->func, val, reg, &ret);
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:896:			sdio_f0_writeb(card->func, val, reg, &ret);
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:908:			val = sdio_readb(card->func, reg, &ret);
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:910:			val = sdio_f0_readb(card->func, reg, &ret);
./staging/marvell/SD-8801-U16-MMC-W14.68.36.p139-C4X14635_B0-GPL/wlan_src/mlinux/moal_sdio_mmc.c:922:	sdio_release_host(card->func);
./staging/greybus/audio_codec.c:808:	card = codec->card->snd_card;
./staging/greybus/audio_codec.c:810:	down_write(&card->controls_rwsem);
./staging/greybus/audio_codec.c:816:		up_write(&card->controls_rwsem);
./staging/greybus/audio_codec.c:822:		up_write(&card->controls_rwsem);
./staging/greybus/audio_codec.c:837:	if (codec->card->instantiated) {
./staging/greybus/audio_codec.c:848:				snd_device_register(codec->card->snd_card,
./staging/greybus/audio_codec.c:858:	if (codec->card->instantiated)
./staging/greybus/audio_codec.c:862:	up_write(&card->controls_rwsem);
./staging/greybus/audio_codec.c:934:	struct snd_card *card = codec->card->snd_card;
./staging/greybus/audio_codec.c:940:	down_write(&card->controls_rwsem);
./staging/greybus/audio_codec.c:960:			snd_device_free(codec->card->snd_card, jack->jack);
./staging/greybus/audio_codec.c:987:	up_write(&card->controls_rwsem);
./staging/vc04_services/bcm2835-audio/bcm2835.c:277:	strcpy(card->driver, audio_driver->driver.name);
./staging/vc04_services/bcm2835-audio/bcm2835.c:278:	strcpy(card->shortname, audio_driver->shortname);
./staging/vc04_services/bcm2835-audio/bcm2835.c:279:	strcpy(card->longname, audio_driver->longname);
./staging/vc04_services/bcm2835-audio/bcm2835-ctl.c:141:		dev_err(chip->card->dev, "Failed to set ALSA controls..\n");
./staging/vc04_services/bcm2835-audio/bcm2835-ctl.c:326:	strcpy(chip->card->mixername, "Broadcom Mixer");
./staging/vc04_services/bcm2835-audio/bcm2835-ctl.c:374:	strcpy(chip->card->mixername, "Broadcom Mixer");
./staging/vc04_services/bcm2835-audio/bcm2835-ctl.c:417:	strcpy(chip->card->mixername, "Broadcom Mixer");
./staging/rtl8189fs/os_dep/linux/sdio_intf.c:350:	rtw_warn_on(card->sdio_funcs != sdio_get_num_of_func(dvobj));
./staging/rtl8189fs/os_dep/linux/sdio_intf.c:351:	RTW_PRINT_SEL(sel, "  func num: %u\n", card->sdio_funcs);
./staging/rtl8189fs/os_dep/linux/sdio_intf.c:352:	for (i = 0; card->sdio_func[i]; i++) {
./staging/rtl8189fs/os_dep/linux/sdio_intf.c:354:			, card->sdio_func[i]->num, card->sdio_func[i]
./staging/rtl8189fs/os_dep/linux/sdio_intf.c:355:			, psdio_data->func == card->sdio_func[i] ? " (*)" : "");
./staging/rtl8189fs/os_dep/linux/sdio_intf.c:394:	psdio_data->timing = func->card->host->ios.timing;
./staging/rtl8189fs/os_dep/linux/sdio_intf.c:395:	psdio_data->clock = func->card->host->ios.clock;
./staging/rtl8189fs/os_dep/linux/sdio_intf.c:396:	psdio_data->func_number = func->card->sdio_funcs;
./staging/ks7010/ks7010_sdio.c:53:	struct sdio_func *func = priv->ks_sdio_card->func;
./staging/ks7010/ks7010_sdio.c:65:	struct sdio_func *func = priv->ks_sdio_card->func;
./staging/ks7010/ks7010_sdio.c:74:	struct sdio_func *func = priv->ks_sdio_card->func;
./staging/ks7010/ks7010_sdio.c:86:	struct sdio_func *func = priv->ks_sdio_card->func;
./staging/ks7010/ks7010_sdio.c:445:		dev_info(&priv->ks_sdio_card->func->dev,
./staging/ks7010/ks7010_sdio.c:452:	sdio_claim_host(priv->ks_sdio_card->func);
./staging/ks7010/ks7010_sdio.c:492:	sdio_release_host(priv->ks_sdio_card->func);
./staging/ks7010/ks7010_sdio.c:503:	priv = card->priv;
./staging/ks7010/ks7010_sdio.c:655:	struct ks_wlan_private *priv = card->priv;
./staging/ks7010/ks7010_sdio.c:667:	sdio_claim_host(card->func);
./staging/ks7010/ks7010_sdio.c:677:			       &priv->ks_sdio_card->func->dev);
./staging/ks7010/ks7010_sdio.c:742:	sdio_release_host(card->func);
./staging/ks7010/ks7010_sdio.c:844:	card->func = func;
./staging/ks7010/ks7010_sdio.c:850:		func->card->cccr.multi_block, func->cur_blksize, ret);
./staging/ks7010/ks7010_sdio.c:880:		dev_err(&card->func->dev, "ks7010 : Unable to alloc new net device\n");
./staging/ks7010/ks7010_sdio.c:884:		dev_err(&card->func->dev,
./staging/ks7010/ks7010_sdio.c:891:	card->priv = priv;
./staging/ks7010/ks7010_sdio.c:892:	SET_NETDEV_DEV(netdev, &card->func->dev);	/* for create sysfs symlinks */
./staging/ks7010/ks7010_sdio.c:919:		dev_err(&card->func->dev,
./staging/ks7010/ks7010_sdio.c:961:	card->priv = NULL;
./staging/ks7010/ks7010_sdio.c:995:	write_to_device(card->priv, (unsigned char *)pp,
./staging/ks7010/ks7010_sdio.c:1014:	DPRINTK(1, "priv = card->priv\n");
./staging/ks7010/ks7010_sdio.c:1015:	priv = card->priv;
./staging/ks7010/ks7010_sdio.c:1048:		card->priv = NULL;
./staging/fwserial/fwserial.c:1517:		   dev_name(serial->card->device),
./staging/fwserial/fwserial.c:1518:		   (unsigned long long)serial->card->guid);
./staging/fwserial/fwserial.c:1984:			  (unsigned long long)card->guid);
./staging/fwserial/fwserial.c:2268:						   card->device);
./staging/fwserial/fwserial.c:2286:						    card->device);
./staging/fwserial/fwserial.c:2311:		     dev_name(card->device), (unsigned long long)card->guid);
./staging/fwserial/fwserial.c:2570:		if (peer->serial->card->guid > peer->guid)
./staging/fwserial/fwserial.c:2631:		if (peer->serial->card->guid > peer->guid)
./pnp/isapnp/core.c:701:				"ignored\n", type, card->number);
./pnp/isapnp/core.c:726:			card->pnpver = tmp[0];
./pnp/isapnp/core.c:727:			card->productver = tmp[1];
./pnp/isapnp/core.c:740:			isapnp_parse_name(card->name, sizeof(card->name),
./pnp/isapnp/core.c:754:			dev_err(&card->dev, "unknown tag %#x, ignored\n",
./pnp/isapnp/core.c:809:		INIT_LIST_HEAD(&card->devices);
./pnp/isapnp/core.c:810:		card->serial =
./pnp/isapnp/core.c:816:			dev_err(&card->dev, "invalid checksum %#x\n",
./pnp/isapnp/core.c:818:		card->checksum = isapnp_checksum_value;
./pnp/isapnp/core.c:835:		if (card->protocol == &isapnp_protocol)
./pnp/isapnp/core.c:891:	isapnp_cfg_begin(dev->card->number, dev->number);
./pnp/isapnp/core.c:928:	isapnp_cfg_begin(dev->card->number, dev->number);
./pnp/isapnp/core.c:976:	isapnp_cfg_begin(dev->card->number, dev->number);
./pnp/isapnp/core.c:1063:			dev_info(&card->dev, "card '%s'\n",
./pnp/isapnp/core.c:1064:			       card->name[0] ? card->name : "unknown");
./pnp/isapnp/core.c:1068:				dev_info(&card->dev, "device '%s'\n",
./pnp/isapnp/compat.c:39:		if (compare_pnp_id(card->id, id) || (memcmp(id, any, 7) == 0))
./pnp/isapnp/compat.c:72:		list = card->devices.next;
./pnp/isapnp/compat.c:78:		while (list != &card->devices) {
./pnp/isapnp/proc.c:53:	isapnp_cfg_begin(dev->card->number, dev->number);
./pnp/card.c:25:		if (compare_pnp_id(card->id, drv_id->id)) {
./pnp/card.c:125:	ptr = card->id;
./pnp/card.c:131:		card->id = dev_id;
./pnp/card.c:141:	id = card->id;
./pnp/card.c:166:	card->protocol = protocol;
./pnp/card.c:167:	card->number = id;
./pnp/card.c:169:	card->dev.parent = &card->protocol->dev;
./pnp/card.c:170:	dev_set_name(&card->dev, "%02x:%02x", card->protocol->number, card->number);
./pnp/card.c:172:	card->dev.coherent_dma_mask = DMA_BIT_MASK(24);
./pnp/card.c:173:	card->dev.dma_mask = &card->dev.coherent_dma_mask;
./pnp/card.c:190:	str += sprintf(str, "%s\n", card->name);
./pnp/card.c:201:	struct pnp_id *pos = card->id;
./pnp/card.c:214:	int rc = device_create_file(&card->dev, &dev_attr_name);
./pnp/card.c:219:	rc = device_create_file(&card->dev, &dev_attr_card_id);
./pnp/card.c:226:	device_remove_file(&card->dev, &dev_attr_name);
./pnp/card.c:239:	card->dev.bus = NULL;
./pnp/card.c:240:	card->dev.release = &pnp_release_card;
./pnp/card.c:241:	error = device_register(&card->dev);
./pnp/card.c:243:		dev_err(&card->dev, "could not register (err=%d)\n", error);
./pnp/card.c:244:		put_device(&card->dev);
./pnp/card.c:250:	list_add_tail(&card->global_list, &pnp_cards);
./pnp/card.c:251:	list_add_tail(&card->protocol_list, &card->protocol->cards);
./pnp/card.c:257:	list_for_each(pos, &card->devices) {
./pnp/card.c:280:	device_unregister(&card->dev);
./pnp/card.c:282:	list_del(&card->global_list);
./pnp/card.c:283:	list_del(&card->protocol_list);
./pnp/card.c:285:	list_for_each_safe(pos, temp, &card->devices) {
./pnp/card.c:298:	dev->dev.parent = &card->dev;
./pnp/card.c:301:		     dev->protocol->number, card->number, dev->number);
./pnp/card.c:304:	list_add_tail(&dev->card_list, &card->devices);
./pnp/card.c:342:		pos = card->devices.next;
./pnp/card.c:348:	while (pos != &card->devices) {
./pcmcia/db1xxx_ss.c:12: * The Db1000 is used as a reference:  Per-socket card-, carddetect- and
./pcmcia/db1xxx_ss.c:20: *	- Au1200-based:	  additional card-eject irqs, irqs not gpios!
./pcmcia/db1xxx_ss.c:56:	int	stschg_irq;	/* card-status-change irq */
./pcmcia/electra_cf.c:255:	prop = of_get_property(np, "card-detect-gpio", NULL);
./pcmcia/electra_cf.c:260:	prop = of_get_property(np, "card-vsense-gpio", NULL);
./pcmcia/electra_cf.c:265:	prop = of_get_property(np, "card-3v-gpio", NULL);
./pcmcia/electra_cf.c:270:	prop = of_get_property(np, "card-5v-gpio", NULL);
./parisc/Kconfig:55:	  incomplete and lacks support for card-to-host DMA.
./parisc/dino.c:513:	** REVISIT: card-mode PCI-PCI expansion chassis do exist.
./parisc/dino.c:529:	** Program INT_LINE for card-mode devices.
./parisc/dino.c:560:	/* Firmware doesn't set up card-mode dino, so we have to */
./parisc/dino.c:887:** If so, initialize the chip appropriately (card-mode vs bridge mode).
./parisc/dino.c:1021: * For card-mode Dino, most machines report an sversion of 9D.  But 715
./parisc/hppb.c:53:	while(card->next) {
./parisc/hppb.c:54:		card = card->next;
./parisc/hppb.c:57:	if(card->hpa) {
./parisc/hppb.c:58:		card->next = kzalloc(sizeof(struct hppb_card), GFP_KERNEL);
./parisc/hppb.c:59:		if(!card->next) {
./parisc/hppb.c:63:		card = card->next;
./parisc/hppb.c:68:	card->hpa = dev->hpa.start;
./parisc/hppb.c:69:	card->mmio_region.name = "HP-PB Bus";
./parisc/hppb.c:70:	card->mmio_region.flags = IORESOURCE_MEM;
./parisc/hppb.c:72:	card->mmio_region.start = gsc_readl(dev->hpa.start + IO_IO_LOW);
./parisc/hppb.c:73:	card->mmio_region.end = gsc_readl(dev->hpa.start + IO_IO_HIGH) - 1;
./parisc/hppb.c:75:	status = ccio_request_resource(dev, &card->mmio_region);
./parisc/hppb.c:78:			__FILE__, &card->mmio_region);
./usb/gadget/function/u_uac1_legacy.c:154:	struct gaudio_snd_dev	*snd = &card->playback;
./usb/gadget/function/u_uac1_legacy.c:184:	return card->playback.channels;
./usb/gadget/function/u_uac1_legacy.c:189:	return card->playback.rate;
./usb/gadget/function/u_uac1_legacy.c:203:	opts = container_of(card->func.fi, struct f_uac1_legacy_opts,
./usb/gadget/function/u_uac1_legacy.c:210:	snd = &card->control;
./usb/gadget/function/u_uac1_legacy.c:222:	snd = &card->playback;
./usb/gadget/function/u_uac1_legacy.c:237:	snd = &card->capture;
./usb/gadget/function/u_audio.c:208:		dev_err(uac->card->dev, "%d Error!\n", __LINE__);
./usb/gadget/function/u_audio.c:244:		dev_err(uac->card->dev, "%d Error!\n", __LINE__);
./usb/gadget/function/u_audio.c:421:		dev_err(uac->card->dev, "%s:%d Error!\n", __func__, __LINE__);
./usb/gadget/function/u_audio.c:448:		dev_err(uac->card->dev, "%s:%d Error!\n", __func__, __LINE__);
./usb/gadget/function/u_audio.c:711:	strlcpy(card->driver, card_name, sizeof(card->driver));
./usb/gadget/function/u_audio.c:712:	strlcpy(card->shortname, card_name, sizeof(card->shortname));
./usb/gadget/function/u_audio.c:713:	sprintf(card->longname, "%s %i", card_name, card->dev->id);
./usb/gadget/function/f_midi.c:821:	strcpy(card->driver, f_midi_longname);
./usb/gadget/function/f_midi.c:822:	strcpy(card->longname, f_midi_longname);
./usb/gadget/function/f_midi.c:823:	strcpy(card->shortname, f_midi_shortname);
./usb/gadget/function/f_midi.c:827:	err = snd_rawmidi_new(card, card->longname, 0,
./usb/gadget/function/f_midi.c:835:	strcpy(rmidi->name, card->shortname);
./video/fbdev/sis/sis_main.h:140:/* The memory heap is now handled card-wise, by using
./video/fbdev/pm3fb.c:1246:	/* TODO: card-specific stuff, *before* accessing *any* FB memory */
./gpu/drm/radeon/atom.c:106:	struct radeon_device *rdev = ctx->card->dev->dev_private;
./gpu/drm/radeon/atom.c:115:			temp = ctx->card->ioreg_read(ctx->card, CU16(base + 1));
./gpu/drm/radeon/atom.c:120:				(void)ctx->card->ioreg_read(ctx->card, CU16(base + 1));
./gpu/drm/radeon/atom.c:121:			ctx->card->ioreg_write(ctx->card, CU16(base + 1), temp);
./gpu/drm/radeon/atom.c:194:			val = gctx->card->reg_read(gctx->card, idx);
./gpu/drm/radeon/atom.c:319:		val = gctx->card->pll_read(gctx->card, idx);
./gpu/drm/radeon/atom.c:326:		val = gctx->card->mc_read(gctx->card, idx);
./gpu/drm/radeon/atom.c:467:				gctx->card->reg_write(gctx->card, idx,
./gpu/drm/radeon/atom.c:470:				gctx->card->reg_write(gctx->card, idx, val);
./gpu/drm/radeon/atom.c:545:		gctx->card->pll_write(gctx->card, idx, val);
./gpu/drm/radeon/atom.c:551:		gctx->card->mc_write(gctx->card, idx, val);
./gpu/drm/radeon/atom.c:1324:	struct radeon_device *rdev = ctx->card->dev->dev_private;
./gpu/drm/amd/amdgpu/atom.c:113:			temp = ctx->card->ioreg_read(ctx->card, CU16(base + 1));
./gpu/drm/amd/amdgpu/atom.c:117:			ctx->card->ioreg_write(ctx->card, CU16(base + 1), temp);
./gpu/drm/amd/amdgpu/atom.c:190:			val = gctx->card->reg_read(gctx->card, idx);
./gpu/drm/amd/amdgpu/atom.c:315:		val = gctx->card->pll_read(gctx->card, idx);
./gpu/drm/amd/amdgpu/atom.c:322:		val = gctx->card->mc_read(gctx->card, idx);
./gpu/drm/amd/amdgpu/atom.c:463:				gctx->card->reg_write(gctx->card, idx,
./gpu/drm/amd/amdgpu/atom.c:466:				gctx->card->reg_write(gctx->card, idx, val);
./gpu/drm/amd/amdgpu/atom.c:541:		gctx->card->pll_write(gctx->card, idx, val);
./gpu/drm/amd/amdgpu/atom.c:547:		gctx->card->mc_write(gctx->card, idx, val);
./gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c:556:	strlcpy(card->driver, DRIVER_NAME, sizeof(card->driver));
./gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c:557:	strlcpy(card->shortname, "DW-HDMI", sizeof(card->shortname));
./gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c:558:	snprintf(card->longname, sizeof(card->longname),
./gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c:559:		 "%s rev 0x%02x, irq %d", card->shortname, revision,
./gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c:562:	dw = card->private_data;
./gpu/drm/vc4/vc4_hdmi.c:1114:	card->dai_link = dai_link;
./gpu/drm/vc4/vc4_hdmi.c:1115:	card->num_links = 1;
./gpu/drm/vc4/vc4_hdmi.c:1116:	card->name = "vc4-hdmi";
./gpu/drm/vc4/vc4_hdmi.c:1117:	card->dev = dev;
./gpu/drm/vc4/vc4_hdmi.c:1123:	 * now stored in card->drvdata and should be retrieved with
./ata/Makefile:7:obj-$(CONFIG_SATA_ACARD_AHCI)	+= acard-ahci.o libahci.o
./ata/acard-ahci.c:3: *  acard-ahci.c - ACard AHCI SATA support
./ata/acard-ahci.c:51:#define DRV_NAME	"acard-ahci"
./ata/acard-ahci.c:86:	AHCI_SHT("acard-ahci"),
./mtd/maps/vmu-flash.c:71:	if (src_ofs >= card->parts[partition].numblocks * card->blocklen)
./mtd/maps/vmu-flash.c:74:	num = src_ofs / card->blocklen;
./mtd/maps/vmu-flash.c:75:	if (num > card->parts[partition].numblocks)
./mtd/maps/vmu-flash.c:83:	vblock->ofs = src_ofs % card->blocklen;
./mtd/maps/vmu-flash.c:100:	if (unlikely(!card->blockread))
./mtd/maps/vmu-flash.c:103:	memcpy(card->blockread, mq->recvbuf->buf + 12,
./mtd/maps/vmu-flash.c:104:		card->blocklen/card->readcnt);
./mtd/maps/vmu-flash.c:126:	pcache = card->parts[partition].pcache;
./mtd/maps/vmu-flash.c:131:		pcache->buffer = kmalloc(card->blocklen, GFP_KERNEL);
./mtd/maps/vmu-flash.c:146:	for (x = 0; x < card->readcnt; x++) {
./mtd/maps/vmu-flash.c:161:		blockread = kmalloc(card->blocklen/card->readcnt, GFP_KERNEL);
./mtd/maps/vmu-flash.c:167:		card->blockread = blockread;
./mtd/maps/vmu-flash.c:186:			card->blockread = NULL;
./mtd/maps/vmu-flash.c:190:			card->blockread = NULL;
./mtd/maps/vmu-flash.c:207:		memcpy(buf + (card->blocklen/card->readcnt) * x, blockread,
./mtd/maps/vmu-flash.c:208:			card->blocklen/card->readcnt);
./mtd/maps/vmu-flash.c:210:		memcpy(pcache->buffer + (card->blocklen/card->readcnt) * x,
./mtd/maps/vmu-flash.c:211:			card->blockread, card->blocklen/card->readcnt);
./mtd/maps/vmu-flash.c:212:		card->blockread = NULL;
./mtd/maps/vmu-flash.c:242:	phaselen = card->blocklen/card->writecnt;
./mtd/maps/vmu-flash.c:249:	for (x = 0; x < card->writecnt; x++) {
./mtd/maps/vmu-flash.c:293:	return card->blocklen;
./mtd/maps/vmu-flash.c:320:	buf = kmalloc(card->blocklen, GFP_KERNEL);
./mtd/maps/vmu-flash.c:368:	numblocks = card->parts[partition].numblocks;
./mtd/maps/vmu-flash.c:369:	if (from + len > numblocks * card->blocklen)
./mtd/maps/vmu-flash.c:370:		len = numblocks * card->blocklen - from;
./mtd/maps/vmu-flash.c:374:	pcache = card->parts[partition].pcache;
./mtd/maps/vmu-flash.c:384:			leftover = card->blocklen - vblock->ofs;
./mtd/maps/vmu-flash.c:385:			if (vblock->ofs + len - index < card->blocklen) {
./mtd/maps/vmu-flash.c:434:	numblocks = card->parts[partition].numblocks;
./mtd/maps/vmu-flash.c:435:	if (to + len > numblocks * card->blocklen)
./mtd/maps/vmu-flash.c:436:		len = numblocks * card->blocklen - to;
./mtd/maps/vmu-flash.c:448:	buffer = kmalloc(card->blocklen, GFP_KERNEL);
./mtd/maps/vmu-flash.c:466:		} while (vblock->ofs < card->blocklen);
./mtd/maps/vmu-flash.c:471:		pcache = card->parts[partition].pcache;
./mtd/maps/vmu-flash.c:474:		if (error != card->blocklen)
./mtd/maps/vmu-flash.c:516:	card->tempA = res[12];
./mtd/maps/vmu-flash.c:517:	card->tempB = res[6];
./mtd/maps/vmu-flash.c:520:		"blocks with a root block at %d\n", card->partition,
./mtd/maps/vmu-flash.c:521:		card->tempA, card->tempB);
./mtd/maps/vmu-flash.c:523:	part_cur = &card->parts[card->partition];
./mtd/maps/vmu-flash.c:524:	part_cur->user_blocks = card->tempA;
./mtd/maps/vmu-flash.c:525:	part_cur->root_block = card->tempB;
./mtd/maps/vmu-flash.c:526:	part_cur->numblocks = card->tempB + 1;
./mtd/maps/vmu-flash.c:532:		mdev->port, mdev->unit, card->partition);
./mtd/maps/vmu-flash.c:533:	mtd_cur = &card->mtd[card->partition];
./mtd/maps/vmu-flash.c:537:	mtd_cur->size = part_cur->numblocks * card->blocklen;
./mtd/maps/vmu-flash.c:538:	mtd_cur->erasesize = card->blocklen;
./mtd/maps/vmu-flash.c:542:	mtd_cur->writesize = card->blocklen;
./mtd/maps/vmu-flash.c:549:	mpart->partition = card->partition;
./mtd/maps/vmu-flash.c:569:	if (++card->partition < card->partitions) {
./mtd/maps/vmu-flash.c:570:		partnum = cpu_to_be32(card->partition << 24);
./mtd/maps/vmu-flash.c:581:	for (error = 0; error <= card->partition; error++) {
./mtd/maps/vmu-flash.c:582:		kfree(((card->parts)[error]).pcache);
./mtd/maps/vmu-flash.c:583:		((card->parts)[error]).pcache = NULL;
./mtd/maps/vmu-flash.c:587:	for (error = 0; error <= card->partition; error++) {
./mtd/maps/vmu-flash.c:588:		kfree(((card->mtd)[error]).priv);
./mtd/maps/vmu-flash.c:589:		((card->mtd)[error]).priv = NULL;
./mtd/maps/vmu-flash.c:620:	card->partitions = (basic_flash_data >> 24 & 0xFF) + 1;
./mtd/maps/vmu-flash.c:621:	card->blocklen = ((basic_flash_data >> 16 & 0xFF) + 1) << 5;
./mtd/maps/vmu-flash.c:622:	card->writecnt = basic_flash_data >> 12 & 0xF;
./mtd/maps/vmu-flash.c:623:	card->readcnt = basic_flash_data >> 8 & 0xF;
./mtd/maps/vmu-flash.c:624:	card->removeable = basic_flash_data >> 7 & 1;
./mtd/maps/vmu-flash.c:626:	card->partition = 0;
./mtd/maps/vmu-flash.c:632:	card->parts = kmalloc(sizeof(struct vmupart) * card->partitions,
./mtd/maps/vmu-flash.c:634:	if (!card->parts) {
./mtd/maps/vmu-flash.c:639:	card->mtd = kmalloc(sizeof(struct mtd_info) * card->partitions,
./mtd/maps/vmu-flash.c:641:	if (!card->mtd) {
./mtd/maps/vmu-flash.c:684:	kfree(card->mtd);
./mtd/maps/vmu-flash.c:686:	kfree(card->parts);
./mtd/maps/vmu-flash.c:701:	for (x = 0; x < card->partitions; x++) {
./mtd/maps/vmu-flash.c:702:		mpart = ((card->mtd)[x]).priv;
./mtd/maps/vmu-flash.c:704:		mtd_device_unregister(&((card->mtd)[x]));
./mtd/maps/vmu-flash.c:705:		kfree(((card->parts)[x]).name);
./mtd/maps/vmu-flash.c:707:	kfree(card->parts);
./mtd/maps/vmu-flash.c:708:	kfree(card->mtd);
./mtd/maps/vmu-flash.c:722:	for (x = 0; x < card->partitions; x++) {
./mtd/maps/vmu-flash.c:723:		mtd = &((card->mtd)[x]);
./char/agp/amd-k7-agp.c:451:		if (gfxcard->vendor == PCI_VENDOR_ID_NVIDIA) {
./char/applicom.c:712:	IndexCard = adgl->num_card-1;
./bluetooth/btsdio.c:301:	    !mmc_card_is_removable(func->card->host))
./bluetooth/btmrvl_main.c:250:	if (!card->support_pscan_win_report)
./bluetooth/btmrvl_main.c:518:	if (card->plt_of_node) {
./bluetooth/btmrvl_main.c:519:		dt_node = card->plt_of_node;
./bluetooth/btmrvl_sdio.c:65:	struct btmrvl_plt_wake_cfg *cfg = card->plt_wake_cfg;
./bluetooth/btmrvl_sdio.c:71:	pm_wakeup_event(&card->func->dev, 0);
./bluetooth/btmrvl_sdio.c:78: * The device node is saved in card->plt_of_node.
./bluetooth/btmrvl_sdio.c:94:	card->plt_of_node = dev->of_node;
./bluetooth/btmrvl_sdio.c:96:	card->plt_wake_cfg = devm_kzalloc(dev, sizeof(*card->plt_wake_cfg),
./bluetooth/btmrvl_sdio.c:98:	cfg = card->plt_wake_cfg;
./bluetooth/btmrvl_sdio.c:99:	if (cfg && card->plt_of_node) {
./bluetooth/btmrvl_sdio.c:100:		cfg->irq_bt = irq_of_parse_and_map(card->plt_of_node, 0);
./bluetooth/btmrvl_sdio.c:324:	reg = sdio_readb(card->func, card->reg->card_rx_unit, &ret);
./bluetooth/btmrvl_sdio.c:326:		card->rx_unit = reg;
./bluetooth/btmrvl_sdio.c:338:	fws0 = sdio_readb(card->func, card->reg->card_fw_status0, &ret);
./bluetooth/btmrvl_sdio.c:342:	fws1 = sdio_readb(card->func, card->reg->card_fw_status1, &ret);
./bluetooth/btmrvl_sdio.c:356:	reg = sdio_readb(card->func, card->reg->card_rx_len, &ret);
./bluetooth/btmrvl_sdio.c:358:		*dat = (u16) reg << card->rx_unit;
./bluetooth/btmrvl_sdio.c:368:	sdio_writeb(card->func, mask, card->reg->host_int_mask, &ret);
./bluetooth/btmrvl_sdio.c:383:	host_int_mask = sdio_readb(card->func, card->reg->host_int_mask, &ret);
./bluetooth/btmrvl_sdio.c:389:	sdio_writeb(card->func, host_int_mask, card->reg->host_int_mask, &ret);
./bluetooth/btmrvl_sdio.c:405:		status = sdio_readb(card->func, card->reg->card_status,	&ret);
./bluetooth/btmrvl_sdio.c:430:		sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:432:		sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:455:	ret = request_firmware(&fw_helper, card->helper,
./bluetooth/btmrvl_sdio.c:456:						&card->func->dev);
./bluetooth/btmrvl_sdio.c:513:		ret = sdio_writesb(card->func, card->ioport, helperbuf,
./bluetooth/btmrvl_sdio.c:528:	ret = sdio_writesb(card->func, card->ioport, helperbuf,
./bluetooth/btmrvl_sdio.c:552:	u16 len, blksz_dl = card->sd_blksz_fw_dl;
./bluetooth/btmrvl_sdio.c:555:	ret = request_firmware(&fw_firmware, card->firmware,
./bluetooth/btmrvl_sdio.c:556:							&card->func->dev);
./bluetooth/btmrvl_sdio.c:597:			base0 = sdio_readb(card->func,
./bluetooth/btmrvl_sdio.c:598:					card->reg->sq_read_base_addr_a0, &ret);
./bluetooth/btmrvl_sdio.c:607:			base1 = sdio_readb(card->func,
./bluetooth/btmrvl_sdio.c:608:					card->reg->sq_read_base_addr_a1, &ret);
./bluetooth/btmrvl_sdio.c:661:		ret = sdio_writesb(card->func, card->ioport, fwbuf,
./bluetooth/btmrvl_sdio.c:667:			sdio_writeb(card->func, HOST_CMD53_FIN,
./bluetooth/btmrvl_sdio.c:668:						card->reg->cfg, &ret);
./bluetooth/btmrvl_sdio.c:696:	if (!card || !card->func) {
./bluetooth/btmrvl_sdio.c:737:	ret = sdio_readsb(card->func, payload, card->ioport,
./bluetooth/btmrvl_sdio.c:820:	sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:832:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:839:	struct btmrvl_adapter *adapter = card->priv->adapter;
./bluetooth/btmrvl_sdio.c:842:	ret = sdio_readsb(card->func, adapter->hw_regs, 0, SDIO_BLOCK_SIZE);
./bluetooth/btmrvl_sdio.c:848:	*ireg = adapter->hw_regs[card->reg->host_intstatus];
./bluetooth/btmrvl_sdio.c:849:	BT_DBG("hw_regs[%#x]=%#x", card->reg->host_intstatus, *ireg);
./bluetooth/btmrvl_sdio.c:858:	*ireg = sdio_readb(card->func, card->reg->host_intstatus, &ret);
./bluetooth/btmrvl_sdio.c:872:		sdio_writeb(card->func, ~(*ireg) & (DN_LD_HOST_INT_STATUS |
./bluetooth/btmrvl_sdio.c:874:			    card->reg->host_intstatus, &ret);
./bluetooth/btmrvl_sdio.c:893:	if (!card || !card->priv) {
./bluetooth/btmrvl_sdio.c:899:	priv = card->priv;
./bluetooth/btmrvl_sdio.c:904:	if (card->reg->int_read_to_clear)
./bluetooth/btmrvl_sdio.c:925:	if (!card || !card->func) {
./bluetooth/btmrvl_sdio.c:931:	func = card->func;
./bluetooth/btmrvl_sdio.c:949:	ret = sdio_set_block_size(card->func, SDIO_BLOCK_SIZE);
./bluetooth/btmrvl_sdio.c:956:	reg = sdio_readb(func, card->reg->io_port_0, &ret);
./bluetooth/btmrvl_sdio.c:962:	card->ioport = reg;
./bluetooth/btmrvl_sdio.c:964:	reg = sdio_readb(func, card->reg->io_port_1, &ret);
./bluetooth/btmrvl_sdio.c:970:	card->ioport |= (reg << 8);
./bluetooth/btmrvl_sdio.c:972:	reg = sdio_readb(func, card->reg->io_port_2, &ret);
./bluetooth/btmrvl_sdio.c:978:	card->ioport |= (reg << 16);
./bluetooth/btmrvl_sdio.c:980:	BT_DBG("SDIO FUNC%d IO port: 0x%x", func->num, card->ioport);
./bluetooth/btmrvl_sdio.c:982:	if (card->reg->int_read_to_clear) {
./bluetooth/btmrvl_sdio.c:983:		reg = sdio_readb(func, card->reg->host_int_rsr, &ret);
./bluetooth/btmrvl_sdio.c:988:		sdio_writeb(func, reg | 0x3f, card->reg->host_int_rsr, &ret);
./bluetooth/btmrvl_sdio.c:994:		reg = sdio_readb(func, card->reg->card_misc_cfg, &ret);
./bluetooth/btmrvl_sdio.c:999:		sdio_writeb(func, reg | 0x10, card->reg->card_misc_cfg, &ret);
./bluetooth/btmrvl_sdio.c:1027:	if (card && card->func) {
./bluetooth/btmrvl_sdio.c:1028:		sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:1029:		sdio_release_irq(card->func);
./bluetooth/btmrvl_sdio.c:1030:		sdio_disable_func(card->func);
./bluetooth/btmrvl_sdio.c:1031:		sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1032:		sdio_set_drvdata(card->func, NULL);
./bluetooth/btmrvl_sdio.c:1042:	if (!card || !card->func)
./bluetooth/btmrvl_sdio.c:1045:	sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:1051:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1060:	if (!card || !card->func)
./bluetooth/btmrvl_sdio.c:1063:	sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:1067:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1083:	if (!card || !card->func) {
./bluetooth/btmrvl_sdio.c:1102:	sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:1106:		ret = sdio_writesb(card->func, card->ioport, buf,
./bluetooth/btmrvl_sdio.c:1121:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1133:	if (!card || !card->func) {
./bluetooth/btmrvl_sdio.c:1143:	sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:1146:	fws0 = sdio_readb(card->func, card->reg->card_fw_status0, &ret);
./bluetooth/btmrvl_sdio.c:1158:		if (card->helper) {
./bluetooth/btmrvl_sdio.c:1184:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1189:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1198:	if (!card || !card->func) {
./bluetooth/btmrvl_sdio.c:1203:	sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:1205:	sdio_writeb(card->func, HOST_POWER_UP, card->reg->cfg, &ret);
./bluetooth/btmrvl_sdio.c:1207:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1224:	sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:1245:				data = sdio_f0_readb(card->func, reg, &ret);
./bluetooth/btmrvl_sdio.c:1247:				data = sdio_readb(card->func, reg, &ret);
./bluetooth/btmrvl_sdio.c:1260:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1272:	sdio_writeb(card->func, FW_DUMP_HOST_READY, card->reg->fw_dump_ctrl,
./bluetooth/btmrvl_sdio.c:1281:		ctrl_data = sdio_readb(card->func, card->reg->fw_dump_ctrl,
./bluetooth/btmrvl_sdio.c:1295:			sdio_writeb(card->func, FW_DUMP_HOST_READY,
./bluetooth/btmrvl_sdio.c:1296:				    card->reg->fw_dump_ctrl, &ret);
./bluetooth/btmrvl_sdio.c:1327:	if (!card->supports_fw_dump) {
./bluetooth/btmrvl_sdio.c:1343:	sdio_claim_host(card->func);
./bluetooth/btmrvl_sdio.c:1351:	reg = card->reg->fw_dump_start;
./bluetooth/btmrvl_sdio.c:1353:	dump_num = sdio_readb(card->func, reg, &ret);
./bluetooth/btmrvl_sdio.c:1369:		reg = card->reg->fw_dump_start;
./bluetooth/btmrvl_sdio.c:1371:			read_reg = sdio_readb(card->func, reg, &ret);
./bluetooth/btmrvl_sdio.c:1382:			sdio_writeb(card->func, FW_DUMP_READ_DONE,
./bluetooth/btmrvl_sdio.c:1383:				    card->reg->fw_dump_ctrl, &ret);
./bluetooth/btmrvl_sdio.c:1417:			reg_start = card->reg->fw_dump_start;
./bluetooth/btmrvl_sdio.c:1418:			reg_end = card->reg->fw_dump_end;
./bluetooth/btmrvl_sdio.c:1420:				*dbg_ptr = sdio_readb(card->func, reg, &ret);
./bluetooth/btmrvl_sdio.c:1445:	sdio_release_host(card->func);
./bluetooth/btmrvl_sdio.c:1488:	dev_coredumpv(&card->func->dev, fw_dump_data, fw_dump_len, GFP_KERNEL);
./bluetooth/btmrvl_sdio.c:1506:	card->func = func;
./bluetooth/btmrvl_sdio.c:1510:		card->helper = data->helper;
./bluetooth/btmrvl_sdio.c:1511:		card->firmware = data->firmware;
./bluetooth/btmrvl_sdio.c:1512:		card->reg = data->reg;
./bluetooth/btmrvl_sdio.c:1513:		card->sd_blksz_fw_dl = data->sd_blksz_fw_dl;
./bluetooth/btmrvl_sdio.c:1514:		card->support_pscan_win_report = data->support_pscan_win_report;
./bluetooth/btmrvl_sdio.c:1515:		card->supports_fw_dump = data->supports_fw_dump;
./bluetooth/btmrvl_sdio.c:1544:	card->priv = priv;
./bluetooth/btmrvl_sdio.c:1578:				btmrvl_send_module_cfg_cmd(card->priv,
./bluetooth/btmrvl_sdio.c:1583:			card->priv->surprise_removed = true;
./bluetooth/btmrvl_sdio.c:1585:			btmrvl_remove_card(card->priv);
./bluetooth/btmrvl_sdio.c:1608:		if (!card || !card->priv) {
./bluetooth/btmrvl_sdio.c:1618:	if (card->plt_wake_cfg && card->plt_wake_cfg->irq_bt >= 0) {
./bluetooth/btmrvl_sdio.c:1619:		card->plt_wake_cfg->wake_by_bt = false;
./bluetooth/btmrvl_sdio.c:1620:		enable_irq(card->plt_wake_cfg->irq_bt);
./bluetooth/btmrvl_sdio.c:1621:		enable_irq_wake(card->plt_wake_cfg->irq_bt);
./bluetooth/btmrvl_sdio.c:1624:	priv = card->priv;
./bluetooth/btmrvl_sdio.c:1634:			if (card->plt_wake_cfg &&
./bluetooth/btmrvl_sdio.c:1635:			    card->plt_wake_cfg->irq_bt >= 0) {
./bluetooth/btmrvl_sdio.c:1636:				disable_irq_wake(card->plt_wake_cfg->irq_bt);
./bluetooth/btmrvl_sdio.c:1637:				disable_irq(card->plt_wake_cfg->irq_bt);
./bluetooth/btmrvl_sdio.c:1671:		if (!card || !card->priv) {
./bluetooth/btmrvl_sdio.c:1679:	priv = card->priv;
./bluetooth/btmrvl_sdio.c:1695:	if (card->plt_wake_cfg && card->plt_wake_cfg->irq_bt >= 0) {
./bluetooth/btmrvl_sdio.c:1696:		disable_irq_wake(card->plt_wake_cfg->irq_bt);
./bluetooth/btmrvl_sdio.c:1697:		disable_irq(card->plt_wake_cfg->irq_bt);
./bluetooth/btmrvl_sdio.c:1698:		if (card->plt_wake_cfg->wake_by_bt)
./bluetooth/btmrvl_sdio.c:1702:			enable_irq(card->plt_wake_cfg->irq_bt);
./block/umem.c:154:	led = readb(card->csr_remap + MEMCTRLCMD_LEDCTRL);
./block/umem.c:162:	led = readb(card->csr_remap + MEMCTRLCMD_LEDCTRL);
./block/umem.c:167:	writeb(led, card->csr_remap + MEMCTRLCMD_LEDCTRL);
./block/umem.c:179:	led = readb(card->csr_remap + MEMCTRLCMD_LEDCTRL);
./block/umem.c:186:	writeb(led, card->csr_remap + MEMCTRLCMD_LEDCTRL);
./block/umem.c:196:	p = card->csr_remap;
./block/umem.c:210:	dev_printk(KERN_DEBUG, &card->dev->dev, "DMAstat - ");
./block/umem.c:255:	 * no IO active, and we know that card->Active
./block/umem.c:263:	page = &card->mm_pages[card->Active];
./block/umem.c:265:		card->Active, page->headcnt, page->cnt - 1);
./block/umem.c:277:	writel(0, card->csr_remap + DMA_PCI_ADDR);
./block/umem.c:278:	writel(0, card->csr_remap + DMA_PCI_ADDR + 4);
./block/umem.c:280:	writel(0, card->csr_remap + DMA_LOCAL_ADDR);
./block/umem.c:281:	writel(0, card->csr_remap + DMA_LOCAL_ADDR + 4);
./block/umem.c:283:	writel(0, card->csr_remap + DMA_TRANSFER_SIZE);
./block/umem.c:284:	writel(0, card->csr_remap + DMA_TRANSFER_SIZE + 4);
./block/umem.c:286:	writel(0, card->csr_remap + DMA_SEMAPHORE_ADDR);
./block/umem.c:287:	writel(0, card->csr_remap + DMA_SEMAPHORE_ADDR + 4);
./block/umem.c:291:	       card->csr_remap + DMA_DESCRIPTOR_ADDR);
./block/umem.c:295:	       card->csr_remap + DMA_DESCRIPTOR_ADDR + 4);
./block/umem.c:299:	       card->csr_remap + DMA_STATUS_CTRL);
./block/umem.c:316:		if (card->Active == -1 &&
./block/umem.c:317:		    card->mm_pages[card->Ready].cnt > 0) {
./block/umem.c:318:			card->Active = card->Ready;
./block/umem.c:319:			card->Ready = 1-card->Ready;
./block/umem.c:323:	} while (card->Active == -1 && add_bio(card));
./block/umem.c:348:	bio = card->currentbio;
./block/umem.c:349:	if (!bio && card->bio) {
./block/umem.c:350:		card->currentbio = card->bio;
./block/umem.c:351:		card->current_iter = card->bio->bi_iter;
./block/umem.c:352:		card->bio = card->bio->bi_next;
./block/umem.c:353:		if (card->bio == NULL)
./block/umem.c:354:			card->biotail = &card->bio;
./block/umem.c:355:		card->currentbio->bi_next = NULL;
./block/umem.c:361:	if (card->mm_pages[card->Ready].cnt >= DESC_PER_PAGE)
./block/umem.c:364:	vec = bio_iter_iovec(bio, card->current_iter);
./block/umem.c:366:	dma_handle = pci_map_page(card->dev,
./block/umem.c:373:	p = &card->mm_pages[card->Ready];
./block/umem.c:377:		p->iter = card->current_iter;
./block/umem.c:387:	desc->local_addr = cpu_to_le64(card->current_iter.bi_sector << 9);
./block/umem.c:404:	bio_advance_iter(bio, &card->current_iter, vec.bv_len);
./block/umem.c:405:	if (!card->current_iter.bi_size)
./block/umem.c:406:		card->currentbio = NULL;
./block/umem.c:422:	unsigned int dma_status = card->dma_status;
./block/umem.c:424:	spin_lock_bh(&card->lock);
./block/umem.c:425:	if (card->Active < 0)
./block/umem.c:427:	page = &card->mm_pages[card->Active];
./block/umem.c:451:		pci_unmap_page(card->dev, desc->data_dma_handle,
./block/umem.c:458:			dev_printk(KERN_WARNING, &card->dev->dev,
./block/umem.c:465:				card->init_size) {
./block/umem.c:466:			card->init_size += le32_to_cpu(desc->transfer_size) >> 9;
./block/umem.c:467:			if (card->init_size >> 1 >= card->mm_size) {
./block/umem.c:468:				dev_printk(KERN_INFO, &card->dev->dev,
./block/umem.c:485:	if (card->check_batteries) {
./block/umem.c:486:		card->check_batteries = 0;
./block/umem.c:491:		card->Active = -1;
./block/umem.c:499:	spin_unlock_bh(&card->lock);
./block/umem.c:514:	spin_lock_irq(&card->lock);
./block/umem.c:516:	spin_unlock_irq(&card->lock);
./block/umem.c:534:	spin_lock_irq(&card->lock);
./block/umem.c:535:	*card->biotail = bio;
./block/umem.c:537:	card->biotail = &bio->bi_next;
./block/umem.c:540:	spin_unlock_irq(&card->lock);
./block/umem.c:553:	dma_status = le32_to_cpu(readl(card->csr_remap + DMA_STATUS_CTRL));
./block/umem.c:561:	if (card->flags & UM_FLAG_NO_BYTE_STATUS)
./block/umem.c:563:		       card->csr_remap + DMA_STATUS_CTRL);
./block/umem.c:566:		       card->csr_remap + DMA_STATUS_CTRL + 2);
./block/umem.c:574:		stat = readb(card->csr_remap + MEMCTRLCMD_ERRSTATUS);
./block/umem.c:576:		data_log1 = le32_to_cpu(readl(card->csr_remap +
./block/umem.c:578:		data_log2 = le32_to_cpu(readl(card->csr_remap +
./block/umem.c:580:		addr_log1 = le32_to_cpu(readl(card->csr_remap +
./block/umem.c:582:		addr_log2 = readb(card->csr_remap + ERROR_ADDR_LOG + 4);
./block/umem.c:584:		count = readb(card->csr_remap + ERROR_COUNT);
./block/umem.c:585:		syndrome = readb(card->csr_remap + ERROR_SYNDROME);
./block/umem.c:586:		check = readb(card->csr_remap + ERROR_CHECK);
./block/umem.c:591:			dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:595:			dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:598:		dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:601:		dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:605:		writeb(0, card->csr_remap + ERROR_COUNT);
./block/umem.c:609:		dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:611:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./block/umem.c:612:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./block/umem.c:616:		dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:618:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./block/umem.c:619:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./block/umem.c:623:		dev_printk(KERN_ERR, &card->dev->dev, "SYSTEM ERROR\n");
./block/umem.c:624:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./block/umem.c:625:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./block/umem.c:629:		dev_printk(KERN_ERR, &card->dev->dev, "TARGET ABORT\n");
./block/umem.c:630:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./block/umem.c:631:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./block/umem.c:635:		dev_printk(KERN_ERR, &card->dev->dev, "MASTER ABORT\n");
./block/umem.c:636:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./block/umem.c:637:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./block/umem.c:641:	card->dma_status = dma_status;
./block/umem.c:642:	tasklet_schedule(&card->tasklet);
./block/umem.c:657:	if (card->battery[0].good && card->battery[1].good)
./block/umem.c:659:	else if (card->battery[0].warned || card->battery[1].warned)
./block/umem.c:661:	else if (!card->battery[0].good && !card->battery[1].good)
./block/umem.c:671:	if (status != card->battery[battery].good) {
./block/umem.c:672:		card->battery[battery].good = !card->battery[battery].good;
./block/umem.c:673:		card->battery[battery].last_change = jiffies;
./block/umem.c:675:		if (card->battery[battery].good) {
./block/umem.c:676:			dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:678:			card->battery[battery].warned = 0;
./block/umem.c:680:			dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:684:	} else if (!card->battery[battery].good &&
./block/umem.c:685:		   !card->battery[battery].warned &&
./block/umem.c:686:		   time_after_eq(jiffies, card->battery[battery].last_change +
./block/umem.c:688:		dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:690:		card->battery[battery].warned = 1;
./block/umem.c:707:	status = readb(card->csr_remap + MEMCTRLSTATUS_BATTERY);
./block/umem.c:709:		dev_printk(KERN_DEBUG, &card->dev->dev,
./block/umem.c:728:			spin_lock_bh(&card->lock);
./block/umem.c:729:			if (card->Active >= 0)
./block/umem.c:730:				card->check_batteries = 1;
./block/umem.c:733:			spin_unlock_bh(&card->lock);
./block/umem.c:763:	set_capacity(disk, card->mm_size << 1);
./block/umem.c:770:	int size = card->mm_size * (1024 / MM_HARDSECT);
./block/umem.c:811:	card->dev         = dev;
./block/umem.c:829:		dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:834:	card->csr_remap = ioremap_nocache(csr_base, csr_len);
./block/umem.c:835:	if (!card->csr_remap) {
./block/umem.c:836:		dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:843:	dev_printk(KERN_INFO, &card->dev->dev,
./block/umem.c:845:	       csr_base, card->csr_remap, csr_len);
./block/umem.c:847:	switch (card->dev->device) {
./block/umem.c:849:		card->flags |= UM_FLAG_NO_BYTE_STATUS | UM_FLAG_NO_BATTREG;
./block/umem.c:854:		card->flags |= UM_FLAG_NO_BYTE_STATUS;
./block/umem.c:859:		card->flags |= UM_FLAG_NO_BYTE_STATUS |
./block/umem.c:869:	if (readb(card->csr_remap + MEMCTRLSTATUS_MAGIC) != magic_number) {
./block/umem.c:870:		dev_printk(KERN_ERR, &card->dev->dev, "Magic number invalid\n");
./block/umem.c:875:	card->mm_pages[0].desc = pci_alloc_consistent(card->dev,
./block/umem.c:877:						&card->mm_pages[0].page_dma);
./block/umem.c:878:	card->mm_pages[1].desc = pci_alloc_consistent(card->dev,
./block/umem.c:880:						&card->mm_pages[1].page_dma);
./block/umem.c:881:	if (card->mm_pages[0].desc == NULL ||
./block/umem.c:882:	    card->mm_pages[1].desc == NULL) {
./block/umem.c:883:		dev_printk(KERN_ERR, &card->dev->dev, "alloc failed\n");
./block/umem.c:886:	reset_page(&card->mm_pages[0]);
./block/umem.c:887:	reset_page(&card->mm_pages[1]);
./block/umem.c:888:	card->Ready = 0;	/* page 0 is ready */
./block/umem.c:889:	card->Active = -1;	/* no page is active */
./block/umem.c:890:	card->bio = NULL;
./block/umem.c:891:	card->biotail = &card->bio;
./block/umem.c:893:	card->queue = blk_alloc_queue(GFP_KERNEL);
./block/umem.c:894:	if (!card->queue)
./block/umem.c:897:	blk_queue_make_request(card->queue, mm_make_request);
./block/umem.c:898:	card->queue->queue_lock = &card->lock;
./block/umem.c:899:	card->queue->queuedata = card;
./block/umem.c:901:	tasklet_init(&card->tasklet, process_page, (unsigned long)card);
./block/umem.c:903:	card->check_batteries = 0;
./block/umem.c:905:	mem_present = readb(card->csr_remap + MEMCTRLSTATUS_MEMORY);
./block/umem.c:908:		card->mm_size = 1024 * 128;
./block/umem.c:911:		card->mm_size = 1024 * 256;
./block/umem.c:914:		card->mm_size = 1024 * 512;
./block/umem.c:917:		card->mm_size = 1024 * 1024;
./block/umem.c:920:		card->mm_size = 1024 * 2048;
./block/umem.c:923:		card->mm_size = 0;
./block/umem.c:931:	batt_status = readb(card->csr_remap + MEMCTRLSTATUS_BATTERY);
./block/umem.c:933:	card->battery[0].good = !(batt_status & BATTERY_1_FAILURE);
./block/umem.c:934:	card->battery[1].good = !(batt_status & BATTERY_2_FAILURE);
./block/umem.c:935:	card->battery[0].last_change = card->battery[1].last_change = jiffies;
./block/umem.c:937:	if (card->flags & UM_FLAG_NO_BATT)
./block/umem.c:938:		dev_printk(KERN_INFO, &card->dev->dev,
./block/umem.c:939:			"Size %d KB\n", card->mm_size);
./block/umem.c:941:		dev_printk(KERN_INFO, &card->dev->dev,
./block/umem.c:943:		       card->mm_size,
./block/umem.c:945:		       card->battery[0].good ? "OK" : "FAILURE",
./block/umem.c:947:		       card->battery[1].good ? "OK" : "FAILURE");
./block/umem.c:963:		dev_printk(KERN_ERR, &card->dev->dev,
./block/umem.c:969:	dev_printk(KERN_INFO, &card->dev->dev,
./block/umem.c:972:	spin_lock_init(&card->lock);
./block/umem.c:990:		dev_printk(KERN_INFO, &card->dev->dev,
./block/umem.c:992:		card->init_size = 0;
./block/umem.c:994:		dev_printk(KERN_INFO, &card->dev->dev,
./block/umem.c:996:		card->init_size = card->mm_size;
./block/umem.c:1000:	writeb(EDC_STORE_CORRECT, card->csr_remap + MEMCTRLCMD_ERRCTRL);
./block/umem.c:1006:	if (card->mm_pages[0].desc)
./block/umem.c:1007:		pci_free_consistent(card->dev, PAGE_SIZE*2,
./block/umem.c:1008:				    card->mm_pages[0].desc,
./block/umem.c:1009:				    card->mm_pages[0].page_dma);
./block/umem.c:1010:	if (card->mm_pages[1].desc)
./block/umem.c:1011:		pci_free_consistent(card->dev, PAGE_SIZE*2,
./block/umem.c:1012:				    card->mm_pages[1].desc,
./block/umem.c:1013:				    card->mm_pages[1].page_dma);
./block/umem.c:1015:	iounmap(card->csr_remap);
./block/umem.c:1027:	tasklet_kill(&card->tasklet);
./block/umem.c:1029:	iounmap(card->csr_remap);
./block/umem.c:1031:	if (card->mm_pages[0].desc)
./block/umem.c:1032:		pci_free_consistent(card->dev, PAGE_SIZE*2,
./block/umem.c:1033:				    card->mm_pages[0].desc,
./block/umem.c:1034:				    card->mm_pages[0].page_dma);
./block/umem.c:1035:	if (card->mm_pages[1].desc)
./block/umem.c:1036:		pci_free_consistent(card->dev, PAGE_SIZE*2,
./block/umem.c:1037:				    card->mm_pages[1].desc,
./block/umem.c:1038:				    card->mm_pages[1].page_dma);
./block/umem.c:1039:	blk_cleanup_queue(card->queue);
./block/xen-blkfront.c:2164:		"discard-granularity", "%u", &discard_granularity,
./block/xen-blkfront.c:2165:		"discard-alignment", "%u", &discard_alignment,
./block/xen-blkfront.c:2172:		!!xenbus_read_unsigned(info->xbdev->otherend, "discard-secure",
./block/umem.h:128:/* bits for card->flags */
./block/xen-blkback/xenbus.c:549:	if (!xenbus_read_unsigned(dev->nodename, "discard-enable", 1))
./block/xen-blkback/xenbus.c:554:			"discard-granularity", "%u",
./block/xen-blkback/xenbus.c:557:			dev_warn(&dev->dev, "writing discard-granularity (%d)", err);
./block/xen-blkback/xenbus.c:561:			"discard-alignment", "%u",
./block/xen-blkback/xenbus.c:564:			dev_warn(&dev->dev, "writing discard-alignment (%d)", err);
./block/xen-blkback/xenbus.c:570:				    "discard-secure", "%d",
./block/xen-blkback/xenbus.c:573:			dev_warn(&dev->dev, "writing discard-secure (%d)", err);
./block/rsxx/dev.c:88:	u64 blocks = card->size8 >> 9;
./block/rsxx/dev.c:94:	if (card->size8) {
./block/rsxx/dev.c:115:	generic_start_io_acct(card->queue, bio_data_dir(bio), bio_sectors(bio),
./block/rsxx/dev.c:116:			     &card->gendisk->part0);
./block/rsxx/dev.c:123:	generic_end_io_acct(card->queue, bio_data_dir(bio),
./block/rsxx/dev.c:124:				&card->gendisk->part0, start_time);
./block/rsxx/dev.c:137:		if (!card->eeh_state && card->gendisk)
./block/rsxx/dev.c:161:	if (bio_end_sector(bio) > get_capacity(card->gendisk))
./block/rsxx/dev.c:164:	if (unlikely(card->halt))
./block/rsxx/dev.c:167:	if (unlikely(card->dma_fault))
./block/rsxx/dev.c:186:	if (!unlikely(card->halt))
./block/rsxx/dev.c:214:	pci_read_config_byte(card->dev, PCI_REVISION_ID, &pci_rev);
./block/rsxx/dev.c:221:	mutex_lock(&card->dev_lock);
./block/rsxx/dev.c:225:		if (card->config_valid)
./block/rsxx/dev.c:226:			set_capacity(card->gendisk, card->size8 >> 9);
./block/rsxx/dev.c:228:			set_capacity(card->gendisk, 0);
./block/rsxx/dev.c:229:		device_add_disk(CARD_TO_DEV(card), card->gendisk);
./block/rsxx/dev.c:230:		card->bdev_attached = 1;
./block/rsxx/dev.c:233:	mutex_unlock(&card->dev_lock);
./block/rsxx/dev.c:240:	mutex_lock(&card->dev_lock);
./block/rsxx/dev.c:242:	if (card->bdev_attached) {
./block/rsxx/dev.c:243:		del_gendisk(card->gendisk);
./block/rsxx/dev.c:244:		card->bdev_attached = 0;
./block/rsxx/dev.c:247:	mutex_unlock(&card->dev_lock);
./block/rsxx/dev.c:254:	mutex_init(&card->dev_lock);
./block/rsxx/dev.c:259:	card->major = register_blkdev(0, DRIVER_NAME);
./block/rsxx/dev.c:260:	if (card->major < 0) {
./block/rsxx/dev.c:265:	card->queue = blk_alloc_queue(GFP_KERNEL);
./block/rsxx/dev.c:266:	if (!card->queue) {
./block/rsxx/dev.c:268:		unregister_blkdev(card->major, DRIVER_NAME);
./block/rsxx/dev.c:272:	card->gendisk = alloc_disk(blkdev_minors);
./block/rsxx/dev.c:273:	if (!card->gendisk) {
./block/rsxx/dev.c:275:		blk_cleanup_queue(card->queue);
./block/rsxx/dev.c:276:		unregister_blkdev(card->major, DRIVER_NAME);
./block/rsxx/dev.c:280:	if (card->config_valid) {
./block/rsxx/dev.c:281:		blk_size = card->config.data.block_size;
./block/rsxx/dev.c:282:		blk_queue_dma_alignment(card->queue, blk_size - 1);
./block/rsxx/dev.c:283:		blk_queue_logical_block_size(card->queue, blk_size);
./block/rsxx/dev.c:286:	blk_queue_make_request(card->queue, rsxx_make_request);
./block/rsxx/dev.c:287:	blk_queue_max_hw_sectors(card->queue, blkdev_max_hw_sectors);
./block/rsxx/dev.c:288:	blk_queue_physical_block_size(card->queue, RSXX_HW_BLK_SIZE);
./block/rsxx/dev.c:290:	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, card->queue);
./block/rsxx/dev.c:291:	queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, card->queue);
./block/rsxx/dev.c:293:		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, card->queue);
./block/rsxx/dev.c:294:		blk_queue_max_discard_sectors(card->queue,
./block/rsxx/dev.c:296:		card->queue->limits.discard_granularity = RSXX_HW_BLK_SIZE;
./block/rsxx/dev.c:297:		card->queue->limits.discard_alignment   = RSXX_HW_BLK_SIZE;
./block/rsxx/dev.c:300:	card->queue->queuedata = card;
./block/rsxx/dev.c:302:	snprintf(card->gendisk->disk_name, sizeof(card->gendisk->disk_name),
./block/rsxx/dev.c:303:		 "rsxx%d", card->disk_id);
./block/rsxx/dev.c:304:	card->gendisk->major = card->major;
./block/rsxx/dev.c:305:	card->gendisk->first_minor = 0;
./block/rsxx/dev.c:306:	card->gendisk->fops = &rsxx_fops;
./block/rsxx/dev.c:307:	card->gendisk->private_data = card;
./block/rsxx/dev.c:308:	card->gendisk->queue = card->queue;
./block/rsxx/dev.c:318:	put_disk(card->gendisk);
./block/rsxx/dev.c:319:	card->gendisk = NULL;
./block/rsxx/dev.c:321:	blk_cleanup_queue(card->queue);
./block/rsxx/dev.c:322:	card->queue->queuedata = NULL;
./block/rsxx/dev.c:323:	unregister_blkdev(card->major, DRIVER_NAME);
./block/rsxx/cregs.c:69:	if (unlikely(card->eeh_state))
./block/rsxx/cregs.c:78:			iowrite32be(data[i], card->regmap + CREG_DATA(i));
./block/rsxx/cregs.c:80:			iowrite32(data[i], card->regmap + CREG_DATA(i));
./block/rsxx/cregs.c:95:	if (unlikely(card->eeh_state))
./block/rsxx/cregs.c:104:			data[i] = ioread32be(card->regmap + CREG_DATA(i));
./block/rsxx/cregs.c:106:			data[i] = ioread32(card->regmap + CREG_DATA(i));
./block/rsxx/cregs.c:116:	if (unlikely(card->eeh_state))
./block/rsxx/cregs.c:119:	iowrite32(cmd->addr, card->regmap + CREG_ADD);
./block/rsxx/cregs.c:120:	iowrite32(cmd->cnt8, card->regmap + CREG_CNT);
./block/rsxx/cregs.c:131:	if (unlikely(card->eeh_state))
./block/rsxx/cregs.c:135:	iowrite32(cmd->op, card->regmap + CREG_CMD);
./block/rsxx/cregs.c:140:	if (card->creg_ctrl.active || list_empty(&card->creg_ctrl.queue))
./block/rsxx/cregs.c:143:	card->creg_ctrl.active = 1;
./block/rsxx/cregs.c:144:	card->creg_ctrl.active_cmd = list_first_entry(&card->creg_ctrl.queue,
./block/rsxx/cregs.c:146:	list_del(&card->creg_ctrl.active_cmd->list);
./block/rsxx/cregs.c:147:	card->creg_ctrl.q_depth--;
./block/rsxx/cregs.c:155:	mod_timer(&card->creg_ctrl.cmd_timer,
./block/rsxx/cregs.c:158:	creg_issue_cmd(card, card->creg_ctrl.active_cmd);
./block/rsxx/cregs.c:173:	if (unlikely(card->halt))
./block/rsxx/cregs.c:176:	if (card->creg_ctrl.reset)
./block/rsxx/cregs.c:197:	spin_lock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:198:	list_add_tail(&cmd->list, &card->creg_ctrl.queue);
./block/rsxx/cregs.c:199:	card->creg_ctrl.q_depth++;
./block/rsxx/cregs.c:201:	spin_unlock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:211:	spin_lock(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:212:	cmd = card->creg_ctrl.active_cmd;
./block/rsxx/cregs.c:213:	card->creg_ctrl.active_cmd = NULL;
./block/rsxx/cregs.c:214:	spin_unlock(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:217:		card->creg_ctrl.creg_stats.creg_timeout++;
./block/rsxx/cregs.c:229:	spin_lock(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:230:	card->creg_ctrl.active = 0;
./block/rsxx/cregs.c:232:	spin_unlock(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:249:	if (del_timer_sync(&card->creg_ctrl.cmd_timer) == 0)
./block/rsxx/cregs.c:250:		card->creg_ctrl.creg_stats.failed_cancel_timer++;
./block/rsxx/cregs.c:252:	spin_lock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:253:	cmd = card->creg_ctrl.active_cmd;
./block/rsxx/cregs.c:254:	card->creg_ctrl.active_cmd = NULL;
./block/rsxx/cregs.c:255:	spin_unlock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:263:	card->creg_ctrl.creg_stats.stat = ioread32(card->regmap + CREG_STAT);
./block/rsxx/cregs.c:264:	cmd->status = card->creg_ctrl.creg_stats.stat;
./block/rsxx/cregs.c:280:		unsigned int cnt8 = ioread32(card->regmap + CREG_CNT);
./block/rsxx/cregs.c:305:	spin_lock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:306:	card->creg_ctrl.active = 0;
./block/rsxx/cregs.c:308:	spin_unlock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:321:	if (!mutex_trylock(&card->creg_ctrl.reset_lock))
./block/rsxx/cregs.c:324:	card->creg_ctrl.reset = 1;
./block/rsxx/cregs.c:325:	spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/cregs.c:327:	spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/cregs.c:333:	spin_lock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:334:	list_for_each_entry_safe(cmd, tmp, &card->creg_ctrl.queue, list) {
./block/rsxx/cregs.c:336:		card->creg_ctrl.q_depth--;
./block/rsxx/cregs.c:342:	cmd = card->creg_ctrl.active_cmd;
./block/rsxx/cregs.c:343:	card->creg_ctrl.active_cmd = NULL;
./block/rsxx/cregs.c:345:		if (timer_pending(&card->creg_ctrl.cmd_timer))
./block/rsxx/cregs.c:346:			del_timer_sync(&card->creg_ctrl.cmd_timer);
./block/rsxx/cregs.c:352:		card->creg_ctrl.active = 0;
./block/rsxx/cregs.c:354:	spin_unlock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:356:	card->creg_ctrl.reset = 0;
./block/rsxx/cregs.c:357:	spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/cregs.c:359:	spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/cregs.c:361:	mutex_unlock(&card->creg_ctrl.reset_lock);
./block/rsxx/cregs.c:413:				   card->creg_ctrl.q_depth + 20000);
./block/rsxx/cregs.c:441:		ioread32(card->regmap + SCRATCH);
./block/rsxx/cregs.c:627:		log_str = &card->log.buf[card->log.buf_len];
./block/rsxx/cregs.c:628:		cnt = min(cmd->cnt8 - off, LOG_BUF_SIZE8 - card->log.buf_len);
./block/rsxx/cregs.c:632:		card->log.buf_len += len;
./block/rsxx/cregs.c:639:		    (card->log.buf_len == LOG_BUF_SIZE8)) {
./block/rsxx/cregs.c:640:			if (card->log.buf_len != 1) /* Don't log blank lines. */
./block/rsxx/cregs.c:641:				hw_log_msg(card, card->log.buf,
./block/rsxx/cregs.c:642:					   card->log.buf_len);
./block/rsxx/cregs.c:643:			card->log.buf_len = 0;
./block/rsxx/cregs.c:657:			    sizeof(card->log.tmp), card->log.tmp,
./block/rsxx/cregs.c:712:	cmd = card->creg_ctrl.active_cmd;
./block/rsxx/cregs.c:713:	card->creg_ctrl.active_cmd = NULL;
./block/rsxx/cregs.c:716:		del_timer_sync(&card->creg_ctrl.cmd_timer);
./block/rsxx/cregs.c:718:		spin_lock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:719:		list_add(&cmd->list, &card->creg_ctrl.queue);
./block/rsxx/cregs.c:720:		card->creg_ctrl.q_depth++;
./block/rsxx/cregs.c:721:		card->creg_ctrl.active = 0;
./block/rsxx/cregs.c:722:		spin_unlock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:728:	spin_lock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:729:	if (!list_empty(&card->creg_ctrl.queue))
./block/rsxx/cregs.c:731:	spin_unlock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:737:	card->creg_ctrl.active_cmd = NULL;
./block/rsxx/cregs.c:739:	card->creg_ctrl.creg_wq =
./block/rsxx/cregs.c:741:	if (!card->creg_ctrl.creg_wq)
./block/rsxx/cregs.c:744:	INIT_WORK(&card->creg_ctrl.done_work, creg_cmd_done);
./block/rsxx/cregs.c:745:	mutex_init(&card->creg_ctrl.reset_lock);
./block/rsxx/cregs.c:746:	INIT_LIST_HEAD(&card->creg_ctrl.queue);
./block/rsxx/cregs.c:747:	spin_lock_init(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:748:	setup_timer(&card->creg_ctrl.cmd_timer, creg_cmd_timed_out,
./block/rsxx/cregs.c:761:	spin_lock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:762:	list_for_each_entry_safe(cmd, tmp, &card->creg_ctrl.queue, list) {
./block/rsxx/cregs.c:774:	cmd = card->creg_ctrl.active_cmd;
./block/rsxx/cregs.c:775:	card->creg_ctrl.active_cmd = NULL;
./block/rsxx/cregs.c:777:		if (timer_pending(&card->creg_ctrl.cmd_timer))
./block/rsxx/cregs.c:778:			del_timer_sync(&card->creg_ctrl.cmd_timer);
./block/rsxx/cregs.c:786:	spin_unlock_bh(&card->creg_ctrl.lock);
./block/rsxx/cregs.c:788:	cancel_work_sync(&card->creg_ctrl.done_work);
./block/rsxx/config.c:103:	memcpy(&cfg, &card->config, sizeof(cfg));
./block/rsxx/config.c:136:	st = rsxx_creg_read(card, CREG_ADD_CONFIG, sizeof(card->config),
./block/rsxx/config.c:137:				&card->config, 1);
./block/rsxx/config.c:144:	config_hdr_be_to_cpu(&card->config.hdr);
./block/rsxx/config.c:146:	if (card->config.hdr.version == RSXX_CFG_VERSION) {
./block/rsxx/config.c:154:		config_data_swab(&card->config);
./block/rsxx/config.c:157:		crc = config_data_crc32(&card->config);
./block/rsxx/config.c:158:		if (crc != card->config.hdr.crc) {
./block/rsxx/config.c:163:				card->config.hdr.crc, crc);
./block/rsxx/config.c:168:		config_data_le_to_cpu(&card->config);
./block/rsxx/config.c:170:	} else if (card->config.hdr.version != 0) {
./block/rsxx/config.c:173:			card->config.hdr.version);
./block/rsxx/config.c:182:		initialize_config(&card->config);
./block/rsxx/config.c:188:	card->config_valid = 1;
./block/rsxx/config.c:191:		card->config.hdr.version);
./block/rsxx/config.c:193:		card->config.hdr.crc);
./block/rsxx/config.c:195:		card->config.data.block_size);
./block/rsxx/config.c:197:		card->config.data.stripe_size);
./block/rsxx/config.c:199:		card->config.data.vendor_id);
./block/rsxx/config.c:201:		card->config.data.cache_order);
./block/rsxx/config.c:203:		card->config.data.intr_coal.mode);
./block/rsxx/config.c:205:		card->config.data.intr_coal.count);
./block/rsxx/config.c:207:		 card->config.data.intr_coal.latency);
./block/rsxx/core.c:70:					ioread32(card->regmap + HWID));
./block/rsxx/core.c:72:					ioread32(card->regmap + SCRATCH));
./block/rsxx/core.c:74:					ioread32(card->regmap + IER));
./block/rsxx/core.c:76:					ioread32(card->regmap + IPR));
./block/rsxx/core.c:78:					ioread32(card->regmap + CREG_CMD));
./block/rsxx/core.c:80:					ioread32(card->regmap + CREG_ADD));
./block/rsxx/core.c:82:					ioread32(card->regmap + CREG_CNT));
./block/rsxx/core.c:84:					ioread32(card->regmap + CREG_STAT));
./block/rsxx/core.c:86:					ioread32(card->regmap + CREG_DATA0));
./block/rsxx/core.c:88:					ioread32(card->regmap + CREG_DATA1));
./block/rsxx/core.c:90:					ioread32(card->regmap + CREG_DATA2));
./block/rsxx/core.c:92:					ioread32(card->regmap + CREG_DATA3));
./block/rsxx/core.c:94:					ioread32(card->regmap + CREG_DATA4));
./block/rsxx/core.c:96:					ioread32(card->regmap + CREG_DATA5));
./block/rsxx/core.c:98:					ioread32(card->regmap + CREG_DATA6));
./block/rsxx/core.c:100:					ioread32(card->regmap + CREG_DATA7));
./block/rsxx/core.c:102:					ioread32(card->regmap + INTR_COAL));
./block/rsxx/core.c:104:					ioread32(card->regmap + HW_ERROR));
./block/rsxx/core.c:106:					ioread32(card->regmap + PCI_DEBUG0));
./block/rsxx/core.c:108:					ioread32(card->regmap + PCI_DEBUG1));
./block/rsxx/core.c:110:					ioread32(card->regmap + PCI_DEBUG2));
./block/rsxx/core.c:112:					ioread32(card->regmap + PCI_DEBUG3));
./block/rsxx/core.c:114:					ioread32(card->regmap + PCI_DEBUG4));
./block/rsxx/core.c:116:					ioread32(card->regmap + PCI_DEBUG5));
./block/rsxx/core.c:118:					ioread32(card->regmap + PCI_DEBUG6));
./block/rsxx/core.c:120:					ioread32(card->regmap + PCI_DEBUG7));
./block/rsxx/core.c:122:					ioread32(card->regmap + PCI_RECONFIG));
./block/rsxx/core.c:132:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:134:				i, card->ctrl[i].stats.crc_errors);
./block/rsxx/core.c:136:				i, card->ctrl[i].stats.hard_errors);
./block/rsxx/core.c:138:				i, card->ctrl[i].stats.soft_errors);
./block/rsxx/core.c:140:				i, card->ctrl[i].stats.writes_issued);
./block/rsxx/core.c:142:				i, card->ctrl[i].stats.writes_failed);
./block/rsxx/core.c:144:				i, card->ctrl[i].stats.reads_issued);
./block/rsxx/core.c:146:				i, card->ctrl[i].stats.reads_failed);
./block/rsxx/core.c:148:				i, card->ctrl[i].stats.reads_retried);
./block/rsxx/core.c:150:				i, card->ctrl[i].stats.discards_issued);
./block/rsxx/core.c:152:				i, card->ctrl[i].stats.discards_failed);
./block/rsxx/core.c:154:				i, card->ctrl[i].stats.dma_sw_err);
./block/rsxx/core.c:156:				i, card->ctrl[i].stats.dma_hw_fault);
./block/rsxx/core.c:158:				i, card->ctrl[i].stats.dma_cancelled);
./block/rsxx/core.c:160:				i, card->ctrl[i].stats.sw_q_depth);
./block/rsxx/core.c:162:			i, atomic_read(&card->ctrl[i].stats.hw_q_depth));
./block/rsxx/core.c:246:	card->debugfs_dir = debugfs_create_dir(card->gendisk->disk_name, NULL);
./block/rsxx/core.c:247:	if (IS_ERR_OR_NULL(card->debugfs_dir))
./block/rsxx/core.c:251:					    card->debugfs_dir, card,
./block/rsxx/core.c:257:					       card->debugfs_dir, card,
./block/rsxx/core.c:263:					   card->debugfs_dir, card,
./block/rsxx/core.c:274:	debugfs_remove(card->debugfs_dir);
./block/rsxx/core.c:276:	card->debugfs_dir = NULL;
./block/rsxx/core.c:283:	card->isr_mask = 0;
./block/rsxx/core.c:284:	card->ier_mask = 0;
./block/rsxx/core.c:301: * Enable/Disable interrupt functions assume the card->irq_lock
./block/rsxx/core.c:306:	if (unlikely(card->halt) ||
./block/rsxx/core.c:307:	    unlikely(card->eeh_state))
./block/rsxx/core.c:310:	__enable_intr(&card->ier_mask, intr);
./block/rsxx/core.c:311:	iowrite32(card->ier_mask, card->regmap + IER);
./block/rsxx/core.c:316:	if (unlikely(card->eeh_state))
./block/rsxx/core.c:319:	__disable_intr(&card->ier_mask, intr);
./block/rsxx/core.c:320:	iowrite32(card->ier_mask, card->regmap + IER);
./block/rsxx/core.c:326:	if (unlikely(card->halt) ||
./block/rsxx/core.c:327:	    unlikely(card->eeh_state))
./block/rsxx/core.c:330:	__enable_intr(&card->isr_mask, intr);
./block/rsxx/core.c:331:	__enable_intr(&card->ier_mask, intr);
./block/rsxx/core.c:332:	iowrite32(card->ier_mask, card->regmap + IER);
./block/rsxx/core.c:337:	if (unlikely(card->eeh_state))
./block/rsxx/core.c:340:	__disable_intr(&card->isr_mask, intr);
./block/rsxx/core.c:341:	__disable_intr(&card->ier_mask, intr);
./block/rsxx/core.c:342:	iowrite32(card->ier_mask, card->regmap + IER);
./block/rsxx/core.c:353:	spin_lock(&card->irq_lock);
./block/rsxx/core.c:358:		if (unlikely(card->eeh_state))
./block/rsxx/core.c:361:		isr = ioread32(card->regmap + ISR);
./block/rsxx/core.c:373:		isr &= card->isr_mask;
./block/rsxx/core.c:377:		for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:379:				if (card->ier_mask & CR_INTR_DMA(i)) {
./block/rsxx/core.c:383:				queue_work(card->ctrl[i].done_wq,
./block/rsxx/core.c:384:					   &card->ctrl[i].dma_done_work);
./block/rsxx/core.c:390:			queue_work(card->creg_ctrl.creg_wq,
./block/rsxx/core.c:391:				   &card->creg_ctrl.done_work);
./block/rsxx/core.c:396:			queue_work(card->event_wq, &card->event_work);
./block/rsxx/core.c:402:	spin_unlock(&card->irq_lock);
./block/rsxx/core.c:426:		rsxx_card_state_to_str(card->state),
./block/rsxx/core.c:429:	card->state = new_state;
./block/rsxx/core.c:432:	if (!card->config_valid)
./block/rsxx/core.c:444:		st = rsxx_get_card_size8(card, &card->size8);
./block/rsxx/core.c:449:		if (card->config_valid)
./block/rsxx/core.c:450:			set_capacity(card->gendisk, card->size8 >> 9);
./block/rsxx/core.c:469:		set_capacity(card->gendisk, 0);
./block/rsxx/core.c:483:	if (unlikely(card->halt))
./block/rsxx/core.c:491:	spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/core.c:493:	spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/core.c:502:	if (card->state != state)
./block/rsxx/core.c:505:	if (card->creg_ctrl.creg_stats.stat & CREG_STAT_LOG_PENDING)
./block/rsxx/core.c:559:	card->eeh_state = 1;
./block/rsxx/core.c:577:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:578:		if (card->ctrl[i].status.buf)
./block/rsxx/core.c:579:			pci_free_consistent(card->dev, STATUS_BUFFER_SIZE8,
./block/rsxx/core.c:580:					    card->ctrl[i].status.buf,
./block/rsxx/core.c:581:					    card->ctrl[i].status.dma_addr);
./block/rsxx/core.c:582:		if (card->ctrl[i].cmd.buf)
./block/rsxx/core.c:583:			pci_free_consistent(card->dev, COMMAND_BUFFER_SIZE8,
./block/rsxx/core.c:584:					    card->ctrl[i].cmd.buf,
./block/rsxx/core.c:585:					    card->ctrl[i].cmd.dma_addr);
./block/rsxx/core.c:599:	card->eeh_state = 1;
./block/rsxx/core.c:600:	card->halt = 1;
./block/rsxx/core.c:602:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:603:		spin_lock_bh(&card->ctrl[i].queue_lock);
./block/rsxx/core.c:604:		cnt = rsxx_cleanup_dma_queue(&card->ctrl[i],
./block/rsxx/core.c:605:					     &card->ctrl[i].queue,
./block/rsxx/core.c:607:		spin_unlock_bh(&card->ctrl[i].queue_lock);
./block/rsxx/core.c:609:		cnt += rsxx_dma_cancel(&card->ctrl[i]);
./block/rsxx/core.c:614:				cnt, card->ctrl[i].id);
./block/rsxx/core.c:625:		status = ioread32(card->regmap + PCI_RECONFIG);
./block/rsxx/core.c:686:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:687:		st = rsxx_hw_buffers_init(dev, &card->ctrl[i]);
./block/rsxx/core.c:692:	if (card->config_valid)
./block/rsxx/core.c:696:	st = ioread32(card->regmap + ISR);
./block/rsxx/core.c:698:	card->eeh_state = 0;
./block/rsxx/core.c:700:	spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/core.c:701:	if (card->n_targets & RSXX_MAX_TARGETS)
./block/rsxx/core.c:705:	spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/core.c:709:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:710:		spin_lock(&card->ctrl[i].queue_lock);
./block/rsxx/core.c:711:		if (list_empty(&card->ctrl[i].queue)) {
./block/rsxx/core.c:712:			spin_unlock(&card->ctrl[i].queue_lock);
./block/rsxx/core.c:715:		spin_unlock(&card->ctrl[i].queue_lock);
./block/rsxx/core.c:717:		queue_work(card->ctrl[i].issue_wq,
./block/rsxx/core.c:718:				&card->ctrl[i].issue_dma_work);
./block/rsxx/core.c:726:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:727:		if (card->ctrl[i].status.buf)
./block/rsxx/core.c:728:			pci_free_consistent(card->dev,
./block/rsxx/core.c:730:					card->ctrl[i].status.buf,
./block/rsxx/core.c:731:					card->ctrl[i].status.dma_addr);
./block/rsxx/core.c:732:		if (card->ctrl[i].cmd.buf)
./block/rsxx/core.c:733:			pci_free_consistent(card->dev,
./block/rsxx/core.c:735:					card->ctrl[i].cmd.buf,
./block/rsxx/core.c:736:					card->ctrl[i].cmd.dma_addr);
./block/rsxx/core.c:751:	pci_read_config_byte(card->dev, PCI_REVISION_ID, &pci_rev);
./block/rsxx/core.c:771:	card->dev = dev;
./block/rsxx/core.c:781:		st = ida_get_new(&rsxx_disk_ida, &card->disk_id);
./block/rsxx/core.c:815:	card->regmap = pci_iomap(dev, 0, 0);
./block/rsxx/core.c:816:	if (!card->regmap) {
./block/rsxx/core.c:822:	spin_lock_init(&card->irq_lock);
./block/rsxx/core.c:823:	card->halt = 0;
./block/rsxx/core.c:824:	card->eeh_state = 0;
./block/rsxx/core.c:826:	spin_lock_irq(&card->irq_lock);
./block/rsxx/core.c:828:	spin_unlock_irq(&card->irq_lock);
./block/rsxx/core.c:852:	spin_lock_irq(&card->irq_lock);
./block/rsxx/core.c:854:	spin_unlock_irq(&card->irq_lock);
./block/rsxx/core.c:871:	st = rsxx_get_num_targets(card, &card->n_targets);
./block/rsxx/core.c:876:	card->ctrl = kzalloc(card->n_targets * sizeof(*card->ctrl), GFP_KERNEL);
./block/rsxx/core.c:877:	if (!card->ctrl) {
./block/rsxx/core.c:890:	card->event_wq = create_singlethread_workqueue(DRIVER_NAME"_event");
./block/rsxx/core.c:891:	if (!card->event_wq) {
./block/rsxx/core.c:896:	INIT_WORK(&card->event_work, card_event_handler);
./block/rsxx/core.c:902:	rsxx_get_card_state(card, &card->state);
./block/rsxx/core.c:906:		rsxx_card_state_to_str(card->state));
./block/rsxx/core.c:913:	spin_lock_irq(&card->irq_lock);
./block/rsxx/core.c:915:	spin_unlock_irq(&card->irq_lock);
./block/rsxx/core.c:917:	if (card->state == CARD_STATE_SHUTDOWN) {
./block/rsxx/core.c:932:				rsxx_get_card_state(card, &card->state);
./block/rsxx/core.c:934:				(card->state == CARD_STATE_STARTING));
./block/rsxx/core.c:936:			if (card->state == CARD_STATE_STARTING) {
./block/rsxx/core.c:939:				card->size8 = 0;
./block/rsxx/core.c:943:					rsxx_card_state_to_str(card->state));
./block/rsxx/core.c:944:				st = rsxx_get_card_size8(card, &card->size8);
./block/rsxx/core.c:946:					card->size8 = 0;
./block/rsxx/core.c:949:	} else if (card->state == CARD_STATE_GOOD ||
./block/rsxx/core.c:950:		   card->state == CARD_STATE_RD_ONLY_FAULT) {
./block/rsxx/core.c:951:		st = rsxx_get_card_size8(card, &card->size8);
./block/rsxx/core.c:953:			card->size8 = 0;
./block/rsxx/core.c:964:	destroy_workqueue(card->event_wq);
./block/rsxx/core.c:965:	card->event_wq = NULL;
./block/rsxx/core.c:970:	destroy_workqueue(card->creg_ctrl.creg_wq);
./block/rsxx/core.c:971:	card->creg_ctrl.creg_wq = NULL;
./block/rsxx/core.c:973:	spin_lock_irq(&card->irq_lock);
./block/rsxx/core.c:975:	spin_unlock_irq(&card->irq_lock);
./block/rsxx/core.c:980:	pci_iounmap(dev, card->regmap);
./block/rsxx/core.c:988:	ida_remove(&rsxx_disk_ida, card->disk_id);
./block/rsxx/core.c:1011:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:1012:		spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/core.c:1014:		spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/core.c:1022:	spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/core.c:1024:	spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/core.c:1026:	cancel_work_sync(&card->event_work);
./block/rsxx/core.c:1031:	spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/core.c:1033:	spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/core.c:1036:	card->halt = 1;
./block/rsxx/core.c:1038:	debugfs_remove_recursive(card->debugfs_dir);
./block/rsxx/core.c:1047:	pci_iounmap(dev, card->regmap);
./block/rsxx/core.c:1074:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/core.c:1075:		spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/core.c:1077:		spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/dma.c:106:	tgt_addr8 = ((addr8 >> card->_stripe.upper_shift) &
./block/rsxx/dma.c:107:		      card->_stripe.upper_mask) |
./block/rsxx/dma.c:108:		    ((addr8) & card->_stripe.lower_mask);
./block/rsxx/dma.c:117:	tgt = (addr8 >> card->_stripe.target_shift) & card->_stripe.target_mask;
./block/rsxx/dma.c:125:	iowrite32(DMA_QUEUE_RESET, card->regmap + RESET);
./block/rsxx/dma.c:210:	if (card->config.data.intr_coal.mode != RSXX_INTR_COAL_AUTO_TUNE ||
./block/rsxx/dma.c:211:	    unlikely(card->eeh_state))
./block/rsxx/dma.c:214:	for (i = 0; i < card->n_targets; i++)
./block/rsxx/dma.c:215:		q_depth += atomic_read(&card->ctrl[i].stats.hw_q_depth);
./block/rsxx/dma.c:217:	intr_coal = dma_intr_coal_val(card->config.data.intr_coal.mode,
./block/rsxx/dma.c:219:				      card->config.data.intr_coal.latency);
./block/rsxx/dma.c:220:	iowrite32(intr_coal, card->regmap + INTR_COAL);
./block/rsxx/dma.c:227:		if (!pci_dma_mapping_error(ctrl->card->dev, dma->dma_addr)) {
./block/rsxx/dma.c:228:			pci_unmap_page(ctrl->card->dev, dma->dma_addr,
./block/rsxx/dma.c:309:			if (ctrl->card->scrub_hard) {
./block/rsxx/dma.c:363:	    unlikely(ctrl->card->eeh_state))
./block/rsxx/dma.c:380:		ctrl->card->dma_fault = 1;
./block/rsxx/dma.c:406:	if (unlikely(ctrl->card->halt) ||
./block/rsxx/dma.c:407:	    unlikely(ctrl->card->eeh_state))
./block/rsxx/dma.c:433:		if (unlikely(ctrl->card->dma_fault)) {
./block/rsxx/dma.c:455:			dma->dma_addr = pci_map_page(ctrl->card->dev, dma->page,
./block/rsxx/dma.c:457:			if (pci_dma_mapping_error(ctrl->card->dev, dma->dma_addr)) {
./block/rsxx/dma.c:499:		if (unlikely(ctrl->card->eeh_state)) {
./block/rsxx/dma.c:519:	if (unlikely(ctrl->card->halt) ||
./block/rsxx/dma.c:520:	    unlikely(ctrl->card->dma_fault) ||
./block/rsxx/dma.c:521:	    unlikely(ctrl->card->eeh_state))
./block/rsxx/dma.c:541:			spin_lock_irqsave(&ctrl->card->irq_lock, flags);
./block/rsxx/dma.c:543:			spin_unlock_irqrestore(&ctrl->card->irq_lock, flags);
./block/rsxx/dma.c:582:	spin_lock_irqsave(&ctrl->card->irq_lock, flags);
./block/rsxx/dma.c:584:	spin_unlock_irqrestore(&ctrl->card->irq_lock, flags);
./block/rsxx/dma.c:703:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/dma.c:754:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/dma.c:756:			spin_lock_bh(&card->ctrl[i].queue_lock);
./block/rsxx/dma.c:757:			card->ctrl[i].stats.sw_q_depth += dma_cnt[i];
./block/rsxx/dma.c:758:			list_splice_tail(&dma_list[i], &card->ctrl[i].queue);
./block/rsxx/dma.c:759:			spin_unlock_bh(&card->ctrl[i].queue_lock);
./block/rsxx/dma.c:761:			queue_work(card->ctrl[i].issue_wq,
./block/rsxx/dma.c:762:				   &card->ctrl[i].issue_dma_work);
./block/rsxx/dma.c:769:	for (i = 0; i < card->n_targets; i++)
./block/rsxx/dma.c:770:		rsxx_cleanup_dma_queue(&card->ctrl[i], &dma_list[i],
./block/rsxx/dma.c:871:	card->_stripe.lower_mask = stripe_size8 - 1;
./block/rsxx/dma.c:873:	card->_stripe.upper_mask  = ~(card->_stripe.lower_mask);
./block/rsxx/dma.c:874:	card->_stripe.upper_shift = ffs(card->n_targets) - 1;
./block/rsxx/dma.c:876:	card->_stripe.target_mask = card->n_targets - 1;
./block/rsxx/dma.c:877:	card->_stripe.target_shift = ffs(stripe_size8) - 1;
./block/rsxx/dma.c:880:		card->_stripe.lower_mask);
./block/rsxx/dma.c:882:		card->_stripe.upper_shift);
./block/rsxx/dma.c:884:		card->_stripe.upper_mask);
./block/rsxx/dma.c:886:		card->_stripe.target_mask);
./block/rsxx/dma.c:888:		card->_stripe.target_shift);
./block/rsxx/dma.c:897:	intr_coal = dma_intr_coal_val(card->config.data.intr_coal.mode,
./block/rsxx/dma.c:898:				      card->config.data.intr_coal.count,
./block/rsxx/dma.c:899:				      card->config.data.intr_coal.latency);
./block/rsxx/dma.c:900:	iowrite32(intr_coal, card->regmap + INTR_COAL);
./block/rsxx/dma.c:902:	return rsxx_dma_stripe_setup(card, card->config.data.stripe_size);
./block/rsxx/dma.c:913:		card->n_targets);
./block/rsxx/dma.c:916:	for (i = 0; i < card->n_targets; i++)
./block/rsxx/dma.c:917:		card->ctrl[i].regmap = card->regmap + (i * 4096);
./block/rsxx/dma.c:919:	card->dma_fault = 0;
./block/rsxx/dma.c:925:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/dma.c:926:		st = rsxx_dma_ctrl_init(card->dev, &card->ctrl[i]);
./block/rsxx/dma.c:930:		card->ctrl[i].card = card;
./block/rsxx/dma.c:931:		card->ctrl[i].id = i;
./block/rsxx/dma.c:934:	card->scrub_hard = 1;
./block/rsxx/dma.c:936:	if (card->config_valid)
./block/rsxx/dma.c:940:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/dma.c:941:		spin_lock_irqsave(&card->irq_lock, flags);
./block/rsxx/dma.c:943:		spin_unlock_irqrestore(&card->irq_lock, flags);
./block/rsxx/dma.c:949:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/dma.c:950:		struct rsxx_dma_ctrl *ctrl = &card->ctrl[i];
./block/rsxx/dma.c:966:			pci_free_consistent(card->dev, STATUS_BUFFER_SIZE8,
./block/rsxx/dma.c:970:			pci_free_consistent(card->dev, COMMAND_BUFFER_SIZE8,
./block/rsxx/dma.c:1002:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/dma.c:1003:		ctrl = &card->ctrl[i];
./block/rsxx/dma.c:1027:		pci_free_consistent(card->dev, STATUS_BUFFER_SIZE8,
./block/rsxx/dma.c:1029:		pci_free_consistent(card->dev, COMMAND_BUFFER_SIZE8,
./block/rsxx/dma.c:1042:	issued_dmas = kzalloc(sizeof(*issued_dmas) * card->n_targets,
./block/rsxx/dma.c:1047:	for (i = 0; i < card->n_targets; i++) {
./block/rsxx/dma.c:1051:			dma = get_tracker_dma(card->ctrl[i].trackers, j);
./block/rsxx/dma.c:1056:				card->ctrl[i].stats.writes_issued--;
./block/rsxx/dma.c:1058:				card->ctrl[i].stats.discards_issued--;
./block/rsxx/dma.c:1060:				card->ctrl[i].stats.reads_issued--;
./block/rsxx/dma.c:1063:				pci_unmap_page(card->dev, dma->dma_addr,
./block/rsxx/dma.c:1071:			push_tracker(card->ctrl[i].trackers, j);
./block/rsxx/dma.c:1075:		spin_lock_bh(&card->ctrl[i].queue_lock);
./block/rsxx/dma.c:1076:		list_splice(&issued_dmas[i], &card->ctrl[i].queue);
./block/rsxx/dma.c:1078:		atomic_sub(cnt, &card->ctrl[i].stats.hw_q_depth);
./block/rsxx/dma.c:1079:		card->ctrl[i].stats.sw_q_depth += cnt;
./block/rsxx/dma.c:1080:		card->ctrl[i].e_cnt = 0;
./block/rsxx/dma.c:1081:		spin_unlock_bh(&card->ctrl[i].queue_lock);
./block/drbd/drbd_receiver.c:2969:		     "Using discard-least-changes instead\n");
./block/drbd/drbd_receiver.c:3594:			drbd_err(connection, "incompatible %s settings\n", "discard-my-data");
./parport/parport_serial.c:552:	if (card->preinit_hook &&
./parport/parport_serial.c:553:	    card->preinit_hook (dev, card, PARPORT_IRQ_NONE, PARPORT_DMA_NONE))
./parport/parport_serial.c:556:	for (n = 0; n < card->numports; n++) {
./parport/parport_serial.c:558:		int lo = card->addr[n].lo;
./parport/parport_serial.c:559:		int hi = card->addr[n].hi;
./parport/parport_serial.c:567:				ARRAY_SIZE(priv->port), card->numports);
./parport/parport_serial.c:599:	if (card->postinit_hook)
./parport/parport_serial.c:600:		card->postinit_hook (dev, card, !success);
./misc/genwqe/Makefile:6:genwqe_card-objs := card_base.o card_dev.o card_ddcb.o card_sysfs.o \
./misc/mic/cosm/cosm_main.h:34: * @COSM_MSG_HEARTBEAT: card->host heartbeat
./misc/mic/cosm/cosm_main.h:35: * @COSM_MSG_SHUTDOWN_STATUS: card->host with shutdown status as payload
./misc/mic/vop/vop_vringh.c:1023: * in the card->host (TX) path, when userspace is unblocked by poll it
./misc/mic/card/Makefile:9:mic_card-y += mic_x100.o
./misc/mic/card/Makefile:10:mic_card-y += mic_device.o
./misc/mic/card/Makefile:11:mic_card-y += mic_debugfs.o
./memstick/host/rtsx_usb_ms.c:260:		if (card->id.type != MEMSTICK_TYPE_PRO)
./memstick/host/rtsx_usb_ms.c:268:		if (card->id.type != MEMSTICK_TYPE_PRO)
./memstick/host/rtsx_usb_ms.c:278:	if (card->id.type == MEMSTICK_TYPE_PRO) {
./memstick/host/rtsx_pci_ms.c:149:	bool pro_card = card->id.type == MEMSTICK_TYPE_PRO;
./memstick/core/memstick.c:35:		if ((id->type == card->id.type)
./memstick/core/memstick.c:36:		    && (id->category == card->id.category)
./memstick/core/memstick.c:37:		    && (id->class == card->id.class))
./memstick/core/memstick.c:68:	if (add_uevent_var(env, "MEMSTICK_TYPE=%02X", card->id.type))
./memstick/core/memstick.c:71:	if (add_uevent_var(env, "MEMSTICK_CATEGORY=%02X", card->id.category))
./memstick/core/memstick.c:74:	if (add_uevent_var(env, "MEMSTICK_CLASS=%02X", card->id.class))
./memstick/core/memstick.c:107:		card->dev.driver = NULL;
./memstick/core/memstick.c:155:	return sprintf(buf, format, card->id.name);                           \
./memstick/core/memstick.c:236:	if (host->card && host->card->next_request)
./memstick/core/memstick.c:237:		rc = host->card->next_request(host->card, mrq);
./memstick/core/memstick.c:256:		reinit_completion(&host->card->mrq_complete);
./memstick/core/memstick.c:333:		memstick_init_req(&card->current_mrq, MS_TPC_READ_REG, &id_reg,
./memstick/core/memstick.c:335:		*mrq = &card->current_mrq;
./memstick/core/memstick.c:340:			card->id.match_flags = MEMSTICK_MATCH_ALL;
./memstick/core/memstick.c:341:			card->id.type = id_reg.type;
./memstick/core/memstick.c:342:			card->id.category = id_reg.category;
./memstick/core/memstick.c:343:			card->id.class = id_reg.class;
./memstick/core/memstick.c:344:			dev_dbg(&card->dev, "if_mode = %02x\n", id_reg.if_mode);
./memstick/core/memstick.c:346:		complete(&card->mrq_complete);
./memstick/core/memstick.c:355:		memstick_init_req(&card->current_mrq, MS_TPC_SET_RW_REG_ADRS,
./memstick/core/memstick.c:356:				  (char *)&card->reg_addr,
./memstick/core/memstick.c:357:				  sizeof(card->reg_addr));
./memstick/core/memstick.c:358:		*mrq = &card->current_mrq;
./memstick/core/memstick.c:361:		complete(&card->mrq_complete);
./memstick/core/memstick.c:373:	card->next_request = h_memstick_set_rw_addr;
./memstick/core/memstick.c:374:	memstick_new_req(card->host);
./memstick/core/memstick.c:375:	wait_for_completion(&card->mrq_complete);
./memstick/core/memstick.c:377:	return card->current_mrq.error;
./memstick/core/memstick.c:389:		card->host = host;
./memstick/core/memstick.c:390:		dev_set_name(&card->dev, "%s", dev_name(&host->dev));
./memstick/core/memstick.c:391:		card->dev.parent = &host->dev;
./memstick/core/memstick.c:392:		card->dev.bus = &memstick_bus_type;
./memstick/core/memstick.c:393:		card->dev.release = memstick_free_card;
./memstick/core/memstick.c:394:		card->check = memstick_dummy_check;
./memstick/core/memstick.c:396:		card->reg_addr.r_offset = offsetof(struct ms_register, id);
./memstick/core/memstick.c:397:		card->reg_addr.r_length = sizeof(id_reg);
./memstick/core/memstick.c:398:		card->reg_addr.w_offset = offsetof(struct ms_register, id);
./memstick/core/memstick.c:399:		card->reg_addr.w_length = sizeof(id_reg);
./memstick/core/memstick.c:401:		init_completion(&card->mrq_complete);
./memstick/core/memstick.c:407:		card->next_request = h_memstick_read_dev_id;
./memstick/core/memstick.c:409:		wait_for_completion(&card->mrq_complete);
./memstick/core/memstick.c:411:		if (card->current_mrq.error)
./memstick/core/memstick.c:443:	} else if (host->card->stop)
./memstick/core/memstick.c:444:		host->card->stop(host->card);
./memstick/core/memstick.c:450:			device_unregister(&host->card->dev);
./memstick/core/memstick.c:455:			card->id.type, card->id.category, card->id.class);
./memstick/core/memstick.c:458:			    || !memstick_dev_match(host->card, &card->id)
./memstick/core/memstick.c:459:			    || !(host->card->check(host->card))) {
./memstick/core/memstick.c:460:				device_unregister(&host->card->dev);
./memstick/core/memstick.c:462:			} else if (host->card->start)
./memstick/core/memstick.c:463:				host->card->start(host->card);
./memstick/core/memstick.c:468:			if (device_register(&card->dev)) {
./memstick/core/memstick.c:469:				put_device(&card->dev);
./memstick/core/memstick.c:552:		device_unregister(&host->card->dev);
./memstick/core/ms_block.c:231:	memset(&card->current_mrq, 0, sizeof(card->current_mrq));
./memstick/core/ms_block.c:233:	card->next_request = state_func;
./memstick/core/ms_block.c:234:	memstick_new_req(card->host);
./memstick/core/ms_block.c:235:	wait_for_completion(&card->mrq_complete);
./memstick/core/ms_block.c:248:	msb->card->next_request = h_msb_default_bad;
./memstick/core/ms_block.c:254:	complete(&msb->card->mrq_complete);
./memstick/core/ms_block.c:261:	struct memstick_request *mrq = &msb->card->current_mrq;
./memstick/core/ms_block.c:288:	struct memstick_request *req = &msb->card->current_mrq;
./memstick/core/ms_block.c:309:	struct memstick_request *req = &msb->card->current_mrq;
./memstick/core/ms_block.c:343:	struct memstick_request *mrq = *out_mrq = &card->current_mrq;
./memstick/core/ms_block.c:479:	struct memstick_request *mrq = *out_mrq = &card->current_mrq;
./memstick/core/ms_block.c:591:	struct memstick_request *mrq = *out_mrq = &card->current_mrq;
./memstick/core/ms_block.c:662:	struct memstick_request *mrq = *out_mrq = &card->current_mrq;
./memstick/core/ms_block.c:684:	struct memstick_request *mrq = *out_mrq = &card->current_mrq;
./memstick/core/ms_block.c:685:	struct memstick_host *host = card->host;
./memstick/core/ms_block.c:730:	struct memstick_host *host = card->host;
./memstick/core/ms_block.c:1696:	struct memstick_host *host = card->host;
./memstick/core/ms_block.c:1702:	if (card->id.class >= MEMSTICK_CLASS_ROM &&
./memstick/core/ms_block.c:1703:				card->id.class <= MEMSTICK_CLASS_ROM)
./memstick/core/ms_block.c:2098:	struct memstick_host *host = card->host;
./memstick/core/ms_block.c:2154:	device_add_disk(&card->dev, msb->disk);
./memstick/core/ms_block.c:2185:		card->check = msb_check_card;
./memstick/core/ms_block.c:2186:		card->stop = msb_stop;
./memstick/core/ms_block.c:2187:		card->start = msb_start;
./memstick/core/ms_block.c:2244:	mutex_lock(&card->host->lock);
./memstick/core/ms_block.c:2289:	mutex_unlock(&card->host->lock);
./memstick/core/mspro_block.c:530:	*mrq = &card->current_mrq;
./memstick/core/mspro_block.c:531:	card->next_request = msb->mrq_handler;
./memstick/core/mspro_block.c:566:	dev_dbg(&card->dev, "wait for ced: value %x\n", (*mrq)->data[0]);
./memstick/core/mspro_block.c:606:			card->next_request = h_mspro_block_default;
./memstick/core/mspro_block.c:621:					card->next_request
./memstick/core/mspro_block.c:689:	card->next_request = h_mspro_block_req_init;
./memstick/core/mspro_block.c:691:	memstick_init_req(&card->current_mrq, MS_TPC_WRITE_REG,
./memstick/core/mspro_block.c:728:		memstick_new_req(card->host);
./memstick/core/mspro_block.c:732:	dev_dbg(&card->dev, "blk_fetch\n");
./memstick/core/mspro_block.c:735:		dev_dbg(&card->dev, "issue end\n");
./memstick/core/mspro_block.c:739:	dev_dbg(&card->dev, "trying again\n");
./memstick/core/mspro_block.c:752:	dev_dbg(&card->dev, "complete %d, %d\n", msb->has_request ? 1 : 0,
./memstick/core/mspro_block.c:760:		if (error || (card->current_mrq.tpc == MSPRO_CMD_STOP)) {
./memstick/core/mspro_block.c:775:		dev_dbg(&card->dev, "transferred %x (%d)\n", t_len, error);
./memstick/core/mspro_block.c:794:	card->next_request = h_mspro_block_default_bad;
./memstick/core/mspro_block.c:795:	complete_all(&card->mrq_complete);
./memstick/core/mspro_block.c:818:		wait_for_completion(&card->mrq_complete);
./memstick/core/mspro_block.c:859:	card->next_request = h_mspro_block_req_init;
./memstick/core/mspro_block.c:861:	memstick_init_req(&card->current_mrq, MS_TPC_GET_INT, NULL, 1);
./memstick/core/mspro_block.c:862:	memstick_new_req(card->host);
./memstick/core/mspro_block.c:863:	wait_for_completion(&card->mrq_complete);
./memstick/core/mspro_block.c:864:	return card->current_mrq.error;
./memstick/core/mspro_block.c:870:	struct memstick_host *host = card->host;
./memstick/core/mspro_block.c:879:	card->next_request = h_mspro_block_req_init;
./memstick/core/mspro_block.c:881:	memstick_init_req(&card->current_mrq, MS_TPC_WRITE_REG, &param,
./memstick/core/mspro_block.c:884:	wait_for_completion(&card->mrq_complete);
./memstick/core/mspro_block.c:885:	return card->current_mrq.error;
./memstick/core/mspro_block.c:890:	struct memstick_host *host = card->host;
./memstick/core/mspro_block.c:903:		       dev_name(&card->dev), rc);
./memstick/core/mspro_block.c:910:	       dev_name(&card->dev));
./memstick/core/mspro_block.c:921:			       dev_name(&card->dev));
./memstick/core/mspro_block.c:925:			       dev_name(&card->dev), rc);
./memstick/core/mspro_block.c:928:	card->next_request = h_mspro_block_req_init;
./memstick/core/mspro_block.c:930:	memstick_init_req(&card->current_mrq, MS_TPC_GET_INT, NULL, 1);
./memstick/core/mspro_block.c:931:	memstick_new_req(card->host);
./memstick/core/mspro_block.c:932:	wait_for_completion(&card->mrq_complete);
./memstick/core/mspro_block.c:933:	rc = card->current_mrq.error;
./memstick/core/mspro_block.c:938:		       dev_name(&card->dev));
./memstick/core/mspro_block.c:995:	memstick_new_req(card->host);
./memstick/core/mspro_block.c:996:	wait_for_completion(&card->mrq_complete);
./memstick/core/mspro_block.c:997:	if (card->current_mrq.error) {
./memstick/core/mspro_block.c:998:		rc = card->current_mrq.error;
./memstick/core/mspro_block.c:1004:		       dev_name(&card->dev), be16_to_cpu(attr->signature));
./memstick/core/mspro_block.c:1011:		       dev_name(&card->dev));
./memstick/core/mspro_block.c:1041:		dev_dbg(&card->dev, "adding attribute %d: id %x, address %x, "
./memstick/core/mspro_block.c:1094:		dev_dbg(&card->dev, "reading attribute range %x, %x\n",
./memstick/core/mspro_block.c:1098:		memstick_new_req(card->host);
./memstick/core/mspro_block.c:1099:		wait_for_completion(&card->mrq_complete);
./memstick/core/mspro_block.c:1100:		if (card->current_mrq.error) {
./memstick/core/mspro_block.c:1101:			rc = card->current_mrq.error;
./memstick/core/mspro_block.c:1120:	struct memstick_host *host = card->host;
./memstick/core/mspro_block.c:1126:	card->reg_addr.r_offset = offsetof(struct mspro_register, status);
./memstick/core/mspro_block.c:1127:	card->reg_addr.r_length = sizeof(struct ms_status_register);
./memstick/core/mspro_block.c:1128:	card->reg_addr.w_offset = offsetof(struct mspro_register, param);
./memstick/core/mspro_block.c:1129:	card->reg_addr.w_length = sizeof(struct mspro_param_register);
./memstick/core/mspro_block.c:1145:	dev_dbg(&card->dev, "card activated\n");
./memstick/core/mspro_block.c:1149:	card->next_request = h_mspro_block_req_init;
./memstick/core/mspro_block.c:1151:	memstick_init_req(&card->current_mrq, MS_TPC_READ_REG, NULL,
./memstick/core/mspro_block.c:1153:	memstick_new_req(card->host);
./memstick/core/mspro_block.c:1154:	wait_for_completion(&card->mrq_complete);
./memstick/core/mspro_block.c:1155:	if (card->current_mrq.error)
./memstick/core/mspro_block.c:1156:		return card->current_mrq.error;
./memstick/core/mspro_block.c:1158:	dev_dbg(&card->dev, "card r/w status %d\n", msb->read_only ? 0 : 1);
./memstick/core/mspro_block.c:1165:	dev_dbg(&card->dev, "attributes loaded\n");
./memstick/core/mspro_block.c:1173:	struct memstick_host *host = card->host;
./memstick/core/mspro_block.c:1243:	dev_dbg(&card->dev, "capacity set %ld\n", capacity);
./memstick/core/mspro_block.c:1245:	device_add_disk(&card->dev, msb->disk);
./memstick/core/mspro_block.c:1300:	rc = sysfs_create_group(&card->dev.kobj, &msb->attr_group);
./memstick/core/mspro_block.c:1306:		card->check = mspro_block_check_card;
./memstick/core/mspro_block.c:1307:		card->stop = mspro_block_stop;
./memstick/core/mspro_block.c:1308:		card->start = mspro_block_start;
./memstick/core/mspro_block.c:1312:	sysfs_remove_group(&card->dev.kobj, &msb->attr_group);
./memstick/core/mspro_block.c:1331:	dev_dbg(&card->dev, "mspro block remove\n");
./memstick/core/mspro_block.c:1336:	sysfs_remove_group(&card->dev.kobj, &msb->attr_group);
./memstick/core/mspro_block.c:1370:	struct memstick_host *host = card->host;
./media/pci/ivtv/ivtv-cards.h:286:	/* GPIO card-specific settings */
./media/pci/ivtv/ivtv-routing.c:41:		in = &itv->card->radio_input;
./media/pci/ivtv/ivtv-routing.c:43:		in = &itv->card->audio_inputs[itv->audio_input];
./media/pci/ivtv/ivtv-routing.c:47:	if (itv->card->hw_muxer & IVTV_HW_M52790)
./media/pci/ivtv/ivtv-routing.c:54:	if (itv->card->hw_audio & IVTV_HW_MSP34XX)
./media/pci/ivtv/ivtv-routing.c:56:	ivtv_call_hw(itv, itv->card->hw_audio, audio, s_routing,
./media/pci/ivtv/ivtv-routing.c:69:		itv->card->video_inputs[inp].video_input, 0, 0);
./media/pci/ivtv/ivtv-routing.c:71:	type = itv->card->video_inputs[inp].video_type;
./media/pci/ivtv/ivtv-routing.c:81:	if (itv->card->hw_video & IVTV_HW_GPIO)
./media/pci/ivtv/ivtv-routing.c:85:	if (itv->card->hw_video & IVTV_HW_UPD64031A) {
./media/pci/ivtv/ivtv-routing.c:94:		input |= itv->card->gr_config;
./media/pci/ivtv/ivtv-routing.c:100:	if (itv->card->hw_video & IVTV_HW_UPD6408X) {
./media/pci/ivtv/ivtv-routing.c:108:		else if (itv->card->hw_video & IVTV_HW_UPD64031A) {
./media/pci/ivtv/ivtv-routing.c:112:			    itv->card->type == IVTV_CARD_CX23416GYC) {
./media/pci/ivtv/ivtv-gpio.c:110:	if (itv->card->type != IVTV_CARD_PVR_150)
./media/pci/ivtv/ivtv-gpio.c:138:	curout &= ~(1 << itv->card->xceive_pin);
./media/pci/ivtv/ivtv-gpio.c:142:	curout |= 1 << itv->card->xceive_pin;
./media/pci/ivtv/ivtv-gpio.c:163:	mask = itv->card->gpio_audio_freq.mask;
./media/pci/ivtv/ivtv-gpio.c:166:		data = itv->card->gpio_audio_freq.f32000;
./media/pci/ivtv/ivtv-gpio.c:169:		data = itv->card->gpio_audio_freq.f44100;
./media/pci/ivtv/ivtv-gpio.c:173:		data = itv->card->gpio_audio_freq.f48000;
./media/pci/ivtv/ivtv-gpio.c:186:	mask = itv->card->gpio_audio_detect.mask;
./media/pci/ivtv/ivtv-gpio.c:200:	mask = itv->card->gpio_audio_mode.mask;
./media/pci/ivtv/ivtv-gpio.c:203:		data = itv->card->gpio_audio_mode.lang1;
./media/pci/ivtv/ivtv-gpio.c:206:		data = itv->card->gpio_audio_mode.lang2;
./media/pci/ivtv/ivtv-gpio.c:209:		data = itv->card->gpio_audio_mode.mono;
./media/pci/ivtv/ivtv-gpio.c:214:		data = itv->card->gpio_audio_mode.stereo;
./media/pci/ivtv/ivtv-gpio.c:227:	mask = itv->card->gpio_audio_input.mask;
./media/pci/ivtv/ivtv-gpio.c:228:	data = itv->card->gpio_audio_input.radio;
./media/pci/ivtv/ivtv-gpio.c:242:	mask = itv->card->gpio_audio_input.mask;
./media/pci/ivtv/ivtv-gpio.c:245:		data = itv->card->gpio_audio_input.tuner;
./media/pci/ivtv/ivtv-gpio.c:248:		data = itv->card->gpio_audio_input.linein;
./media/pci/ivtv/ivtv-gpio.c:252:		data = itv->card->gpio_audio_input.radio;
./media/pci/ivtv/ivtv-gpio.c:268:		mask = itv->card->gpio_audio_mute.mask;
./media/pci/ivtv/ivtv-gpio.c:269:		data = ctrl->val ? itv->card->gpio_audio_mute.mute : 0;
./media/pci/ivtv/ivtv-gpio.c:298:	mask = itv->card->gpio_video_input.mask;
./media/pci/ivtv/ivtv-gpio.c:300:		data = itv->card->gpio_video_input.tuner;
./media/pci/ivtv/ivtv-gpio.c:302:		data = itv->card->gpio_video_input.composite;
./media/pci/ivtv/ivtv-gpio.c:304:		data = itv->card->gpio_video_input.svideo;
./media/pci/ivtv/ivtv-gpio.c:344:	if (itv->card->xceive_pin)
./media/pci/ivtv/ivtv-gpio.c:345:		pin = 1 << itv->card->xceive_pin;
./media/pci/ivtv/ivtv-gpio.c:347:	if ((itv->card->gpio_init.direction | pin) == 0)
./media/pci/ivtv/ivtv-gpio.c:354:	write_reg(itv->card->gpio_init.initial_value | pin, IVTV_REG_GPIO_OUT);
./media/pci/ivtv/ivtv-gpio.c:355:	write_reg(itv->card->gpio_init.direction | pin, IVTV_REG_GPIO_DIR);
./media/pci/ivtv/ivtv-cards.c:1307:	const struct ivtv_card_video_input *card_input = itv->card->video_inputs + index;
./media/pci/ivtv/ivtv-cards.c:1332:	const struct ivtv_card_output *card_output = itv->card->video_outputs + index;
./media/pci/ivtv/ivtv-cards.c:1334:	if (index >= itv->card->nof_outputs)
./media/pci/ivtv/ivtv-cards.c:1346:	const struct ivtv_card_audio_input *aud_input = itv->card->audio_inputs + index;
./media/pci/ivtv/ivtv-cards.c:1366:	if (itv->card->video_outputs == NULL || index != 0)
./media/pci/ivtv/ivtv-driver.c:462:	itv->v4l2_cap = itv->card->v4l2_capabilities;
./media/pci/ivtv/ivtv-driver.c:463:	itv->card_name = itv->card->name;
./media/pci/ivtv/ivtv-driver.c:464:	itv->card_i2c = itv->card->i2c;
./media/pci/ivtv/ivtv-driver.c:682:				itv->card->name, chipname);
./media/pci/ivtv/ivtv-driver.c:697:			if (itv->card->pci_list == NULL)
./media/pci/ivtv/ivtv-driver.c:699:			for (j = 0; itv->card->pci_list[j].device; j++) {
./media/pci/ivtv/ivtv-driver.c:701:				    itv->card->pci_list[j].device)
./media/pci/ivtv/ivtv-driver.c:704:				    itv->card->pci_list[j].subsystem_vendor)
./media/pci/ivtv/ivtv-driver.c:707:				    itv->card->pci_list[j].subsystem_device)
./media/pci/ivtv/ivtv-driver.c:710:						itv->card->name, chipname);
./media/pci/ivtv/ivtv-driver.c:724:		IVTV_ERR("Defaulting to %s card\n", itv->card->name);
./media/pci/ivtv/ivtv-driver.c:729:	itv->v4l2_cap = itv->card->v4l2_capabilities;
./media/pci/ivtv/ivtv-driver.c:730:	itv->card_name = itv->card->name;
./media/pci/ivtv/ivtv-driver.c:731:	itv->card_i2c = itv->card->i2c;
./media/pci/ivtv/ivtv-driver.c:809:		if (itv->card->video_inputs[i].video_type == 0)
./media/pci/ivtv/ivtv-driver.c:813:		if (itv->card->audio_inputs[i].audio_type == 0)
./media/pci/ivtv/ivtv-driver.c:817:	if (itv->card->hw_all & IVTV_HW_CX25840) {
./media/pci/ivtv/ivtv-driver.c:825:		if (itv->card->video_inputs[i].video_type ==
./media/pci/ivtv/ivtv-driver.c:832:	itv->audio_input = itv->card->video_inputs[i].audio_index;
./media/pci/ivtv/ivtv-driver.c:909:	u32 hw = itv->card->hw_all;
./media/pci/ivtv/ivtv-driver.c:931:	if (itv->card->hw_all & IVTV_HW_CX25840)
./media/pci/ivtv/ivtv-driver.c:933:	else if (itv->card->hw_all & IVTV_HW_SAA717X)
./media/pci/ivtv/ivtv-driver.c:935:	else if (itv->card->hw_all & IVTV_HW_SAA7114)
./media/pci/ivtv/ivtv-driver.c:939:	itv->sd_audio = ivtv_find_hw(itv, itv->card->hw_audio_ctrl);
./media/pci/ivtv/ivtv-driver.c:940:	itv->sd_muxer = ivtv_find_hw(itv, itv->card->hw_muxer);
./media/pci/ivtv/ivtv-driver.c:944:	if (itv->card->type == IVTV_CARD_CX23416GYC) {
./media/pci/ivtv/ivtv-driver.c:952:	else if (itv->card->type == IVTV_CARD_GV_MVPRX ||
./media/pci/ivtv/ivtv-driver.c:953:		 itv->card->type == IVTV_CARD_GV_MVPRX2E) {
./media/pci/ivtv/ivtv-driver.c:1100:	if (itv->card->hw_all & IVTV_HW_TVEEPROM) {
./media/pci/ivtv/ivtv-driver.c:1105:	if (itv->card->comment)
./media/pci/ivtv/ivtv-driver.c:1106:		IVTV_INFO("%s", itv->card->comment);
./media/pci/ivtv/ivtv-driver.c:1107:	if (itv->card->v4l2_capabilities == 0) {
./media/pci/ivtv/ivtv-driver.c:1121:			if ((itv->std & itv->card->tuners[i].std) == 0)
./media/pci/ivtv/ivtv-driver.c:1123:			itv->options.tuner = itv->card->tuners[i].tuner;
./media/pci/ivtv/ivtv-driver.c:1128:	if (itv->options.tuner == -1 && itv->card->tuners[0].std) {
./media/pci/ivtv/ivtv-driver.c:1129:		itv->std = itv->card->tuners[0].std;
./media/pci/ivtv/ivtv-driver.c:1136:		itv->options.tuner = itv->card->tuners[0].tuner;
./media/pci/ivtv/ivtv-driver.c:1139:		itv->options.radio = (itv->card->radio_input.audio_type != 0);
./media/pci/ivtv/ivtv-driver.c:1141:	/* The card is now fully identified, continue with card-specific
./media/pci/ivtv/ivtv-driver.c:1335:	if (itv->card->hw_all & IVTV_HW_CX25840)
./media/pci/ivtv/ivtv-driver.c:1361:	if (itv->card->v4l2_capabilities & V4L2_CAP_VIDEO_OUTPUT) {
./media/pci/ivtv/ivtv-streams.c:562:		if (itv->card->hw_all & (IVTV_HW_SAA7115 | IVTV_HW_SAA717X))
./media/pci/ivtv/ivtv-streams.c:564:		else if (itv->card->hw_all & IVTV_HW_SAA7114)
./media/pci/ivtv/ivtv-ioctl.c:811:	if (itv->card->video_outputs == NULL || vout->index != 0)
./media/pci/ivtv/ivtv-ioctl.c:1022:	itv->audio_input = itv->card->video_inputs[inp].audio_index;
./media/pci/ivtv/ivtv-ioctl.c:1024:	if (itv->card->video_inputs[inp].video_type == IVTV_CARD_INPUT_VID_TUNER)
./media/pci/ivtv/ivtv-ioctl.c:1057:	if (outp >= itv->card->nof_outputs)
./media/pci/ivtv/ivtv-ioctl.c:1070:			itv->card->video_outputs[outp].video_output, 0);
./media/pci/ivtv/ivtv-firmware.c:288:		    itv->card->video_outputs[itv->active_output].video_output,
./media/pci/ivtv/ivtv-firmware.c:325:		    itv->card->video_outputs[itv->active_output].video_output,
./media/pci/cx25821/cx25821-alsa.c:728:	strcpy(card->driver, "cx25821");
./media/pci/cx25821/cx25821-alsa.c:731:	chip = card->private_data;
./media/pci/cx25821/cx25821-alsa.c:757:	strcpy(card->shortname, "cx25821");
./media/pci/cx25821/cx25821-alsa.c:758:	sprintf(card->longname, "%s at 0x%lx irq %d", chip->dev->name,
./media/pci/cx25821/cx25821-alsa.c:760:	strcpy(card->mixername, "CX25821");
./media/pci/cx25821/cx25821-alsa.c:762:	pr_info("%s/%i: ALSA support for cx25821 boards\n", card->driver,
./media/pci/cx18/cx18-dvb.c:268:	switch (cx->card->type) {
./media/pci/cx18/cx18-dvb.c:470:	switch (cx->card->type) {
./media/pci/cx18/cx18-video.c:26:			cx->card->video_inputs[inp].video_input, 0, 0);
./media/pci/cx18/cx18-i2c.c:55:/* This might well become a card-specific array */
./media/pci/cx18/cx18-streams.c:346:		if (cx->card->hw_all & CX18_HW_DVB) {
./media/pci/cx18/cx18-streams.c:370:	if (cx->card->video_inputs->video_type == CX18_CARD_INPUT_VID_TUNER)
./media/pci/cx18/cx18-audio.c:40:		in = &cx->card->radio_input;
./media/pci/cx18/cx18-audio.c:42:		in = &cx->card->audio_inputs[cx->audio_input];
./media/pci/cx18/cx18-audio.c:48:	err = cx18_call_hw_err(cx, cx->card->hw_audio_ctrl,
./media/pci/cx18/cx18-gpio.c:123:	gpio_update(cx, cx->card->gpio_audio_input.mask,
./media/pci/cx18/cx18-gpio.c:124:			cx->card->gpio_audio_input.radio);
./media/pci/cx18/cx18-gpio.c:133:	switch (cx->card->audio_inputs[cx->audio_input].muxer_input) {
./media/pci/cx18/cx18-gpio.c:135:		data = cx->card->gpio_audio_input.linein;
./media/pci/cx18/cx18-gpio.c:138:		data = cx->card->gpio_audio_input.tuner;
./media/pci/cx18/cx18-gpio.c:146:		data = cx->card->gpio_audio_input.tuner;
./media/pci/cx18/cx18-gpio.c:149:	gpio_update(cx, cx->card->gpio_audio_input.mask, data);
./media/pci/cx18/cx18-gpio.c:161:		data = cx->card->gpio_audio_input.tuner;
./media/pci/cx18/cx18-gpio.c:164:		data = cx->card->gpio_audio_input.linein;
./media/pci/cx18/cx18-gpio.c:167:		data = cx->card->gpio_audio_input.radio;
./media/pci/cx18/cx18-gpio.c:172:	gpio_update(cx, cx->card->gpio_audio_input.mask, data);
./media/pci/cx18/cx18-gpio.c:218:	p = &cx->card->gpio_i2c_slave_reset;
./media/pci/cx18/cx18-gpio.c:243:		if (cx->card->tuners[0].tuner == TUNER_XC2028)
./media/pci/cx18/cx18-gpio.c:244:			gpio_reset_seq(cx, (1 << cx->card->xceive_pin), 0,
./media/pci/cx18/cx18-gpio.c:266:	cx->gpio_dir = cx->card->gpio_init.direction;
./media/pci/cx18/cx18-gpio.c:267:	cx->gpio_val = cx->card->gpio_init.initial_value;
./media/pci/cx18/cx18-gpio.c:269:	if (cx->card->tuners[0].tuner == TUNER_XC2028) {
./media/pci/cx18/cx18-gpio.c:270:		cx->gpio_dir |= 1 << cx->card->xceive_pin;
./media/pci/cx18/cx18-gpio.c:271:		cx->gpio_val |= 1 << cx->card->xceive_pin;
./media/pci/cx18/cx18-gpio.c:321:	if (cx->card->gpio_i2c_slave_reset.ir_reset_mask == 0)
./media/pci/cx18/cx18-gpio.c:340:	    cx->card->tuners[0].tuner != TUNER_XC2028)
./media/pci/cx18/cx18-driver.c:338:	switch (cx->card->type) {
./media/pci/cx18/cx18-driver.c:409:	cx->v4l2_cap = cx->card->v4l2_capabilities;
./media/pci/cx18/cx18-driver.c:410:	cx->card_name = cx->card->name;
./media/pci/cx18/cx18-driver.c:411:	cx->card_i2c = cx->card->i2c;
./media/pci/cx18/cx18-driver.c:649:		CX18_INFO("User specified %s card\n", cx->card->name);
./media/pci/cx18/cx18-driver.c:660:			if (cx->card->pci_list == NULL)
./media/pci/cx18/cx18-driver.c:662:			for (j = 0; cx->card->pci_list[j].device; j++) {
./media/pci/cx18/cx18-driver.c:664:				    cx->card->pci_list[j].device)
./media/pci/cx18/cx18-driver.c:667:				    cx->card->pci_list[j].subsystem_vendor)
./media/pci/cx18/cx18-driver.c:670:				    cx->card->pci_list[j].subsystem_device)
./media/pci/cx18/cx18-driver.c:672:				CX18_INFO("Autodetected %s card\n", cx->card->name);
./media/pci/cx18/cx18-driver.c:686:		CX18_ERR("Defaulting to %s card\n", cx->card->name);
./media/pci/cx18/cx18-driver.c:691:	cx->v4l2_cap = cx->card->v4l2_capabilities;
./media/pci/cx18/cx18-driver.c:692:	cx->card_name = cx->card->name;
./media/pci/cx18/cx18-driver.c:693:	cx->card_i2c = cx->card->i2c;
./media/pci/cx18/cx18-driver.c:785:		if (cx->card->video_inputs[i].video_type == 0)
./media/pci/cx18/cx18-driver.c:789:		if (cx->card->audio_inputs[i].audio_type == 0)
./media/pci/cx18/cx18-driver.c:795:		if (cx->card->video_inputs[i].video_type ==
./media/pci/cx18/cx18-driver.c:802:	cx->audio_input = cx->card->video_inputs[i].audio_index;
./media/pci/cx18/cx18-driver.c:852:	u32 hw = cx->card->hw_all;
./media/pci/cx18/cx18-driver.c:892:	if (cx->card->hw_muxer != 0)
./media/pci/cx18/cx18-driver.c:893:		cx->sd_extmux = cx18_find_hw(cx, cx->card->hw_muxer);
./media/pci/cx18/cx18-driver.c:992:	if (cx->card->hw_all & CX18_HW_GPIO_RESET_CTRL) {
./media/pci/cx18/cx18-driver.c:1007:	if (cx->card->hw_all & CX18_HW_TVEEPROM) {
./media/pci/cx18/cx18-driver.c:1020:	if (cx->card->comment)
./media/pci/cx18/cx18-driver.c:1021:		CX18_INFO("%s", cx->card->comment);
./media/pci/cx18/cx18-driver.c:1022:	if (cx->card->v4l2_capabilities == 0) {
./media/pci/cx18/cx18-driver.c:1042:			if ((cx->std & cx->card->tuners[i].std) == 0)
./media/pci/cx18/cx18-driver.c:1044:			cx->options.tuner = cx->card->tuners[i].tuner;
./media/pci/cx18/cx18-driver.c:1049:	if (cx->options.tuner == -1 && cx->card->tuners[0].std) {
./media/pci/cx18/cx18-driver.c:1050:		cx->std = cx->card->tuners[0].std;
./media/pci/cx18/cx18-driver.c:1057:		cx->options.tuner = cx->card->tuners[0].tuner;
./media/pci/cx18/cx18-driver.c:1060:		cx->options.radio = (cx->card->radio_input.audio_type != 0);
./media/pci/cx18/cx18-driver.c:1062:	/* The card is now fully identified, continue with card-specific
./media/pci/cx18/cx18-cards.c:592:		cx->card->video_inputs + index;
./media/pci/cx18/cx18-cards.c:618:		cx->card->audio_inputs + index;
./media/pci/cx18/cx18-ioctl.c:511:				cx->card->video_inputs + inp;
./media/pci/cx18/cx18-ioctl.c:526:	cx->audio_input = cx->card->video_inputs[inp].audio_index;
./media/pci/cx18/cx18-cards.h:136:	/* GPIO card-specific settings */
./media/pci/cx18/cx18-firmware.c:333:	cx18_write_reg(cx, cx->card->ddr.chip_config, CX18_DDR_CHIP_CONFIG);
./media/pci/cx18/cx18-firmware.c:337:	cx18_write_reg(cx, cx->card->ddr.refresh, CX18_DDR_REFRESH);
./media/pci/cx18/cx18-firmware.c:338:	cx18_write_reg(cx, cx->card->ddr.timing1, CX18_DDR_TIMING1);
./media/pci/cx18/cx18-firmware.c:339:	cx18_write_reg(cx, cx->card->ddr.timing2, CX18_DDR_TIMING2);
./media/pci/cx18/cx18-firmware.c:344:	cx18_write_reg(cx, cx->card->ddr.tune_lane, CX18_DDR_TUNE_LANE);
./media/pci/cx18/cx18-firmware.c:345:	cx18_write_reg(cx, cx->card->ddr.initial_emrs, CX18_DDR_INITIAL_EMRS);
./media/pci/zoran/zoran_device.h:6: * This part handles card-specific data and detection
./media/pci/zoran/zoran_procfs.h:6: * This part handles card-specific data and detection
./media/pci/zoran/zoran_card.h:6: * This part handles card-specific data and detection
./media/pci/zoran/zoran_card.c:6: * This part handles card-specific data and detection
./media/pci/pt3/pt3_dma.c:97:			adap->num_discard--;
./media/pci/saa7134/saa7134-cards.c:4: * card-specific stuff.
./media/pci/saa7134/saa7134-alsa.c:1078:	strcpy(card->mixername, "SAA7134 Mixer");
./media/pci/saa7134/saa7134-alsa.c:1104:	snd_card_saa7134_t *chip = card->private_data;
./media/pci/saa7134/saa7134-alsa.c:1142:	strcpy(card->driver, "SAA7134");
./media/pci/saa7134/saa7134-alsa.c:1146:	card->private_free = snd_saa7134_free;
./media/pci/saa7134/saa7134-alsa.c:1147:	chip = card->private_data;
./media/pci/saa7134/saa7134-alsa.c:1182:	strcpy(card->shortname, "SAA7134");
./media/pci/saa7134/saa7134-alsa.c:1183:	sprintf(card->longname, "%s at 0x%lx irq %d",
./media/pci/saa7134/saa7134-alsa.c:1187:		dev->name, card->longname, index[devnum]);
./media/pci/solo6x10/solo6x10-g723.c:338:	ret = snd_pcm_new(card, card->driver, 0, 0, solo_dev->nr_chans,
./media/pci/solo6x10/solo6x10-g723.c:348:	strcpy(pcm->name, card->shortname);
./media/pci/solo6x10/solo6x10-g723.c:388:	strcpy(card->driver, SOLO6X10_NAME);
./media/pci/solo6x10/solo6x10-g723.c:389:	strcpy(card->shortname, "SOLO-6x10 Audio");
./media/pci/solo6x10/solo6x10-g723.c:390:	sprintf(card->longname, "%s on %s IRQ %d", card->shortname,
./media/pci/solo6x10/solo6x10-g723.c:398:	strcpy(card->mixername, "SOLO-6x10");
./media/pci/ttpci/budget-core.c:97:	switch(budget->card->type) {
./media/pci/ttpci/budget-core.c:434:	switch(budget->card->type) {
./media/pci/ttpci/budget-core.c:483:	ret = dvb_register_adapter(&budget->dvb_adapter, budget->card->name,
./media/pci/ttpci/budget-core.c:507:	strlcpy(budget->i2c_adap.name, budget->card->name, sizeof(budget->i2c_adap.name));
./media/pci/ttpci/budget-core.c:510:	strcpy(budget->i2c_adap.name, budget->card->name);
./media/pci/ttpci/av7110.c:228:	/* card-specific recovery */
./media/pci/tw686x/tw686x-audio.c:291:	err = snd_pcm_new(card, card->driver, 0, 0, max_channels(dev), &pcm);
./media/pci/tw686x/tw686x-audio.c:393:	strlcpy(card->driver, "tw686x", sizeof(card->driver));
./media/pci/tw686x/tw686x-audio.c:394:	strlcpy(card->shortname, "tw686x", sizeof(card->shortname));
./media/pci/tw686x/tw686x-audio.c:395:	strlcpy(card->longname, pci_name(pci_dev), sizeof(card->longname));
./media/pci/bt8xx/bttv-cards.c:5:    this file has configuration informations - card-specific stuff
./media/pci/bt8xx/bttv-driver.c:4193:	/* some card-specific stuff (needs working i2c) */
./media/pci/bt8xx/bttv.h:195:/* more card-specific defines */
./media/pci/bt8xx/bttv.h:292:/* card-specific funtions */
./media/pci/bt8xx/dvb-bt8xx.c:56:	dprintk("%d\n", card->bt->finished_block);
./media/pci/bt8xx/dvb-bt8xx.c:58:	while (card->bt->last_block != card->bt->finished_block) {
./media/pci/bt8xx/dvb-bt8xx.c:59:		(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
./media/pci/bt8xx/dvb-bt8xx.c:60:			(&card->demux,
./media/pci/bt8xx/dvb-bt8xx.c:61:			 &card->bt->buf_cpu[card->bt->last_block *
./media/pci/bt8xx/dvb-bt8xx.c:62:					    card->bt->block_bytes],
./media/pci/bt8xx/dvb-bt8xx.c:63:			 card->bt->block_bytes);
./media/pci/bt8xx/dvb-bt8xx.c:64:		card->bt->last_block = (card->bt->last_block + 1) %
./media/pci/bt8xx/dvb-bt8xx.c:65:					card->bt->block_count;
./media/pci/bt8xx/dvb-bt8xx.c:80:	mutex_lock(&card->lock);
./media/pci/bt8xx/dvb-bt8xx.c:81:	card->nfeeds++;
./media/pci/bt8xx/dvb-bt8xx.c:82:	rc = card->nfeeds;
./media/pci/bt8xx/dvb-bt8xx.c:83:	if (card->nfeeds == 1)
./media/pci/bt8xx/dvb-bt8xx.c:84:		bt878_start(card->bt, card->gpio_mode,
./media/pci/bt8xx/dvb-bt8xx.c:85:			    card->op_sync_orin, card->irq_err_ignore);
./media/pci/bt8xx/dvb-bt8xx.c:86:	mutex_unlock(&card->lock);
./media/pci/bt8xx/dvb-bt8xx.c:100:	mutex_lock(&card->lock);
./media/pci/bt8xx/dvb-bt8xx.c:101:	card->nfeeds--;
./media/pci/bt8xx/dvb-bt8xx.c:102:	if (card->nfeeds == 0)
./media/pci/bt8xx/dvb-bt8xx.c:103:		bt878_stop(card->bt);
./media/pci/bt8xx/dvb-bt8xx.c:104:	mutex_unlock(&card->lock);
./media/pci/bt8xx/dvb-bt8xx.c:252:	bttv_gpio_enable(card->bttv_nr, 1, 1);  /* output */
./media/pci/bt8xx/dvb-bt8xx.c:253:	bttv_write_gpio(card->bttv_nr, 1, 1);   /* relay on */
./media/pci/bt8xx/dvb-bt8xx.c:262:	bttv_write_gpio(card->bttv_nr, 1, 0);   /* relay off */
./media/pci/bt8xx/dvb-bt8xx.c:308:	i2c_transfer(card->i2c_adapter, &msg, 1);
./media/pci/bt8xx/dvb-bt8xx.c:493:	i2c_transfer(card->i2c_adapter, &msg, 1);
./media/pci/bt8xx/dvb-bt8xx.c:602:		card->fe = dvb_attach(mt352_attach, &thomson_dtt7579_config, card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:604:		if (card->fe == NULL)
./media/pci/bt8xx/dvb-bt8xx.c:605:			card->fe = dvb_attach(zl10353_attach, &thomson_dtt7579_zl10353_config,
./media/pci/bt8xx/dvb-bt8xx.c:606:						  card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:608:		if (card->fe != NULL) {
./media/pci/bt8xx/dvb-bt8xx.c:609:			card->fe->ops.tuner_ops.calc_regs = thomson_dtt7579_tuner_calc_regs;
./media/pci/bt8xx/dvb-bt8xx.c:610:			card->fe->ops.info.frequency_min = 174000000;
./media/pci/bt8xx/dvb-bt8xx.c:611:			card->fe->ops.info.frequency_max = 862000000;
./media/pci/bt8xx/dvb-bt8xx.c:617:		card->fe = dvb_attach(lgdt330x_attach, &tdvs_tua6034_config, card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:618:		if (card->fe != NULL) {
./media/pci/bt8xx/dvb-bt8xx.c:619:			dvb_attach(simple_tuner_attach, card->fe,
./media/pci/bt8xx/dvb-bt8xx.c:620:				   card->i2c_adapter, 0x61,
./media/pci/bt8xx/dvb-bt8xx.c:634:		card->fe = dvb_attach(nxt6000_attach, &vp3021_alps_tded4_config, card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:635:		if (card->fe != NULL) {
./media/pci/bt8xx/dvb-bt8xx.c:636:			card->fe->ops.tuner_ops.set_params = vp3021_alps_tded4_tuner_set_params;
./media/pci/bt8xx/dvb-bt8xx.c:643:		card->fe = dvb_attach(mt352_attach, &digitv_alps_tded4_config, card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:645:		if (card->fe != NULL) {
./media/pci/bt8xx/dvb-bt8xx.c:646:			card->fe->ops.tuner_ops.calc_regs = digitv_alps_tded4_tuner_calc_regs;
./media/pci/bt8xx/dvb-bt8xx.c:652:		card->fe = dvb_attach(sp887x_attach, &microtune_mt7202dtf_config, card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:653:		if (card->fe) {
./media/pci/bt8xx/dvb-bt8xx.c:654:			card->fe->ops.tuner_ops.set_params = microtune_mt7202dtf_tuner_set_params;
./media/pci/bt8xx/dvb-bt8xx.c:659:		card->fe = dvb_attach(mt352_attach, &advbt771_samsung_tdtc9251dh0_config, card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:660:		if (card->fe != NULL) {
./media/pci/bt8xx/dvb-bt8xx.c:661:			card->fe->ops.tuner_ops.calc_regs = advbt771_samsung_tdtc9251dh0_tuner_calc_regs;
./media/pci/bt8xx/dvb-bt8xx.c:662:			card->fe->ops.info.frequency_min = 174000000;
./media/pci/bt8xx/dvb-bt8xx.c:663:			card->fe->ops.info.frequency_max = 862000000;
./media/pci/bt8xx/dvb-bt8xx.c:676:		state->i2c = card->i2c_adapter;
./media/pci/bt8xx/dvb-bt8xx.c:677:		state->bt = card->bt;
./media/pci/bt8xx/dvb-bt8xx.c:680:		if (dvb_attach(dst_attach, state, &card->dvb_adapter) == NULL) {
./media/pci/bt8xx/dvb-bt8xx.c:687:		card->fe = &state->frontend;
./media/pci/bt8xx/dvb-bt8xx.c:689:			dvb_attach(dst_ca_attach, state, &card->dvb_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:693:		card->fe = dvb_attach(cx24110_attach, &pctvsat_config, card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:694:		if (card->fe) {
./media/pci/bt8xx/dvb-bt8xx.c:695:			card->fe->ops.tuner_ops.init = pinnsat_tuner_init;
./media/pci/bt8xx/dvb-bt8xx.c:696:			card->fe->ops.tuner_ops.sleep = pinnsat_tuner_sleep;
./media/pci/bt8xx/dvb-bt8xx.c:697:			card->fe->ops.tuner_ops.set_params = cx24108_tuner_set_params;
./media/pci/bt8xx/dvb-bt8xx.c:702:		card->fe = dvb_attach(or51211_attach, &or51211_config, card->i2c_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:703:		if (card->fe != NULL)
./media/pci/bt8xx/dvb-bt8xx.c:704:			dvb_attach(simple_tuner_attach, card->fe,
./media/pci/bt8xx/dvb-bt8xx.c:705:				   card->i2c_adapter, 0x61,
./media/pci/bt8xx/dvb-bt8xx.c:710:	if (card->fe == NULL)
./media/pci/bt8xx/dvb-bt8xx.c:712:		       card->bt->dev->vendor,
./media/pci/bt8xx/dvb-bt8xx.c:713:		       card->bt->dev->device,
./media/pci/bt8xx/dvb-bt8xx.c:714:		       card->bt->dev->subsystem_vendor,
./media/pci/bt8xx/dvb-bt8xx.c:715:		       card->bt->dev->subsystem_device);
./media/pci/bt8xx/dvb-bt8xx.c:717:		if (dvb_register_frontend(&card->dvb_adapter, card->fe)) {
./media/pci/bt8xx/dvb-bt8xx.c:719:			dvb_frontend_detach(card->fe);
./media/pci/bt8xx/dvb-bt8xx.c:720:			card->fe = NULL;
./media/pci/bt8xx/dvb-bt8xx.c:728:	result = dvb_register_adapter(&card->dvb_adapter, card->card_name,
./media/pci/bt8xx/dvb-bt8xx.c:729:				      THIS_MODULE, &card->bt->dev->dev,
./media/pci/bt8xx/dvb-bt8xx.c:735:	card->dvb_adapter.priv = card;
./media/pci/bt8xx/dvb-bt8xx.c:737:	card->bt->adapter = card->i2c_adapter;
./media/pci/bt8xx/dvb-bt8xx.c:739:	memset(&card->demux, 0, sizeof(struct dvb_demux));
./media/pci/bt8xx/dvb-bt8xx.c:741:	card->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING;
./media/pci/bt8xx/dvb-bt8xx.c:743:	card->demux.priv = card;
./media/pci/bt8xx/dvb-bt8xx.c:744:	card->demux.filternum = 256;
./media/pci/bt8xx/dvb-bt8xx.c:745:	card->demux.feednum = 256;
./media/pci/bt8xx/dvb-bt8xx.c:746:	card->demux.start_feed = dvb_bt8xx_start_feed;
./media/pci/bt8xx/dvb-bt8xx.c:747:	card->demux.stop_feed = dvb_bt8xx_stop_feed;
./media/pci/bt8xx/dvb-bt8xx.c:748:	card->demux.write_to_decoder = NULL;
./media/pci/bt8xx/dvb-bt8xx.c:750:	result = dvb_dmx_init(&card->demux);
./media/pci/bt8xx/dvb-bt8xx.c:756:	card->dmxdev.filternum = 256;
./media/pci/bt8xx/dvb-bt8xx.c:757:	card->dmxdev.demux = &card->demux.dmx;
./media/pci/bt8xx/dvb-bt8xx.c:758:	card->dmxdev.capabilities = 0;
./media/pci/bt8xx/dvb-bt8xx.c:760:	result = dvb_dmxdev_init(&card->dmxdev, &card->dvb_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:766:	card->fe_hw.source = DMX_FRONTEND_0;
./media/pci/bt8xx/dvb-bt8xx.c:768:	result = card->demux.dmx.add_frontend(&card->demux.dmx, &card->fe_hw);
./media/pci/bt8xx/dvb-bt8xx.c:774:	card->fe_mem.source = DMX_MEMORY_FE;
./media/pci/bt8xx/dvb-bt8xx.c:776:	result = card->demux.dmx.add_frontend(&card->demux.dmx, &card->fe_mem);
./media/pci/bt8xx/dvb-bt8xx.c:782:	result = card->demux.dmx.connect_frontend(&card->demux.dmx, &card->fe_hw);
./media/pci/bt8xx/dvb-bt8xx.c:788:	result = dvb_net_init(&card->dvb_adapter, &card->dvbnet, &card->demux.dmx);
./media/pci/bt8xx/dvb-bt8xx.c:794:	tasklet_init(&card->bt->tasklet, dvb_bt8xx_task, (unsigned long) card);
./media/pci/bt8xx/dvb-bt8xx.c:801:	card->demux.dmx.disconnect_frontend(&card->demux.dmx);
./media/pci/bt8xx/dvb-bt8xx.c:803:	card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);
./media/pci/bt8xx/dvb-bt8xx.c:805:	card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
./media/pci/bt8xx/dvb-bt8xx.c:807:	dvb_dmxdev_release(&card->dmxdev);
./media/pci/bt8xx/dvb-bt8xx.c:809:	dvb_dmx_release(&card->demux);
./media/pci/bt8xx/dvb-bt8xx.c:811:	dvb_unregister_adapter(&card->dvb_adapter);
./media/pci/bt8xx/dvb-bt8xx.c:824:	mutex_init(&card->lock);
./media/pci/bt8xx/dvb-bt8xx.c:825:	card->bttv_nr = sub->core->nr;
./media/pci/bt8xx/dvb-bt8xx.c:826:	strlcpy(card->card_name, sub->core->v4l2_dev.name, sizeof(card->card_name));
./media/pci/bt8xx/dvb-bt8xx.c:827:	card->i2c_adapter = &sub->core->i2c_adap;
./media/pci/bt8xx/dvb-bt8xx.c:831:		card->gpio_mode = 0x0400c060;
./media/pci/bt8xx/dvb-bt8xx.c:834:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./media/pci/bt8xx/dvb-bt8xx.c:835:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./media/pci/bt8xx/dvb-bt8xx.c:839:		card->gpio_mode = 0x0400C060;
./media/pci/bt8xx/dvb-bt8xx.c:840:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./media/pci/bt8xx/dvb-bt8xx.c:841:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./media/pci/bt8xx/dvb-bt8xx.c:848:		card->gpio_mode = 0x0400c060;
./media/pci/bt8xx/dvb-bt8xx.c:849:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./media/pci/bt8xx/dvb-bt8xx.c:850:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./media/pci/bt8xx/dvb-bt8xx.c:855:		card->gpio_mode = (1 << 26) | (1 << 14) | (1 << 5);
./media/pci/bt8xx/dvb-bt8xx.c:856:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./media/pci/bt8xx/dvb-bt8xx.c:857:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./media/pci/bt8xx/dvb-bt8xx.c:862:		card->gpio_mode = 0x0400402B;
./media/pci/bt8xx/dvb-bt8xx.c:863:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./media/pci/bt8xx/dvb-bt8xx.c:864:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./media/pci/bt8xx/dvb-bt8xx.c:869:		card->gpio_mode = 0x2204f2c;
./media/pci/bt8xx/dvb-bt8xx.c:870:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./media/pci/bt8xx/dvb-bt8xx.c:871:		card->irq_err_ignore = BT878_APABORT | BT878_ARIPERR |
./media/pci/bt8xx/dvb-bt8xx.c:887:		card->gpio_mode = 0x0100EC7B;
./media/pci/bt8xx/dvb-bt8xx.c:888:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./media/pci/bt8xx/dvb-bt8xx.c:889:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./media/pci/bt8xx/dvb-bt8xx.c:898:	dprintk("dvb_bt8xx: identified card%d as %s\n", card->bttv_nr, card->card_name);
./media/pci/bt8xx/dvb-bt8xx.c:900:	if (!(bttv_pci_dev = bttv_get_pcidev(card->bttv_nr))) {
./media/pci/bt8xx/dvb-bt8xx.c:901:		pr_err("no pci device for card %d\n", card->bttv_nr);
./media/pci/bt8xx/dvb-bt8xx.c:906:	if (!(card->bt = dvb_bt8xx_878_match(card->bttv_nr, bttv_pci_dev))) {
./media/pci/bt8xx/dvb-bt8xx.c:907:		pr_err("unable to determine DMA core of card %d,\n", card->bttv_nr);
./media/pci/bt8xx/dvb-bt8xx.c:914:	mutex_init(&card->bt->gpio_lock);
./media/pci/bt8xx/dvb-bt8xx.c:915:	card->bt->bttv_nr = sub->core->nr;
./media/pci/bt8xx/dvb-bt8xx.c:930:	dprintk("dvb_bt8xx: unloading card%d\n", card->bttv_nr);
./media/pci/bt8xx/dvb-bt8xx.c:932:	bt878_stop(card->bt);
./media/pci/bt8xx/dvb-bt8xx.c:933:	tasklet_kill(&card->bt->tasklet);
./media/pci/bt8xx/dvb-bt8xx.c:934:	dvb_net_release(&card->dvbnet);
./media/pci/bt8xx/dvb-bt8xx.c:935:	card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);
./media/pci/bt8xx/dvb-bt8xx.c:936:	card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
./media/pci/bt8xx/dvb-bt8xx.c:937:	dvb_dmxdev_release(&card->dmxdev);
./media/pci/bt8xx/dvb-bt8xx.c:938:	dvb_dmx_release(&card->demux);
./media/pci/bt8xx/dvb-bt8xx.c:939:	if (card->fe) {
./media/pci/bt8xx/dvb-bt8xx.c:940:		dvb_unregister_frontend(card->fe);
./media/pci/bt8xx/dvb-bt8xx.c:941:		dvb_frontend_detach(card->fe);
./media/pci/bt8xx/dvb-bt8xx.c:943:	dvb_unregister_adapter(&card->dvb_adapter);
./media/pci/cx23885/cx23885-alsa.c:565:	chip = (struct cx23885_audio_dev *) card->private_data;
./media/pci/cx23885/cx23885-alsa.c:575:	strcpy(card->driver, "CX23885");
./media/pci/cx23885/cx23885-alsa.c:576:	sprintf(card->shortname, "Conexant CX23885");
./media/pci/cx23885/cx23885-alsa.c:577:	sprintf(card->longname, "%s at %s", card->shortname, dev->name);
./media/pci/cx88/cx88-alsa.c:846:	struct cx88_audio_dev *chip = card->private_data;
./media/pci/cx88/cx88-alsa.c:873:	chip = card->private_data;
./media/pci/cx88/cx88-alsa.c:944:	card->private_free = snd_cx88_dev_free;
./media/pci/cx88/cx88-alsa.c:968:	strcpy(card->driver, "CX88x");
./media/pci/cx88/cx88-alsa.c:969:	sprintf(card->shortname, "Conexant CX%x", pci->device);
./media/pci/cx88/cx88-alsa.c:970:	sprintf(card->longname, "%s at %#llx",
./media/pci/cx88/cx88-alsa.c:971:		card->shortname,
./media/pci/cx88/cx88-alsa.c:973:	strcpy(card->mixername, "CX88");
./media/pci/cx88/cx88-alsa.c:976:		card->driver, devno);
./media/pci/cx88/cx88-cards.c:3: * card-specific stuff.
./media/usb/em28xx/em28xx-audio.c:935:	strcpy(card->driver, "Em28xx-Audio");
./media/usb/em28xx/em28xx-audio.c:936:	strcpy(card->shortname, "Em28xx Audio");
./media/usb/em28xx/em28xx-audio.c:937:	strcpy(card->longname, "Empia Em28xx Audio");
./media/usb/usbtv/usbtv-audio.c:360:	strlcpy(card->driver, usbtv->dev->driver->name, sizeof(card->driver));
./media/usb/usbtv/usbtv-audio.c:361:	strlcpy(card->shortname, "usbtv", sizeof(card->shortname));
./media/usb/usbtv/usbtv-audio.c:362:	snprintf(card->longname, sizeof(card->longname),
./media/usb/go7007/snd-go7007.c:262:	strlcpy(gosnd->card->driver, "go7007", sizeof(gosnd->card->driver));
./media/usb/go7007/snd-go7007.c:263:	strlcpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->driver));
./media/usb/go7007/snd-go7007.c:264:	strlcpy(gosnd->card->longname, gosnd->card->shortname,
./media/usb/go7007/snd-go7007.c:265:			sizeof(gosnd->card->longname));
./media/usb/tm6000/tm6000-alsa.c:438:	strcpy(card->driver, "tm6000-alsa");
./media/usb/tm6000/tm6000-alsa.c:439:	strcpy(card->shortname, "TM5600/60x0");
./media/usb/tm6000/tm6000-alsa.c:440:	sprintf(card->longname, "TM5600/60x0 Audio at bus %d device %d",
./media/usb/tm6000/tm6000-alsa.c:474:	dprintk(1, "Registered audio driver for %s\n", card->longname);
./media/usb/cx231xx/cx231xx-audio.c:681:	strcpy(card->driver, "Cx231xx-Audio");
./media/usb/cx231xx/cx231xx-audio.c:682:	strcpy(card->shortname, "Cx231xx Audio");
./media/usb/cx231xx/cx231xx-audio.c:683:	strcpy(card->longname, "Conexant cx231xx Audio");
./media/avb/avb_alsa.c:507:	avb_chip = card->private_data;
./media/avb/avb_alsa.c:520:	strcpy(card->driver, "Avb");
./media/avb/avb_alsa.c:521:	strcpy(card->shortname, "Avb");
./media/avb/avb_alsa.c:522:	sprintf(card->longname, "Avb %i", devptr->id + 1);
./media/avb/avb_alsa.c:539:			__func__, card->shortname);
./media/avb/avb_alsa.c:553:	struct avb_chip *avb_chip = card->private_data;
./media/avb/avb_alsa.c:640:	avb_chip = card->private_data;
./isdn/isdnloop/isdnloop.c:39:	struct sk_buff_head *queue = &card->bqueue[channel];
./isdn/isdnloop/isdnloop.c:42:	card->sndcount[channel] = 0;
./isdn/isdnloop/isdnloop.c:56:	isdnloop_card *rcard = card->rcard[ch];
./isdn/isdnloop/isdnloop.c:57:	int rch = card->rch[ch], len, ack;
./isdn/isdnloop/isdnloop.c:61:	while (card->sndcount[ch]) {
./isdn/isdnloop/isdnloop.c:62:		skb = skb_dequeue(&card->bqueue[ch]);
./isdn/isdnloop/isdnloop.c:65:			card->sndcount[ch] -= len;
./isdn/isdnloop/isdnloop.c:67:			cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:70:				rcard->interface.rcvcallb_skb(rcard->myid, rch, skb);
./isdn/isdnloop/isdnloop.c:78:			card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:80:			card->sndcount[ch] = 0;
./isdn/isdnloop/isdnloop.c:98:	if (card->flags & ISDNLOOP_FLAGS_B1ACTIVE)
./isdn/isdnloop/isdnloop.c:100:	if (card->flags & ISDNLOOP_FLAGS_B2ACTIVE)
./isdn/isdnloop/isdnloop.c:102:	if (card->flags & (ISDNLOOP_FLAGS_B1ACTIVE | ISDNLOOP_FLAGS_B2ACTIVE)) {
./isdn/isdnloop/isdnloop.c:104:		spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:105:		card->rb_timer.expires = jiffies + ISDNLOOP_TIMER_BCREAD;
./isdn/isdnloop/isdnloop.c:106:		add_timer(&card->rb_timer);
./isdn/isdnloop/isdnloop.c:107:		card->flags |= ISDNLOOP_FLAGS_RBTIMER;
./isdn/isdnloop/isdnloop.c:108:		spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:110:		card->flags &= ~ISDNLOOP_FLAGS_RBTIMER;
./isdn/isdnloop/isdnloop.c:201:	cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:206:		card->flags |= (channel) ?
./isdn/isdnloop/isdnloop.c:211:		card->flags &= ~((channel) ?
./isdn/isdnloop/isdnloop.c:221:		sprintf(cmd.parm.setup.phone, "LEASED%d", card->myid);
./isdn/isdnloop/isdnloop.c:248:		card->flags &= ~ISDNLOOP_FLAGS_B1ACTIVE;
./isdn/isdnloop/isdnloop.c:251:		cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:252:		card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:255:		cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:256:		card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:258:		card->flags &= ~ISDNLOOP_FLAGS_B2ACTIVE;
./isdn/isdnloop/isdnloop.c:261:		cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:262:		card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:265:		cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:268:	card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:283:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:284:	*card->msg_buf_write++ = (c == 0xff) ? '\n' : c;
./isdn/isdnloop/isdnloop.c:285:	if (card->msg_buf_write == card->msg_buf_read) {
./isdn/isdnloop/isdnloop.c:286:		if (++card->msg_buf_read > card->msg_buf_end)
./isdn/isdnloop/isdnloop.c:287:			card->msg_buf_read = card->msg_buf;
./isdn/isdnloop/isdnloop.c:289:	if (card->msg_buf_write > card->msg_buf_end)
./isdn/isdnloop/isdnloop.c:290:		card->msg_buf_write = card->msg_buf;
./isdn/isdnloop/isdnloop.c:291:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:320:	skb = skb_dequeue(&card->dqueue);
./isdn/isdnloop/isdnloop.c:329:		card->imsg[card->iptr] = c;
./isdn/isdnloop/isdnloop.c:330:		if (card->iptr < 59)
./isdn/isdnloop/isdnloop.c:331:			card->iptr++;
./isdn/isdnloop/isdnloop.c:335:			card->imsg[card->iptr] = 0;
./isdn/isdnloop/isdnloop.c:336:			card->iptr = 0;
./isdn/isdnloop/isdnloop.c:337:			if (card->imsg[0] == '0' && card->imsg[1] >= '0' &&
./isdn/isdnloop/isdnloop.c:338:			    card->imsg[1] <= '2' && card->imsg[2] == ';') {
./isdn/isdnloop/isdnloop.c:339:				ch = (card->imsg[1] - '0') - 1;
./isdn/isdnloop/isdnloop.c:340:				p = &card->imsg[3];
./isdn/isdnloop/isdnloop.c:343:				p = card->imsg;
./isdn/isdnloop/isdnloop.c:347:						card->ptype = ISDN_PTYPE_1TR6;
./isdn/isdnloop/isdnloop.c:348:						card->interface.features |= ISDN_FEATURE_P_1TR6;
./isdn/isdnloop/isdnloop.c:353:						card->ptype = ISDN_PTYPE_EURO;
./isdn/isdnloop/isdnloop.c:354:						card->interface.features |= ISDN_FEATURE_P_EURO;
./isdn/isdnloop/isdnloop.c:366:		cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:368:		card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:370:	if (card->flags & (ISDNLOOP_FLAGS_B1ACTIVE | ISDNLOOP_FLAGS_B2ACTIVE))
./isdn/isdnloop/isdnloop.c:371:		if (!(card->flags & ISDNLOOP_FLAGS_RBTIMER)) {
./isdn/isdnloop/isdnloop.c:373:			card->flags |= ISDNLOOP_FLAGS_RBTIMER;
./isdn/isdnloop/isdnloop.c:374:			spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:375:			del_timer(&card->rb_timer);
./isdn/isdnloop/isdnloop.c:376:			card->rb_timer.function = isdnloop_pollbchan;
./isdn/isdnloop/isdnloop.c:377:			card->rb_timer.data = (unsigned long) card;
./isdn/isdnloop/isdnloop.c:378:			card->rb_timer.expires = jiffies + ISDNLOOP_TIMER_BCREAD;
./isdn/isdnloop/isdnloop.c:379:			add_timer(&card->rb_timer);
./isdn/isdnloop/isdnloop.c:380:			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:383:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:384:	card->st_timer.expires = jiffies + ISDNLOOP_TIMER_DCREAD;
./isdn/isdnloop/isdnloop.c:385:	add_timer(&card->st_timer);
./isdn/isdnloop/isdnloop.c:386:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:395: *   card    = pointer to card-struct
./isdn/isdnloop/isdnloop.c:412:		if (!(card->flags & (channel ? ISDNLOOP_FLAGS_B2ACTIVE : ISDNLOOP_FLAGS_B1ACTIVE)))
./isdn/isdnloop/isdnloop.c:414:		if (card->sndcount[channel] > ISDNLOOP_MAX_SQUEUE)
./isdn/isdnloop/isdnloop.c:416:		spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:421:			skb_queue_tail(&card->bqueue[channel], nskb);
./isdn/isdnloop/isdnloop.c:425:		card->sndcount[channel] += len;
./isdn/isdnloop/isdnloop.c:426:		spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:449:		if (card->msg_buf_read == card->msg_buf_write)
./isdn/isdnloop/isdnloop.c:451:		if (put_user(*card->msg_buf_read++, p))
./isdn/isdnloop/isdnloop.c:453:		if (card->msg_buf_read > card->msg_buf_end)
./isdn/isdnloop/isdnloop.c:454:			card->msg_buf_read = card->msg_buf;
./isdn/isdnloop/isdnloop.c:483:	skb_queue_tail(&card->dqueue, skb);
./isdn/isdnloop/isdnloop.c:523:	snprintf(buf, sizeof(buf), "E%s", card->omsg);
./isdn/isdnloop/isdnloop.c:547:	switch (card->ptype) {
./isdn/isdnloop/isdnloop.c:574:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:575:	if (card->rcard) {
./isdn/isdnloop/isdnloop.c:576:		isdnloop_fake(card->rcard[ch], "DDIS_I", card->rch[ch] + 1);
./isdn/isdnloop/isdnloop.c:577:		card->rcard[ch]->rcard[card->rch[ch]] = NULL;
./isdn/isdnloop/isdnloop.c:578:		card->rcard[ch] = NULL;
./isdn/isdnloop/isdnloop.c:584:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:619:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:620:	init_timer(&card->c_timer[ch]);
./isdn/isdnloop/isdnloop.c:621:	card->c_timer[ch].expires = jiffies + ISDNLOOP_TIMER_ALERTWAIT;
./isdn/isdnloop/isdnloop.c:623:		card->c_timer[ch].function = isdnloop_atimeout1;
./isdn/isdnloop/isdnloop.c:625:		card->c_timer[ch].function = isdnloop_atimeout0;
./isdn/isdnloop/isdnloop.c:626:	card->c_timer[ch].data = (unsigned long) card;
./isdn/isdnloop/isdnloop.c:627:	add_timer(&card->c_timer[ch]);
./isdn/isdnloop/isdnloop.c:628:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:643:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:644:	del_timer(&card->c_timer[ch]);
./isdn/isdnloop/isdnloop.c:645:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:699:				spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:704:						spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:710:					card->rcard[lch] = cc;
./isdn/isdnloop/isdnloop.c:711:					card->rch[lch] = ch;
./isdn/isdnloop/isdnloop.c:712:					spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:715:					spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:748:	switch (card->ptype) {
./isdn/isdnloop/isdnloop.c:752:				if (!(strcmp(card->s0num[i], phone)))
./isdn/isdnloop/isdnloop.c:754:			return card->s0num[0];
./isdn/isdnloop/isdnloop.c:760:			sprintf(nphone, "%s%c", card->s0num[0], phone[0]);
./isdn/isdnloop/isdnloop.c:779:	char *p = card->omsg;
./isdn/isdnloop/isdnloop.c:787:	if ((card->omsg[0] != '0') && (card->omsg[2] != ';')) {
./isdn/isdnloop/isdnloop.c:791:	ch = card->omsg[1] - '0';
./isdn/isdnloop/isdnloop.c:813:		if (card->rcard[ch - 1]) {
./isdn/isdnloop/isdnloop.c:814:			isdnloop_fake(card->rcard[ch - 1], "BCON_I",
./isdn/isdnloop/isdnloop.c:815:				      card->rch[ch - 1] + 1);
./isdn/isdnloop/isdnloop.c:821:		if (card->rcard[ch - 1]) {
./isdn/isdnloop/isdnloop.c:822:			isdnloop_fake(card->rcard[ch - 1], "BCON_C",
./isdn/isdnloop/isdnloop.c:823:				      card->rch[ch - 1] + 1);
./isdn/isdnloop/isdnloop.c:829:		if (card->rcard[ch - 1]) {
./isdn/isdnloop/isdnloop.c:830:			isdnloop_fake(card->rcard[ch - 1], "BDIS_I",
./isdn/isdnloop/isdnloop.c:831:				      card->rch[ch - 1] + 1);
./isdn/isdnloop/isdnloop.c:837:		if (card->rcard[ch - 1]) {
./isdn/isdnloop/isdnloop.c:838:			isdnloop_kill_ctimer(card->rcard[ch - 1], card->rch[ch - 1]);
./isdn/isdnloop/isdnloop.c:839:			isdnloop_fake(card->rcard[ch - 1], "DCON_C",
./isdn/isdnloop/isdnloop.c:840:				      card->rch[ch - 1] + 1);
./isdn/isdnloop/isdnloop.c:847:		if (card->rcard[ch - 1]) {
./isdn/isdnloop/isdnloop.c:848:			isdnloop_kill_ctimer(card->rcard[ch - 1], card->rch[ch - 1]);
./isdn/isdnloop/isdnloop.c:849:			isdnloop_fake(card->rcard[ch - 1], "DDIS_I",
./isdn/isdnloop/isdnloop.c:850:				      card->rch[ch - 1] + 1);
./isdn/isdnloop/isdnloop.c:851:			card->rcard[ch - 1] = NULL;
./isdn/isdnloop/isdnloop.c:857:		if (card->ptype != ISDN_PTYPE_1TR6) {
./isdn/isdnloop/isdnloop.c:873:				isdnloop_vstphone(card->rcard[ch - 1],
./isdn/isdnloop/isdnloop.c:875:			isdnloop_fake(card->rcard[ch - 1], buf, card->rch[ch - 1] + 1);
./isdn/isdnloop/isdnloop.c:897:		card->eazlist[ch - 1][0] = '\0';
./isdn/isdnloop/isdnloop.c:902:		if (strlen(p) >= sizeof(card->eazlist[0]))
./isdn/isdnloop/isdnloop.c:904:		strcpy(card->eazlist[ch - 1], p);
./isdn/isdnloop/isdnloop.c:908:		sprintf(buf, "EAZ-LIST: %s", card->eazlist[ch - 1]);
./isdn/isdnloop/isdnloop.c:923:				card->sil[ch - 1] |= si2bit[*p - '0'];
./isdn/isdnloop/isdnloop.c:934:			if (card->sil[ch - 1] & (1 << i))
./isdn/isdnloop/isdnloop.c:940:		card->sil[ch - 1] = 0;
./isdn/isdnloop/isdnloop.c:989:			card->omsg[card->optr] = *p;
./isdn/isdnloop/isdnloop.c:991:				card->omsg[card->optr] = '\0';
./isdn/isdnloop/isdnloop.c:992:				card->optr = 0;
./isdn/isdnloop/isdnloop.c:999:				if (card->optr < 59)
./isdn/isdnloop/isdnloop.c:1000:					card->optr++;
./isdn/isdnloop/isdnloop.c:1006:	cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:1008:	card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:1021:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1022:	if (card->flags & ISDNLOOP_FLAGS_RUNNING) {
./isdn/isdnloop/isdnloop.c:1023:		card->flags &= ~ISDNLOOP_FLAGS_RUNNING;
./isdn/isdnloop/isdnloop.c:1024:		del_timer(&card->st_timer);
./isdn/isdnloop/isdnloop.c:1025:		del_timer(&card->rb_timer);
./isdn/isdnloop/isdnloop.c:1026:		del_timer(&card->c_timer[0]);
./isdn/isdnloop/isdnloop.c:1027:		del_timer(&card->c_timer[1]);
./isdn/isdnloop/isdnloop.c:1029:		cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:1030:		card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:1032:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1067:	if (card->flags & ISDNLOOP_FLAGS_RUNNING)
./isdn/isdnloop/isdnloop.c:1077:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1082:			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1085:		card->sil[0] = card->sil[1] = 4;
./isdn/isdnloop/isdnloop.c:1087:			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1091:			strlcpy(card->s0num[i], sdef.num[i],
./isdn/isdnloop/isdnloop.c:1092:				sizeof(card->s0num[0]));
./isdn/isdnloop/isdnloop.c:1098:			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1101:		card->sil[0] = card->sil[1] = 4;
./isdn/isdnloop/isdnloop.c:1103:			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1106:		strlcpy(card->s0num[0], sdef.num[0], sizeof(card->s0num[0]));
./isdn/isdnloop/isdnloop.c:1107:		card->s0num[1][0] = '\0';
./isdn/isdnloop/isdnloop.c:1108:		card->s0num[2][0] = '\0';
./isdn/isdnloop/isdnloop.c:1111:		spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1116:	init_timer(&card->st_timer);
./isdn/isdnloop/isdnloop.c:1117:	card->st_timer.expires = jiffies + ISDNLOOP_TIMER_DCREAD;
./isdn/isdnloop/isdnloop.c:1118:	card->st_timer.function = isdnloop_polldchan;
./isdn/isdnloop/isdnloop.c:1119:	card->st_timer.data = (unsigned long) card;
./isdn/isdnloop/isdnloop.c:1120:	add_timer(&card->st_timer);
./isdn/isdnloop/isdnloop.c:1121:	card->flags |= ISDNLOOP_FLAGS_RUNNING;
./isdn/isdnloop/isdnloop.c:1122:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./isdn/isdnloop/isdnloop.c:1156:				if (!card->leased) {
./isdn/isdnloop/isdnloop.c:1157:					card->leased = 1;
./isdn/isdnloop/isdnloop.c:1158:					while (card->ptype == ISDN_PTYPE_UNKNOWN)
./isdn/isdnloop/isdnloop.c:1167:					cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:1169:					card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:1172:				if (card->leased) {
./isdn/isdnloop/isdnloop.c:1173:					card->leased = 0;
./isdn/isdnloop/isdnloop.c:1180:					cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:1182:					card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:1191:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1193:		if (card->leased)
./isdn/isdnloop/isdnloop.c:1216:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1221:			switch (card->l2_proto[a - 1]) {
./isdn/isdnloop/isdnloop.c:1244:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1248:			switch (card->l2_proto[a - 1]) {
./isdn/isdnloop/isdnloop.c:1270:			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1279:			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1281:			if (card->leased)
./isdn/isdnloop/isdnloop.c:1285:				if (card->ptype == ISDN_PTYPE_EURO) {
./isdn/isdnloop/isdnloop.c:1295:			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1297:			if (card->leased)
./isdn/isdnloop/isdnloop.c:1301:				if (card->ptype == ISDN_PTYPE_EURO)
./isdn/isdnloop/isdnloop.c:1309:			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1335:				card->l2_proto[a & 255] = (a >> 8);
./isdn/isdnloop/isdnloop.c:1339:			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1386:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1401:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1416:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./isdn/isdnloop/isdnloop.c:1428: * Allocate a new card-struct, initialize it
./isdn/isdnloop/isdnloop.c:1439:		       "isdnloop: (%s) Could not allocate card-struct.\n", id);
./isdn/isdnloop/isdnloop.c:1442:	card->interface.owner = THIS_MODULE;
./isdn/isdnloop/isdnloop.c:1443:	card->interface.channels = ISDNLOOP_BCH;
./isdn/isdnloop/isdnloop.c:1444:	card->interface.hl_hdrlen  = 1; /* scratch area for storing ack flag*/
./isdn/isdnloop/isdnloop.c:1445:	card->interface.maxbufsize = 4000;
./isdn/isdnloop/isdnloop.c:1446:	card->interface.command = if_command;
./isdn/isdnloop/isdnloop.c:1447:	card->interface.writebuf_skb = if_sendbuf;
./isdn/isdnloop/isdnloop.c:1448:	card->interface.writecmd = if_writecmd;
./isdn/isdnloop/isdnloop.c:1449:	card->interface.readstat = if_readstatus;
./isdn/isdnloop/isdnloop.c:1450:	card->interface.features = ISDN_FEATURE_L2_X75I |
./isdn/isdnloop/isdnloop.c:1458:	card->ptype = ISDN_PTYPE_UNKNOWN;
./isdn/isdnloop/isdnloop.c:1459:	strlcpy(card->interface.id, id, sizeof(card->interface.id));
./isdn/isdnloop/isdnloop.c:1460:	card->msg_buf_write = card->msg_buf;
./isdn/isdnloop/isdnloop.c:1461:	card->msg_buf_read = card->msg_buf;
./isdn/isdnloop/isdnloop.c:1462:	card->msg_buf_end = &card->msg_buf[sizeof(card->msg_buf) - 1];
./isdn/isdnloop/isdnloop.c:1464:		card->l2_proto[i] = ISDN_PROTO_L2_X75I;
./isdn/isdnloop/isdnloop.c:1465:		skb_queue_head_init(&card->bqueue[i]);
./isdn/isdnloop/isdnloop.c:1467:	skb_queue_head_init(&card->dqueue);
./isdn/isdnloop/isdnloop.c:1468:	spin_lock_init(&card->isdnloop_lock);
./isdn/isdnloop/isdnloop.c:1469:	card->next = cards;
./isdn/isdnloop/isdnloop.c:1471:	if (!register_isdn(&card->interface)) {
./isdn/isdnloop/isdnloop.c:1478:	card->myid = card->interface.channels;
./isdn/isdnloop/isdnloop.c:1492:	       card->interface.id);
./isdn/isdnloop/isdnloop.c:1516:		cmd.driver = card->myid;
./isdn/isdnloop/isdnloop.c:1517:		card->interface.statcallb(&cmd);
./isdn/isdnloop/isdnloop.c:1520:		card = card->next;
./isdn/isdnloop/isdnloop.c:1525:		skb_queue_purge(&card->dqueue);
./isdn/isdnloop/isdnloop.c:1526:		card = card->next;
./isdn/isdnloop/isdnloop.h:109:#define CID (card->interface.id)
./isdn/hisax/nj_u.c:224:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/nj_s.c:261:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/sedlbauer.c:535:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/sedlbauer.c:558:				card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/sedlbauer.c:559:				card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/sedlbauer.c:561:				if (!card->para[0] || !card->para[1]) {
./isdn/hisax/sedlbauer.c:563:					       card->para[0], card->para[1]);
./isdn/hisax/sedlbauer.c:567:				cs->hw.sedl.cfg_reg = card->para[1];
./isdn/hisax/sedlbauer.c:568:				cs->irq = card->para[0];
./isdn/hisax/sedlbauer.c:604:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/sedlbauer.c:677:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/sedlbauer.c:699:	if (card->para[1]) {
./isdn/hisax/sedlbauer.c:700:		cs->hw.sedl.cfg_reg = card->para[1];
./isdn/hisax/sedlbauer.c:701:		cs->irq = card->para[0];
./isdn/hisax/sedlbauer.c:730:		       CardType[card->typ],
./isdn/hisax/w6692.c:1000:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/ix1_micro.c:229:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/ix1_micro.c:238:	if (!card->para[1] && isapnp_present()) {
./isdn/hisax/ix1_micro.c:257:					card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/ix1_micro.c:258:					card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/ix1_micro.c:259:					if (!card->para[0] || !card->para[1]) {
./isdn/hisax/ix1_micro.c:261:						       card->para[0], card->para[1]);
./isdn/hisax/ix1_micro.c:280:	cs->hw.ix1.isac_ale = card->para[1] + ISAC_COMMAND_OFFSET;
./isdn/hisax/ix1_micro.c:281:	cs->hw.ix1.hscx_ale = card->para[1] + HSCX_COMMAND_OFFSET;
./isdn/hisax/ix1_micro.c:282:	cs->hw.ix1.isac = card->para[1] + ISAC_DATA_OFFSET;
./isdn/hisax/ix1_micro.c:283:	cs->hw.ix1.hscx = card->para[1] + HSCX_DATA_OFFSET;
./isdn/hisax/ix1_micro.c:284:	cs->hw.ix1.cfg_reg = card->para[1];
./isdn/hisax/ix1_micro.c:285:	cs->irq = card->para[0];
./isdn/hisax/enternow_pci.c:31: * 1. Load hisax with card-specific parameters, this example ist for
./isdn/hisax/enternow_pci.c:390:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/avm_a1p.c:219:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/avm_a1p.c:229:	cs->hw.avm.cfg_reg = card->para[1];
./isdn/hisax/avm_a1p.c:230:	cs->irq = card->para[0];
./isdn/hisax/niccy.c:231:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/niccy.c:239:	if (!card->para[1] && isapnp_present()) {
./isdn/hisax/niccy.c:261:			card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/niccy.c:262:			card->para[2] = pnp_port_start(pnp_d, 1);
./isdn/hisax/niccy.c:263:			card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/niccy.c:264:			if (!card->para[0] || !card->para[1] ||
./isdn/hisax/niccy.c:265:			    !card->para[2]) {
./isdn/hisax/niccy.c:268:				       card->para[0], card->para[1],
./isdn/hisax/niccy.c:269:				       card->para[2]);
./isdn/hisax/niccy.c:277:	if (card->para[1]) {
./isdn/hisax/niccy.c:278:		cs->hw.niccy.isac = card->para[1] + ISAC_PNP;
./isdn/hisax/niccy.c:279:		cs->hw.niccy.hscx = card->para[1] + HSCX_PNP;
./isdn/hisax/niccy.c:280:		cs->hw.niccy.isac_ale = card->para[2] + ISAC_PNP;
./isdn/hisax/niccy.c:281:		cs->hw.niccy.hscx_ale = card->para[2] + HSCX_PNP;
./isdn/hisax/niccy.c:284:		cs->irq = card->para[0];
./isdn/hisax/config.c:859:	switch (card->typ) {
./isdn/hisax/config.c:1016:		       CardType[card->typ]);
./isdn/hisax/config.c:1039:	card->cs = cs;
./isdn/hisax/config.c:1050:	if (card->protocol == ISDN_PTYPE_NI1)
./isdn/hisax/config.c:1055:	cs->protocol = card->protocol;
./isdn/hisax/config.c:1057:	if (card->typ <= 0 || card->typ > ISDN_CTYPE_COUNT) {
./isdn/hisax/config.c:1059:		       "HiSax: Card Type %d out of range\n", card->typ);
./isdn/hisax/config.c:1077:	cs->typ = card->typ;
./isdn/hisax/config.c:1116:	card->cs = NULL;
./isdn/hisax/config.c:1144:	switch (card->typ) {
./isdn/hisax/config.c:1170:	card->cs = NULL;
./isdn/hisax/config.c:1187:	       (card->protocol == ISDN_PTYPE_1TR6) ? "1TR6" :
./isdn/hisax/config.c:1188:	       (card->protocol == ISDN_PTYPE_EURO) ? "EDSS1" :
./isdn/hisax/config.c:1189:	       (card->protocol == ISDN_PTYPE_LEASED) ? "LEASED" :
./isdn/hisax/config.c:1190:	       (card->protocol == ISDN_PTYPE_NI1) ? "NI1" :
./isdn/hisax/config.c:1204:	card->cs = NULL;
./isdn/hisax/gazel.c:493:	if (readreg_ipac(card->para[1], IPAC_ID) == 1)
./isdn/hisax/gazel.c:499:	cs->hw.gazel.cfg_reg = card->para[1] + 0xC000;
./isdn/hisax/gazel.c:500:	cs->hw.gazel.ipac = card->para[1];
./isdn/hisax/gazel.c:501:	cs->hw.gazel.isac = card->para[1] + 0x8000;
./isdn/hisax/gazel.c:502:	cs->hw.gazel.hscx[0] = card->para[1];
./isdn/hisax/gazel.c:503:	cs->hw.gazel.hscx[1] = card->para[1] + 0x4000;
./isdn/hisax/gazel.c:504:	cs->irq = card->para[0];
./isdn/hisax/gazel.c:625:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/gazel.c:635:	if (card->para[0]) {
./isdn/hisax/mic.c:193:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/mic.c:202:	cs->hw.mic.cfg_reg = card->para[1];
./isdn/hisax/mic.c:203:	cs->irq = card->para[0];
./isdn/hisax/s0box.c:215:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/s0box.c:223:	cs->hw.teles3.cfg_reg = card->para[1];
./isdn/hisax/s0box.c:230:	cs->irq = card->para[0];
./isdn/hisax/avm_pci.c:873:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/avm_pci.c:883:	if (card->para[1]) {
./isdn/hisax/avm_pci.c:885:		cs->hw.avm.cfg_reg = card->para[1];
./isdn/hisax/avm_pci.c:886:		cs->irq = card->para[0];
./isdn/hisax/hfc_pci.c:1639:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/hfc_pci.c:1674:			if ((card->para[0]) && (card->para[0] != (tmp_hfcpci->resource[0].start & PCI_BASE_ADDRESS_IO_MASK)))
./isdn/hisax/diva.c:1003:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/diva.c:1006:	if (!card->para[1])
./isdn/hisax/diva.c:1010:	cs->hw.diva.cfg_reg = card->para[1];
./isdn/hisax/diva.c:1017:		cs->hw.diva.isac = card->para[1] + DIVA_IPAC_DATA;
./isdn/hisax/diva.c:1018:		cs->hw.diva.hscx = card->para[1] + DIVA_IPAC_DATA;
./isdn/hisax/diva.c:1019:		cs->hw.diva.isac_adr = card->para[1] + DIVA_IPAC_ADR;
./isdn/hisax/diva.c:1020:		cs->hw.diva.hscx_adr = card->para[1] + DIVA_IPAC_ADR;
./isdn/hisax/diva.c:1024:		cs->hw.diva.ctrl = card->para[1] + DIVA_ISA_CTRL;
./isdn/hisax/diva.c:1025:		cs->hw.diva.isac = card->para[1] + DIVA_ISA_ISAC_DATA;
./isdn/hisax/diva.c:1026:		cs->hw.diva.hscx = card->para[1] + DIVA_HSCX_DATA;
./isdn/hisax/diva.c:1027:		cs->hw.diva.isac_adr = card->para[1] + DIVA_ISA_ISAC_ADR;
./isdn/hisax/diva.c:1028:		cs->hw.diva.hscx_adr = card->para[1] + DIVA_HSCX_ADR;
./isdn/hisax/diva.c:1030:	cs->irq = card->para[0];
./isdn/hisax/diva.c:1072:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/diva.c:1095:				card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/diva.c:1096:				card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/diva.c:1097:				if (!card->para[0] || !card->para[1]) {
./isdn/hisax/diva.c:1099:					       card->para[0], card->para[1]);
./isdn/hisax/diva.c:1103:				cs->hw.diva.cfg_reg  = card->para[1];
./isdn/hisax/diva.c:1104:				cs->irq = card->para[0];
./isdn/hisax/diva.c:1109:						card->para[1] + DIVA_IPAC_DATA;
./isdn/hisax/diva.c:1111:						card->para[1] + DIVA_IPAC_DATA;
./isdn/hisax/diva.c:1113:						card->para[1] + DIVA_IPAC_ADR;
./isdn/hisax/diva.c:1115:						card->para[1] + DIVA_IPAC_ADR;
./isdn/hisax/diva.c:1120:						card->para[1] + DIVA_ISA_CTRL;
./isdn/hisax/diva.c:1122:						card->para[1] + DIVA_ISA_ISAC_DATA;
./isdn/hisax/diva.c:1124:						card->para[1] + DIVA_HSCX_DATA;
./isdn/hisax/diva.c:1126:						card->para[1] + DIVA_ISA_ISAC_ADR;
./isdn/hisax/diva.c:1128:						card->para[1] + DIVA_HSCX_ADR;
./isdn/hisax/diva.c:1160:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/diva.c:1245:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/diva.c:1282:	return setup_diva_common(card->cs);
./isdn/hisax/telespci.c:290:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/saphir.c:245:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/saphir.c:254:	cs->hw.saphir.cfg_reg = card->para[1];
./isdn/hisax/saphir.c:255:	cs->hw.saphir.isac = card->para[1] + ISAC_DATA;
./isdn/hisax/saphir.c:256:	cs->hw.saphir.hscx = card->para[1] + HSCX_DATA;
./isdn/hisax/saphir.c:257:	cs->hw.saphir.ale = card->para[1] + ADDRESS_REG;
./isdn/hisax/saphir.c:258:	cs->irq = card->para[0];
./isdn/hisax/amd7930_fn.c:24: * 1. Load hisax with card-specific parameters, this example ist for
./isdn/hisax/isurf.c:203:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/isurf.c:211:	if (card->para[1] && card->para[2]) {
./isdn/hisax/isurf.c:212:		cs->hw.isurf.reset = card->para[1];
./isdn/hisax/isurf.c:213:		cs->hw.isurf.phymem = card->para[2];
./isdn/hisax/isurf.c:214:		cs->irq = card->para[0];
./isdn/hisax/bkm_a8.c:278:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/bkm_a8.c:291:	if (card->para[0] >= SCT_1 && card->para[0] <= SCT_4)
./isdn/hisax/bkm_a8.c:292:		cs->subtyp = card->para[0];
./isdn/hisax/teles3.c:276:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/teles3.c:286:	if (!card->para[1] && isapnp_present()) {
./isdn/hisax/teles3.c:305:					card->para[3] = pnp_port_start(pnp_d, 2);
./isdn/hisax/teles3.c:306:					card->para[2] = pnp_port_start(pnp_d, 1);
./isdn/hisax/teles3.c:307:					card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/teles3.c:308:					card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/teles3.c:309:					if (!card->para[0] || !card->para[1] || !card->para[2]) {
./isdn/hisax/teles3.c:311:						       card->para[0], card->para[1], card->para[2]);
./isdn/hisax/teles3.c:330:		cs->hw.teles3.cfg_reg = card->para[1];
./isdn/hisax/teles3.c:343:		cs->hw.teles3.hscx[0] = card->para[1] - 0x20;
./isdn/hisax/teles3.c:344:		cs->hw.teles3.hscx[1] = card->para[1];
./isdn/hisax/teles3.c:345:		cs->hw.teles3.isac = card->para[1] + 0x20;
./isdn/hisax/teles3.c:347:		cs->hw.teles3.cfg_reg = card->para[3];
./isdn/hisax/teles3.c:348:		cs->hw.teles3.isac = card->para[2] - 32;
./isdn/hisax/teles3.c:349:		cs->hw.teles3.hscx[0] = card->para[1] - 32;
./isdn/hisax/teles3.c:350:		cs->hw.teles3.hscx[1] = card->para[1];
./isdn/hisax/teles3.c:353:		cs->hw.teles3.isac = card->para[1] - 32;
./isdn/hisax/teles3.c:354:		cs->hw.teles3.hscx[0] = card->para[2] - 32;
./isdn/hisax/teles3.c:355:		cs->hw.teles3.hscx[1] = card->para[2];
./isdn/hisax/teles3.c:357:	cs->irq = card->para[0];
./isdn/hisax/teles3.c:377:					       CardType[card->typ],
./isdn/hisax/teles3.c:385:					       CardType[card->typ],
./isdn/hisax/teleint.c:264:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/teleint.c:272:	cs->hw.hfc.addr = card->para[1] & 0x3fe;
./isdn/hisax/teleint.c:273:	cs->irq = card->para[0];
./isdn/hisax/hfcscard.c:170:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/hfcscard.c:177:	if (!card->para[1] && isapnp_present()) {
./isdn/hisax/hfcscard.c:196:					card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/hfcscard.c:197:					card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/hfcscard.c:198:					if (!card->para[0] || !card->para[1]) {
./isdn/hisax/hfcscard.c:200:						       card->para[0], card->para[1]);
./isdn/hisax/hfcscard.c:218:	cs->hw.hfcD.addr = card->para[1] & 0xfffe;
./isdn/hisax/hfcscard.c:219:	cs->irq = card->para[0];
./isdn/hisax/hfcscard.c:237:		       CardType[card->typ],
./isdn/hisax/avm_a1.c:183:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/avm_a1.c:191:	cs->hw.avm.cfg_reg = card->para[1] + 0x1800;
./isdn/hisax/avm_a1.c:192:	cs->hw.avm.isac = card->para[1] + 0x1400 - 0x20;
./isdn/hisax/avm_a1.c:193:	cs->hw.avm.hscx[0] = card->para[1] + 0x400 - 0x20;
./isdn/hisax/avm_a1.c:194:	cs->hw.avm.hscx[1] = card->para[1] + 0xc00 - 0x20;
./isdn/hisax/avm_a1.c:195:	cs->hw.avm.isacfifo = card->para[1] + 0x1000;
./isdn/hisax/avm_a1.c:196:	cs->hw.avm.hscxfifo[0] = card->para[1];
./isdn/hisax/avm_a1.c:197:	cs->hw.avm.hscxfifo[1] = card->para[1] + 0x800;
./isdn/hisax/avm_a1.c:198:	cs->irq = card->para[0];
./isdn/hisax/teles0.c:269:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/teles0.c:278:		cs->hw.teles0.cfg_reg = card->para[2];
./isdn/hisax/teles0.c:282:	if (card->para[1] < 0x10000) {
./isdn/hisax/teles0.c:283:		card->para[1] <<= 4;
./isdn/hisax/teles0.c:286:		       (unsigned long) card->para[1]);
./isdn/hisax/teles0.c:288:	cs->irq = card->para[0];
./isdn/hisax/teles0.c:293:			       CardType[card->typ],
./isdn/hisax/teles0.c:325:	cs->hw.teles0.phymem = card->para[1];
./isdn/hisax/teles0.c:329:		       CardType[card->typ],
./isdn/hisax/sportster.c:212:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/sportster.c:220:	cs->hw.spt.cfg_reg = card->para[1];
./isdn/hisax/sportster.c:221:	cs->irq = card->para[0];
./isdn/hisax/bkm_a4t.c:327:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/hfc_sx.c:1398:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/hfc_sx.c:1404:	if (!card->para[1] && isapnp_present()) {
./isdn/hisax/hfc_sx.c:1423:					card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/hfc_sx.c:1424:					card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/hfc_sx.c:1425:					if (!card->para[0] || !card->para[1]) {
./isdn/hisax/hfc_sx.c:1427:						       card->para[0], card->para[1]);
./isdn/hisax/hfc_sx.c:1445:	cs->hw.hfcsx.base = card->para[1] & 0xfffe;
./isdn/hisax/hfc_sx.c:1446:	cs->irq = card->para[0];
./isdn/hisax/elsa.c:839:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/elsa.c:842:	cs->hw.elsa.base = card->para[0];
./isdn/hisax/elsa.c:923:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/elsa.c:926:	if (!card->para[1] && isapnp_present()) {
./isdn/hisax/elsa.c:945:					card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/elsa.c:946:					card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/elsa.c:948:					if (!card->para[0] || !card->para[1]) {
./isdn/hisax/elsa.c:950:						       card->para[0], card->para[1]);
./isdn/hisax/elsa.c:974:	if (card->para[1] && card->para[0]) {
./isdn/hisax/elsa.c:975:		cs->hw.elsa.base = card->para[1];
./isdn/hisax/elsa.c:976:		cs->irq = card->para[0];
./isdn/hisax/elsa.c:1000:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/elsa.c:1003:	cs->hw.elsa.base = card->para[1];
./isdn/hisax/elsa.c:1004:	cs->irq = card->para[0];
./isdn/hisax/elsa.c:1035:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/elsa.c:1099:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/elsa.c:1213:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/asuscom.c:321:	struct IsdnCardState *cs = card->cs;
./isdn/hisax/asuscom.c:330:	if (!card->para[1] && isapnp_present()) {
./isdn/hisax/asuscom.c:349:					card->para[1] = pnp_port_start(pnp_d, 0);
./isdn/hisax/asuscom.c:350:					card->para[0] = pnp_irq(pnp_d, 0);
./isdn/hisax/asuscom.c:351:					if (!card->para[0] || !card->para[1]) {
./isdn/hisax/asuscom.c:353:						       card->para[0], card->para[1]);
./isdn/hisax/asuscom.c:372:	cs->hw.asus.cfg_reg = card->para[1];
./isdn/hisax/asuscom.c:373:	cs->irq = card->para[0];
./isdn/hysdn/boardergo.c:44:	if (!card->irq_enabled)
./isdn/hysdn/boardergo.c:47:	spin_lock_irqsave(&card->hysdn_lock, flags); /* no further irqs allowed */
./isdn/hysdn/boardergo.c:49:	if (!(bytein(card->iobase + PCI9050_INTR_REG) & PCI9050_INTR_REG_STAT1)) {
./isdn/hysdn/boardergo.c:50:		spin_unlock_irqrestore(&card->hysdn_lock, flags);	/* restore old state */
./isdn/hysdn/boardergo.c:54:	dpr = card->dpram;
./isdn/hysdn/boardergo.c:60:	if (!card->hw_lock)
./isdn/hysdn/boardergo.c:61:		schedule_work(&card->irq_queue);
./isdn/hysdn/boardergo.c:62:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:81:	if (card->state != CARD_STATE_RUN)
./isdn/hysdn/boardergo.c:84:	dpr = card->dpram;	/* point to DPRAM */
./isdn/hysdn/boardergo.c:86:	spin_lock_irqsave(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:87:	if (card->hw_lock) {
./isdn/hysdn/boardergo.c:88:		spin_unlock_irqrestore(&card->hysdn_lock, flags);	/* hardware currently unavailable */
./isdn/hysdn/boardergo.c:91:	card->hw_lock = 1;	/* we now lock the hardware */
./isdn/hysdn/boardergo.c:117:			card->hw_lock = 0;	/* free hardware again */
./isdn/hysdn/boardergo.c:120:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:137:	spin_lock_irqsave(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:138:	val = bytein(card->iobase + PCI9050_INTR_REG);	/* get actual value */
./isdn/hysdn/boardergo.c:140:	byteout(card->iobase + PCI9050_INTR_REG, val);
./isdn/hysdn/boardergo.c:141:	card->irq_enabled = 0;
./isdn/hysdn/boardergo.c:142:	byteout(card->iobase + PCI9050_USER_IO, PCI9050_E1_RESET);	/* reset E1 processor */
./isdn/hysdn/boardergo.c:143:	card->state = CARD_STATE_UNUSED;
./isdn/hysdn/boardergo.c:144:	card->err_log_state = ERRLOG_STATE_OFF;		/* currently no log active */
./isdn/hysdn/boardergo.c:146:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:157:	if (card->state != CARD_STATE_RUN) {
./isdn/hysdn/boardergo.c:158:		card->err_log_state = ERRLOG_STATE_OFF;		/* must be off */
./isdn/hysdn/boardergo.c:161:	spin_lock_irqsave(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:163:	if (((card->err_log_state == ERRLOG_STATE_OFF) && !on) ||
./isdn/hysdn/boardergo.c:164:	    ((card->err_log_state == ERRLOG_STATE_ON) && on)) {
./isdn/hysdn/boardergo.c:165:		spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:169:		card->err_log_state = ERRLOG_STATE_START;	/* request start */
./isdn/hysdn/boardergo.c:171:		card->err_log_state = ERRLOG_STATE_STOP;	/* request stop */
./isdn/hysdn/boardergo.c:173:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:174:	schedule_work(&card->irq_queue);
./isdn/hysdn/boardergo.c:185:	tErgDpram *dpr = card->dpram;
./isdn/hysdn/boardergo.c:221:	if (card->debug_flags & LOG_POF_CARD)
./isdn/hysdn/boardergo.c:224:	dst = card->dpram;	/* pointer to start of DPRAM */
./isdn/hysdn/boardergo.c:236:		memset(card->dpram, 0, ERG_DPRAM_FILL_SIZE);	/* fill the DPRAM still not cleared */
./isdn/hysdn/boardergo.c:237:		dpram = card->dpram;	/* get pointer to dpram structure */
./isdn/hysdn/boardergo.c:241:		byteout(card->iobase + PCI9050_USER_IO, PCI9050_E1_RUN);	/* start E1 processor */
./isdn/hysdn/boardergo.c:246:		if (((tDpramBootSpooler *) card->dpram)->Len != DPRAM_SPOOLER_DATA_SIZE) {
./isdn/hysdn/boardergo.c:247:			if (card->debug_flags & LOG_POF_CARD)
./isdn/hysdn/boardergo.c:263:	tDpramBootSpooler *sp = (tDpramBootSpooler *) card->dpram;
./isdn/hysdn/boardergo.c:271:	if (card->debug_flags & LOG_POF_CARD)
./isdn/hysdn/boardergo.c:289:			if (card->debug_flags & LOG_POF_CARD)
./isdn/hysdn/boardergo.c:324:	tErgDpram *dpr = card->dpram;	/* pointer to DPRAM structure */
./isdn/hysdn/boardergo.c:330:	if (card->debug_flags & LOG_POF_CARD)
./isdn/hysdn/boardergo.c:350:			if (card->debug_flags & LOG_POF_RECORD)
./isdn/hysdn/boardergo.c:352:			spin_lock_irqsave(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:354:			card->state = CARD_STATE_RUN;	/* now card is running */
./isdn/hysdn/boardergo.c:356:			byteout(card->iobase + PCI9050_INTR_REG,
./isdn/hysdn/boardergo.c:357:				bytein(card->iobase + PCI9050_INTR_REG) |
./isdn/hysdn/boardergo.c:359:			card->irq_enabled = 1;	/* we are ready to receive interrupts */
./isdn/hysdn/boardergo.c:365:			spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/boardergo.c:366:			if ((hynet_enable & (1 << card->myid))
./isdn/hysdn/boardergo.c:370:				card->state = CARD_STATE_BOOTERR;
./isdn/hysdn/boardergo.c:383:	if (card->debug_flags & LOG_POF_CARD)
./isdn/hysdn/boardergo.c:399:	free_irq(card->irq, card);	/* release interrupt */
./isdn/hysdn/boardergo.c:400:	release_region(card->iobase + PCI9050_INTR_REG, 1);	/* release all io ports */
./isdn/hysdn/boardergo.c:401:	release_region(card->iobase + PCI9050_USER_IO, 1);
./isdn/hysdn/boardergo.c:402:	iounmap(card->dpram);
./isdn/hysdn/boardergo.c:403:	card->dpram = NULL;	/* release shared mem */
./isdn/hysdn/boardergo.c:415:	if (!request_region(card->iobase + PCI9050_INTR_REG, 1, "HYSDN"))
./isdn/hysdn/boardergo.c:417:	if (!request_region(card->iobase + PCI9050_USER_IO, 1, "HYSDN")) {
./isdn/hysdn/boardergo.c:418:		release_region(card->iobase + PCI9050_INTR_REG, 1);
./isdn/hysdn/boardergo.c:421:	card->memend = card->membase + ERG_DPRAM_PAGE_SIZE - 1;
./isdn/hysdn/boardergo.c:422:	if (!(card->dpram = ioremap(card->membase, ERG_DPRAM_PAGE_SIZE))) {
./isdn/hysdn/boardergo.c:423:		release_region(card->iobase + PCI9050_INTR_REG, 1);
./isdn/hysdn/boardergo.c:424:		release_region(card->iobase + PCI9050_USER_IO, 1);
./isdn/hysdn/boardergo.c:429:	if (request_irq(card->irq, ergo_interrupt, IRQF_SHARED, "HYSDN", card)) {
./isdn/hysdn/boardergo.c:434:	card->stopcard = ergo_stopcard;
./isdn/hysdn/boardergo.c:435:	card->releasehardware = ergo_releasehardware;
./isdn/hysdn/boardergo.c:436:	card->testram = ergo_testram;
./isdn/hysdn/boardergo.c:437:	card->writebootimg = ergo_writebootimg;
./isdn/hysdn/boardergo.c:438:	card->writebootseq = ergo_writebootseq;
./isdn/hysdn/boardergo.c:439:	card->waitpofready = ergo_waitpofready;
./isdn/hysdn/boardergo.c:440:	card->set_errlog_state = ergo_set_errlog_state;
./isdn/hysdn/boardergo.c:441:	INIT_WORK(&card->irq_queue, ergo_irq_bh);
./isdn/hysdn/boardergo.c:442:	spin_lock_init(&card->hysdn_lock);
./isdn/hysdn/hysdn_boot.c:87:	struct boot_data *boot = card->boot;	/* pointer to boot specific data */
./isdn/hysdn/hysdn_boot.c:96:		if (card->debug_flags & LOG_POF_RECORD)
./isdn/hysdn/hysdn_boot.c:103:		if (card->debug_flags & LOG_POF_RECORD)
./isdn/hysdn/hysdn_boot.c:132:			     card->writebootimg(card, imgp,
./isdn/hysdn/hysdn_boot.c:141:		if (card->debug_flags & LOG_POF_RECORD)
./isdn/hysdn/hysdn_boot.c:146:		if ((boot->last_error = card->writebootseq(card, boot->buf.BootBuf, datlen)) < 0)
./isdn/hysdn/hysdn_boot.c:150:			return (card->waitpofready(card));	/* data completely spooled, wait for ready */
./isdn/hysdn/hysdn_boot.c:155:		if (card->debug_flags & LOG_POF_RECORD)
./isdn/hysdn/hysdn_boot.c:176:	struct boot_data *boot = card->boot;	/* pointer to boot specific data */
./isdn/hysdn/hysdn_boot.c:183:	if (card->debug_flags & LOG_POF_WRITE)
./isdn/hysdn/hysdn_boot.c:188:		if (card->debug_flags & LOG_POF_WRITE)
./isdn/hysdn/hysdn_boot.c:206:		if (card->debug_flags & LOG_POF_WRITE)
./isdn/hysdn/hysdn_boot.c:217:		if (card->debug_flags & LOG_POF_RECORD)
./isdn/hysdn/hysdn_boot.c:234:		if (card->debug_flags & LOG_POF_WRITE)
./isdn/hysdn/hysdn_boot.c:275:	if (card->boot) {
./isdn/hysdn/hysdn_boot.c:276:		if (card->debug_flags & LOG_POF_OPEN)
./isdn/hysdn/hysdn_boot.c:282:		if (card->debug_flags & LOG_MEM_ERR)
./isdn/hysdn/hysdn_boot.c:286:	card->boot = boot;
./isdn/hysdn/hysdn_boot.c:287:	card->state = CARD_STATE_BOOTING;
./isdn/hysdn/hysdn_boot.c:289:	card->stopcard(card);	/* first stop the card */
./isdn/hysdn/hysdn_boot.c:290:	if (card->testram(card)) {
./isdn/hysdn/hysdn_boot.c:291:		if (card->debug_flags & LOG_POF_OPEN)
./isdn/hysdn/hysdn_boot.c:294:		card->state = CARD_STATE_BOOTERR;	/* show boot error */
./isdn/hysdn/hysdn_boot.c:301:	if (card->debug_flags & LOG_POF_OPEN)
./isdn/hysdn/hysdn_boot.c:315:	struct boot_data *boot = card->boot;	/* pointer to boot specific data */
./isdn/hysdn/hysdn_boot.c:320:	card->boot = NULL;	/* no boot active */
./isdn/hysdn/hysdn_boot.c:323:	if (card->state == CARD_STATE_RUN)
./isdn/hysdn/hysdn_boot.c:324:		card->set_errlog_state(card, 1);	/* activate error log */
./isdn/hysdn/hysdn_boot.c:326:	if (card->debug_flags & LOG_POF_OPEN)
./isdn/hysdn/hysdn_boot.c:342:	if (card->debug_flags & LOG_POF_RECORD)
./isdn/hysdn/hysdn_boot.c:373:			card->bchans = *(cp + 2);
./isdn/hysdn/hysdn_boot.c:379:			card->faxchans = *(cp + 2);
./isdn/hysdn/hysdn_boot.c:385:			memcpy(card->mac_addr, cp + 2, 6);
./isdn/hysdn/hysdn_init.c:74:	card->myid = cardmax;	/* set own id */
./isdn/hysdn/hysdn_init.c:75:	card->bus = akt_pcidev->bus->number;
./isdn/hysdn/hysdn_init.c:76:	card->devfn = akt_pcidev->devfn;	/* slot + function */
./isdn/hysdn/hysdn_init.c:77:	card->subsysid = akt_pcidev->subsystem_device;
./isdn/hysdn/hysdn_init.c:78:	card->irq = akt_pcidev->irq;
./isdn/hysdn/hysdn_init.c:79:	card->iobase = pci_resource_start(akt_pcidev, PCI_REG_PLX_IO_BASE);
./isdn/hysdn/hysdn_init.c:80:	card->plxbase = pci_resource_start(akt_pcidev, PCI_REG_PLX_MEM_BASE);
./isdn/hysdn/hysdn_init.c:81:	card->membase = pci_resource_start(akt_pcidev, PCI_REG_MEMORY_BASE);
./isdn/hysdn/hysdn_init.c:82:	card->brdtype = BD_NONE;	/* unknown */
./isdn/hysdn/hysdn_init.c:83:	card->debug_flags = DEF_DEB_FLAGS;	/* set default debug */
./isdn/hysdn/hysdn_init.c:84:	card->faxchans = 0;	/* default no fax channels */
./isdn/hysdn/hysdn_init.c:85:	card->bchans = 2;	/* and 2 b-channels */
./isdn/hysdn/hysdn_init.c:86:	card->brdtype = ent->driver_data;
./isdn/hysdn/hysdn_init.c:89:		printk(KERN_WARNING "HYSDN: card at io 0x%04x already in use\n", card->iobase);
./isdn/hysdn/hysdn_init.c:95:	card->next = NULL;	/*end of chain */
./isdn/hysdn/hysdn_init.c:118:	if (card->stopcard)
./isdn/hysdn/hysdn_init.c:119:		card->stopcard(card);
./isdn/hysdn/hysdn_init.c:125:	if (card->releasehardware)
./isdn/hysdn/hysdn_init.c:126:		card->releasehardware(card);   /* free all hardware resources */
./isdn/hysdn/hysdn_init.c:136:				tmp->next = card->next;
./isdn/hysdn/hycapi.c:104:	kfree(card->hyctrlinfo);
./isdn/hysdn/hycapi.c:107:	card->hyctrlinfo = NULL;
./isdn/hysdn/hycapi.c:133:		       card->myid);
./isdn/hysdn/hycapi.c:138:	schedule_work(&card->irq_queue);
./isdn/hysdn/hycapi.c:171:		       card->myid);
./isdn/hysdn/hycapi.c:244:		MaxLogicalConnections = card->bchans * -MaxLogicalConnections;
./isdn/hysdn/hycapi.c:247:		MaxLogicalConnections = card->bchans;
./isdn/hysdn/hycapi.c:279:		       card->myid);
./isdn/hysdn/hycapi.c:325:	hycapictrl_info *cinfo = card->hyctrlinfo;
./isdn/hysdn/hycapi.c:345:	hycapictrl_info *cinfo = card->hyctrlinfo;
./isdn/hysdn/hycapi.c:446:	seq_printf(m, "%-16s 0x%x\n", "io", card->iobase);
./isdn/hysdn/hycapi.c:447:	seq_printf(m, "%-16s %d\n", "irq", card->irq);
./isdn/hysdn/hycapi.c:449:	switch (card->brdtype) {
./isdn/hysdn/hycapi.c:511:		cinfo->card ? cinfo->card->iobase : 0x0,
./isdn/hysdn/hycapi.c:512:		cinfo->card ? cinfo->card->irq : 0,
./isdn/hysdn/hycapi.c:531:	hycapictrl_info *cinfo = card->hyctrlinfo;
./isdn/hysdn/hycapi.c:546:		       card->myid, len);
./isdn/hysdn/hycapi.c:557:			       card->myid);
./isdn/hysdn/hycapi.c:567:			       card->myid);
./isdn/hysdn/hycapi.c:586:			       "protocol. NCPI ignored.\n", card->myid);
./isdn/hysdn/hycapi.c:590:			       " current state\n", card->myid);
./isdn/hysdn/hycapi.c:593:			printk(KERN_ERR "HYSDN Card%d: invalid PLCI\n", card->myid);
./isdn/hysdn/hycapi.c:596:			printk(KERN_ERR "HYSDN Card%d: out of NCCI\n", card->myid);
./isdn/hysdn/hycapi.c:600:			       card->myid);
./isdn/hysdn/hycapi.c:604:			       card->myid, info);
./isdn/hysdn/hycapi.c:634:	hycapictrl_info *cinfo = card->hyctrlinfo;
./isdn/hysdn/hycapi.c:662:	hycapictrl_info *cinfo = card->hyctrlinfo;
./isdn/hysdn/hycapi.c:711:	cinfo = card->hyctrlinfo;
./isdn/hysdn/hycapi.c:719:	ctrl->profile.ncontroller = card->myid;
./isdn/hysdn/hycapi.c:720:	ctrl->profile.nbchannel = card->bchans;
./isdn/hysdn/hycapi.c:724:		(card->faxchans ? B1_PROT_T30 : 0) |
./isdn/hysdn/hycapi.c:727:		(card->faxchans ? B2_PROT_T30 : 0) |
./isdn/hysdn/hycapi.c:731:		(card->faxchans ? B3_PROT_T30 : 0) |
./isdn/hysdn/hycapi.c:732:		(card->faxchans ? B3_PROT_T30EXT : 0) |
./isdn/hysdn/hycapi.c:745:	if ((hycapi_enable & (1 << card->myid)) == 0) {
./isdn/hysdn/hycapi.c:748:	if (!card->hyctrlinfo) {
./isdn/hysdn/hycapi.c:754:		card->hyctrlinfo = cinfo;
./isdn/hysdn/hycapi.c:759:		switch (card->brdtype) {
./isdn/hysdn/hycapi.c:791:		ctrl = &card->hyctrlinfo->capi_ctrl;
./isdn/hysdn/hysdn_net.c:69:	if (!card->mac_addr[0]) {
./isdn/hysdn/hysdn_net.c:78:		memcpy(dev->dev_addr, card->mac_addr, ETH_ALEN);
./isdn/hysdn/hysdn_net.c:160:	struct net_local *lp = card->netif;
./isdn/hysdn/hysdn_net.c:186:	struct net_local *lp = card->netif;
./isdn/hysdn/hysdn_net.c:220:	struct net_local *lp = card->netif;
./isdn/hysdn/hysdn_net.c:253:		printk(KERN_WARNING "No card-pt in hysdn_net_create!\n");
./isdn/hysdn/hysdn_net.c:271:	dev->base_addr = card->iobase;	/* IO address */
./isdn/hysdn/hysdn_net.c:272:	dev->irq = card->irq;	/* irq */
./isdn/hysdn/hysdn_net.c:281:	card->netif = dev;	/* setup the local pointer */
./isdn/hysdn/hysdn_net.c:283:	if (card->debug_flags & LOG_NET_INIT)
./isdn/hysdn/hysdn_net.c:295:	struct net_device *dev = card->netif;
./isdn/hysdn/hysdn_net.c:300:	card->netif = NULL;	/* clear out pointer */
./isdn/hysdn/hysdn_net.c:307:	if (card->debug_flags & LOG_NET_INIT)
./isdn/hysdn/hysdn_net.c:320:	struct net_device *dev = card->netif;
./isdn/hysdn/hysdn_procconf.c:58:	if (cnf->card->debug_flags & LOG_CNF_LINE)
./isdn/hysdn/hysdn_procconf.c:70:			if (cnf->card->debug_flags & LOG_CNF_MISC)
./isdn/hysdn/hysdn_procconf.c:78:		if (cnf->card->debug_flags & LOG_CNF_DATA)
./isdn/hysdn/hysdn_procconf.c:120:			if (cnf->card->state != CARD_STATE_RUN)
./isdn/hysdn/hysdn_procconf.c:140:				cnf->card->state = CARD_STATE_BOOTERR;	/* show boot error */
./isdn/hysdn/hysdn_procconf.c:149:		if (cnf->card->state != CARD_STATE_RUN) {
./isdn/hysdn/hysdn_procconf.c:150:			if (cnf->card->debug_flags & LOG_CNF_MISC)
./isdn/hysdn/hysdn_procconf.c:190:					if (cnf->card->debug_flags & LOG_CNF_MISC)
./isdn/hysdn/hysdn_procconf.c:199:			if (cnf->card->debug_flags & LOG_CNF_MISC)
./isdn/hysdn/hysdn_procconf.c:238:	if (card->debug_flags & (LOG_PROC_OPEN | LOG_PROC_ALL))
./isdn/hysdn/hysdn_procconf.c:275:			card->myid,
./isdn/hysdn/hysdn_procconf.c:276:			card->bus,
./isdn/hysdn/hysdn_procconf.c:277:			PCI_SLOT(card->devfn),
./isdn/hysdn/hysdn_procconf.c:278:			card->brdtype,
./isdn/hysdn/hysdn_procconf.c:279:			card->irq,
./isdn/hysdn/hysdn_procconf.c:280:			card->iobase,
./isdn/hysdn/hysdn_procconf.c:281:			card->membase,
./isdn/hysdn/hysdn_procconf.c:282:			card->bchans,
./isdn/hysdn/hysdn_procconf.c:283:			card->faxchans,
./isdn/hysdn/hysdn_procconf.c:284:			card->state,
./isdn/hysdn/hysdn_procconf.c:312:	if (card->debug_flags & (LOG_PROC_OPEN | LOG_PROC_ALL))
./isdn/hysdn/hysdn_procconf.c:373:		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
./isdn/hysdn/hysdn_procconf.c:374:		if ((card->procconf = (void *) proc_create_data(conf_name,
./isdn/hysdn/hysdn_procconf.c:381:		card = card->next;	/* next entry */
./isdn/hysdn/hysdn_procconf.c:401:		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
./isdn/hysdn/hysdn_procconf.c:402:		if (card->procconf)
./isdn/hysdn/hysdn_procconf.c:407:		card = card->next;	/* point to next card */
./isdn/hysdn/hysdn_proclog.c:70:	struct procdata *pd = card->proclog;
./isdn/hysdn/hysdn_proclog.c:78:	cp += sprintf(cp, "HYSDN: card %d ", card->myid);
./isdn/hysdn/hysdn_proclog.c:86:	if (card->debug_flags & DEB_OUT_SYSLOG)
./isdn/hysdn/hysdn_proclog.c:103:	struct procdata *pd = card->proclog;
./isdn/hysdn/hysdn_proclog.c:120:	spin_lock_irqsave(&card->hysdn_lock, flags);
./isdn/hysdn/hysdn_proclog.c:140:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/hysdn_proclog.c:159:	rc = kstrtoul_from_user(buf, count, 0, &card->debug_flags);
./isdn/hysdn/hysdn_proclog.c:162:	hysdn_addlog(card, "debug set to 0x%lx", card->debug_flags);
./isdn/hysdn/hysdn_proclog.c:177:		struct procdata *pd = card->proclog;
./isdn/hysdn/hysdn_proclog.c:211:		struct procdata *pd = card->proclog;
./isdn/hysdn/hysdn_proclog.c:215:		spin_lock_irqsave(&card->hysdn_lock, flags);
./isdn/hysdn/hysdn_proclog.c:221:		spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/hysdn_proclog.c:258:			pd = card->proclog;	/* pointer to procfs log */
./isdn/hysdn/hysdn_proclog.c:289:	struct procdata *pd = card->proclog;
./isdn/hysdn/hysdn_proclog.c:329:		sprintf(pd->log_name, "%s%d", PROC_LOG_BASENAME, card->myid);
./isdn/hysdn/hysdn_proclog.c:336:		card->proclog = (void *) pd;	/* remember procfs structure */
./isdn/hysdn/hysdn_proclog.c:351:	if ((pd = (struct procdata *) card->proclog) != NULL) {
./isdn/hysdn/hysdn_proclog.c:355:		card->proclog = NULL;
./isdn/hysdn/hysdn_sched.c:37:		if (hynet_enable & (1 << card->myid)) {
./isdn/hysdn/hysdn_sched.c:45:		if (card->err_log_state == ERRLOG_STATE_ON)
./isdn/hysdn/hysdn_sched.c:46:			card->err_log_state = ERRLOG_STATE_START;	/* start new fetch */
./isdn/hysdn/hysdn_sched.c:51:		if (hycapi_enable & (1 << card->myid)) {
./isdn/hysdn/hysdn_sched.c:80:	if (card->net_tx_busy) {
./isdn/hysdn/hysdn_sched.c:81:		card->net_tx_busy = 0;	/* reset flag */
./isdn/hysdn/hysdn_sched.c:85:	if (card->async_busy) {
./isdn/hysdn/hysdn_sched.c:86:		if (card->async_len <= maxlen) {
./isdn/hysdn/hysdn_sched.c:87:			memcpy(buf, card->async_data, card->async_len);
./isdn/hysdn/hysdn_sched.c:88:			*len = card->async_len;
./isdn/hysdn/hysdn_sched.c:89:			*chan = card->async_channel;
./isdn/hysdn/hysdn_sched.c:90:			card->async_busy = 0;	/* reset request */
./isdn/hysdn/hysdn_sched.c:93:		card->async_busy = 0;	/* in case of length error */
./isdn/hysdn/hysdn_sched.c:95:	if ((card->err_log_state == ERRLOG_STATE_START) &&
./isdn/hysdn/hysdn_sched.c:100:		card->err_log_state = ERRLOG_STATE_ON;	/* new state is on */
./isdn/hysdn/hysdn_sched.c:103:	if ((card->err_log_state == ERRLOG_STATE_STOP) &&
./isdn/hysdn/hysdn_sched.c:108:		card->err_log_state = ERRLOG_STATE_OFF;		/* new state is off */
./isdn/hysdn/hysdn_sched.c:112:	if ((hynet_enable & (1 << card->myid)) &&
./isdn/hysdn/hysdn_sched.c:120:			card->net_tx_busy = 1;	/* we are busy sending network data */
./isdn/hysdn/hysdn_sched.c:126:	if (((hycapi_enable & (1 << card->myid))) &&
./isdn/hysdn/hysdn_sched.c:155:	if (card->debug_flags & LOG_SCHED_ASYN)
./isdn/hysdn/hysdn_sched.c:158:	while (card->async_busy) {
./isdn/hysdn/hysdn_sched.c:160:		if (card->debug_flags & LOG_SCHED_ASYN)
./isdn/hysdn/hysdn_sched.c:168:	spin_lock_irqsave(&card->hysdn_lock, flags);
./isdn/hysdn/hysdn_sched.c:169:	strcpy(card->async_data, line);
./isdn/hysdn/hysdn_sched.c:170:	card->async_len = strlen(line) + 1;
./isdn/hysdn/hysdn_sched.c:171:	card->async_channel = chan;
./isdn/hysdn/hysdn_sched.c:172:	card->async_busy = 1;	/* request transfer */
./isdn/hysdn/hysdn_sched.c:175:	schedule_work(&card->irq_queue);
./isdn/hysdn/hysdn_sched.c:176:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./isdn/hysdn/hysdn_sched.c:178:	if (card->debug_flags & LOG_SCHED_ASYN)
./isdn/hysdn/hysdn_sched.c:183:	while (card->async_busy) {
./isdn/hysdn/hysdn_sched.c:185:		if (card->debug_flags & LOG_SCHED_ASYN)
./isdn/hysdn/hysdn_sched.c:193:	if (card->debug_flags & LOG_SCHED_ASYN)
./isdn/hardware/eicon/diva.c:585:	card--;
./isdn/hardware/eicon/capimain.c:87:	seq_printf(m, "Id         : %d\n", card->Id);
./isdn/hardware/eicon/capimain.c:88:	seq_printf(m, "Channels   : %d\n", card->d.channels);
./isdn/hardware/eicon/capifunc.c:176:		if (ControllerMap[card->Id] == controller) {
./isdn/hardware/eicon/capifunc.c:177:			if (card->remove_in_progress)
./isdn/hardware/eicon/capifunc.c:340:	capi_ctr_handle_message(&card->capi_ctrl, appl->Id, dmb);
./isdn/hardware/eicon/capifunc.c:407:		if (card->d.request == d->request) {
./isdn/hardware/eicon/capifunc.c:408:			card->remove_in_progress = 1;
./isdn/hardware/eicon/capifunc.c:420:		detach_capi_ctr(&card->capi_ctrl);
./isdn/hardware/eicon/capifunc.c:428:		clean_adapter(card->Id - 1, &free_mem_q);
./isdn/hardware/eicon/capifunc.c:430:			 ControllerMap[card->Id], card->Id))
./isdn/hardware/eicon/capifunc.c:431:			ControllerMap[card->Id] = 0;
./isdn/hardware/eicon/capifunc.c:462:		d.request = card->d.request;
./isdn/hardware/eicon/capifunc.c:504:	memcpy(&card->d, d, sizeof(DESCRIPTOR));
./isdn/hardware/eicon/capifunc.c:507:	card->d.request((ENTITY *)&sync_req);
./isdn/hardware/eicon/capifunc.c:508:	strlcpy(card->name, sync_req.GetName.name, sizeof(card->name));
./isdn/hardware/eicon/capifunc.c:509:	ctrl = &card->capi_ctrl;
./isdn/hardware/eicon/capifunc.c:510:	strcpy(ctrl->name, card->name);
./isdn/hardware/eicon/capifunc.c:525:	card->Id = find_free_id();
./isdn/hardware/eicon/capifunc.c:536:	card->d.request((ENTITY *)&sync_req);
./isdn/hardware/eicon/capifunc.c:546:	a = &adapter[card->Id - 1];
./isdn/hardware/eicon/capifunc.c:547:	card->adapter = a;
./isdn/hardware/eicon/capifunc.c:549:	ControllerMap[card->Id] = (byte) (ctrl->cnr);
./isdn/hardware/eicon/capifunc.c:551:	DBG_TRC(("AddAdapterMap (%d) -> (%d)", ctrl->cnr, card->Id))
./isdn/hardware/eicon/capifunc.c:557:	card->d.request((ENTITY *)&sync_req);
./isdn/hardware/eicon/capifunc.c:562:	a->request = DIRequest;	/* card->d.request; */
./isdn/hardware/eicon/capifunc.c:563:	a->max_plci = card->d.channels + 30;
./isdn/hardware/eicon/capifunc.c:564:	a->max_listen = (card->d.channels > 2) ? 8 : 2;
./isdn/hardware/eicon/capifunc.c:575:		a->Id = (byte) card->Id;
./isdn/hardware/eicon/capifunc.c:579:		a->plci[k].Sig.user[0] = (word) (card->Id - 1);
./isdn/hardware/eicon/capifunc.c:584:		a->plci[k].NL.user[0] = (word) ((card->Id - 1) | 0x8000);
./isdn/hardware/eicon/capifunc.c:589:	a->profile.Number = card->Id;
./isdn/hardware/eicon/capifunc.c:590:	a->profile.Channels = card->d.channels;
./isdn/hardware/eicon/capifunc.c:591:	if (card->d.features & DI_FAX3) {
./isdn/hardware/eicon/capifunc.c:593:		if (card->d.features & DI_CODEC)
./isdn/hardware/eicon/capifunc.c:608:		if (card->d.features & DI_CODEC)
./isdn/hardware/eicon/capifunc.c:678:	for (i = card->Id; i < max_adapter; i++) {
./isdn/hardware/eicon/capifunc.c:686:	list_add(&(card->list), &cards);
./isdn/hardware/eicon/capifunc.c:703:	PUT_WORD(&ctrl->profile.nbchannel, card->d.channels);
./isdn/hardware/eicon/capifunc.c:898:		if (card->remove_in_progress) {
./isdn/hardware/eicon/capifunc.c:911:	msg->header.controller = ControllerMap[card->Id]
./isdn/hardware/eicon/capifunc.c:1019:	(*(os_card->d.request)) (e);
./isdn/hardware/eicon/idifunc.c:70:		if (card->d.request == d->request) {
./isdn/hardware/eicon/idifunc.c:94:	memcpy(&card->d, d, sizeof(DESCRIPTOR));
./isdn/hardware/eicon/idifunc.c:98:	card->d.request((ENTITY *)&sync_req);
./isdn/hardware/eicon/idifunc.c:101:	card->Id = adapter_nr;
./isdn/hardware/eicon/idifunc.c:104:		list_add_tail(&card->list, &cards);
./isdn/hardware/eicon/idifunc.c:125:	diva_user_mode_idi_remove_adapter(card->Id);
./isdn/hardware/eicon/idifunc.c:127:	list_del(&card->list);
./isdn/hardware/eicon/idifunc.c:129:	DBG_LOG(("idi proc entry removed for card %d", card->Id));
./isdn/hardware/eicon/idifunc.c:145:		list_del(&card->list);
./isdn/hardware/eicon/idifunc.c:147:		diva_user_mode_idi_remove_adapter(card->Id);
./isdn/hardware/mISDN/w6692.c:98:	card->dch.debug = debug;
./isdn/hardware/mISDN/w6692.c:99:	card->bc[0].bch.debug = debug;
./isdn/hardware/mISDN/w6692.c:100:	card->bc[1].bch.debug = debug;
./isdn/hardware/mISDN/w6692.c:132:	return inb(card->addr + offset);
./isdn/hardware/mISDN/w6692.c:138:	outb(value, card->addr + offset);
./isdn/hardware/mISDN/w6692.c:156:	WriteW6692(card, W_IMASK, card->imask);
./isdn/hardware/mISDN/w6692.c:173:	pr_notice("%s: Winbond W6692 version: %s\n", card->name,
./isdn/hardware/mISDN/w6692.c:180:	if ((!(card->fmask & led)) || card->subtype == W6692_USR)
./isdn/hardware/mISDN/w6692.c:183:		card->xdata &= 0xfb;	/*  LED ON */
./isdn/hardware/mISDN/w6692.c:184:		WriteW6692(card, W_XDATA, card->xdata);
./isdn/hardware/mISDN/w6692.c:186:		card->xdata |= 0x04;	/*  LED OFF */
./isdn/hardware/mISDN/w6692.c:187:		WriteW6692(card, W_XDATA, card->xdata);
./isdn/hardware/mISDN/w6692.c:194:	pr_debug("%s: ph_command %x\n", card->name, cmd);
./isdn/hardware/mISDN/w6692.c:201:	if (card->state == W_L1CMD_RST)
./isdn/hardware/mISDN/w6692.c:203:	schedule_event(&card->dch, FLG_PHCHANGE);
./isdn/hardware/mISDN/w6692.c:211:	switch (card->state) {
./isdn/hardware/mISDN/w6692.c:251:			 card->name, card->state, dch->state);
./isdn/hardware/mISDN/w6692.c:254:	pr_debug("%s: TE newstate %02x\n", card->name, dch->state);
./isdn/hardware/mISDN/w6692.c:260:	struct dchannel *dch = &card->dch;
./isdn/hardware/mISDN/w6692.c:263:	pr_debug("%s: empty_Dfifo %d\n", card->name, count);
./isdn/hardware/mISDN/w6692.c:265:		dch->rx_skb = mI_alloc_skb(card->dch.maxlen, GFP_ATOMIC);
./isdn/hardware/mISDN/w6692.c:267:			pr_info("%s: D receive out of memory\n", card->name);
./isdn/hardware/mISDN/w6692.c:273:		pr_debug("%s: empty_Dfifo overrun %d\n", card->name,
./isdn/hardware/mISDN/w6692.c:279:	insb(card->addr + W_D_RFIFO, ptr, count);
./isdn/hardware/mISDN/w6692.c:282:		snprintf(card->log, 63, "D-recv %s %d ",
./isdn/hardware/mISDN/w6692.c:283:			 card->name, count);
./isdn/hardware/mISDN/w6692.c:284:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);
./isdn/hardware/mISDN/w6692.c:291:	struct dchannel *dch = &card->dch;
./isdn/hardware/mISDN/w6692.c:296:	pr_debug("%s: fill_Dfifo\n", card->name);
./isdn/hardware/mISDN/w6692.c:308:	outsb(card->addr + W_D_XFIFO, ptr, count);
./isdn/hardware/mISDN/w6692.c:311:		pr_debug("%s: fill_Dfifo dbusytimer running\n", card->name);
./isdn/hardware/mISDN/w6692.c:318:		snprintf(card->log, 63, "D-send %s %d ",
./isdn/hardware/mISDN/w6692.c:319:			 card->name, count);
./isdn/hardware/mISDN/w6692.c:320:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);
./isdn/hardware/mISDN/w6692.c:327:	struct dchannel *dch = &card->dch;
./isdn/hardware/mISDN/w6692.c:340:		pr_info("%s: %s without TX_BUSY\n", card->name, __func__);
./isdn/hardware/mISDN/w6692.c:345:		pr_info("%s: XDU no TX_BUSY\n", card->name);
./isdn/hardware/mISDN/w6692.c:359:			pr_debug("%s: D-channel RDOV\n", card->name);
./isdn/hardware/mISDN/w6692.c:361:			card->dch.err_rx++;
./isdn/hardware/mISDN/w6692.c:365:			pr_debug("%s: D-channel CRC error\n", card->name);
./isdn/hardware/mISDN/w6692.c:367:			card->dch.err_crc++;
./isdn/hardware/mISDN/w6692.c:371:			pr_debug("%s: D-channel ABORT\n", card->name);
./isdn/hardware/mISDN/w6692.c:373:			card->dch.err_rx++;
./isdn/hardware/mISDN/w6692.c:376:		if (card->dch.rx_skb)
./isdn/hardware/mISDN/w6692.c:377:			dev_kfree_skb(card->dch.rx_skb);
./isdn/hardware/mISDN/w6692.c:378:		card->dch.rx_skb = NULL;
./isdn/hardware/mISDN/w6692.c:385:		recv_Dchannel(&card->dch);
./isdn/hardware/mISDN/w6692.c:391:	if (test_and_clear_bit(FLG_BUSY_TIMER, &card->dch.Flags))
./isdn/hardware/mISDN/w6692.c:392:		del_timer(&card->dch.timer);
./isdn/hardware/mISDN/w6692.c:393:	if (card->dch.tx_skb && card->dch.tx_idx < card->dch.tx_skb->len) {
./isdn/hardware/mISDN/w6692.c:396:		if (card->dch.tx_skb)
./isdn/hardware/mISDN/w6692.c:397:			dev_kfree_skb(card->dch.tx_skb);
./isdn/hardware/mISDN/w6692.c:398:		if (get_next_dframe(&card->dch))
./isdn/hardware/mISDN/w6692.c:406:	struct dchannel *dch = &card->dch;
./isdn/hardware/mISDN/w6692.c:411:	pr_debug("%s: D_EXIR %02x\n", card->name, exval);
./isdn/hardware/mISDN/w6692.c:414:		pr_debug("%s: D-channel underrun/collision\n", card->name);
./isdn/hardware/mISDN/w6692.c:421:		pr_debug("%s: D-channel RDOV\n", card->name);
./isdn/hardware/mISDN/w6692.c:425:		pr_debug("%s: spurious TIN2 interrupt\n", card->name);
./isdn/hardware/mISDN/w6692.c:429:			 card->name, v1);
./isdn/hardware/mISDN/w6692.c:433:		pr_debug("%s: ISC CIR %02X\n", card->name, cir);
./isdn/hardware/mISDN/w6692.c:436:			pr_debug("%s: ph_state_change %x -> %x\n", card->name,
./isdn/hardware/mISDN/w6692.c:438:			card->state = v1;
./isdn/hardware/mISDN/w6692.c:439:			if (card->fmask & led) {
./isdn/hardware/mISDN/w6692.c:454:			pr_debug("%s: SCC SQR %02X\n", card->name, v1);
./isdn/hardware/mISDN/w6692.c:458:		pr_debug("%s: spurious WEXP interrupt!\n", card->name);
./isdn/hardware/mISDN/w6692.c:460:		pr_debug("%s: spurious TEXP interrupt!\n", card->name);
./isdn/hardware/mISDN/w6692.c:470:	pr_debug("%s: empty_Bfifo %d\n", card->name, count);
./isdn/hardware/mISDN/w6692.c:472:		pr_debug("%s: empty_Bfifo ISDN_P_NONE\n", card->name);
./isdn/hardware/mISDN/w6692.c:489:			   card->name, wch->bch.nr, count);
./isdn/hardware/mISDN/w6692.c:496:		snprintf(card->log, 63, "B%1d-recv %s %d ",
./isdn/hardware/mISDN/w6692.c:497:			 wch->bch.nr, card->name, count);
./isdn/hardware/mISDN/w6692.c:498:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);
./isdn/hardware/mISDN/w6692.c:509:	pr_debug("%s: fill Bfifo\n", card->name);
./isdn/hardware/mISDN/w6692.c:527:	pr_debug("%s: fill Bfifo%d/%d\n", card->name,
./isdn/hardware/mISDN/w6692.c:540:		snprintf(card->log, 63, "B%1d-send %s %d ",
./isdn/hardware/mISDN/w6692.c:541:			 wch->bch.nr, card->name, count);
./isdn/hardware/mISDN/w6692.c:542:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);
./isdn/hardware/mISDN/w6692.c:554:	if ((!(card->fmask & pots)) ||
./isdn/hardware/mISDN/w6692.c:565:		card->xaddr &= 0xc7;
./isdn/hardware/mISDN/w6692.c:567:		card->xaddr &= 0xf8;
./isdn/hardware/mISDN/w6692.c:569:	card->xaddr |= val;
./isdn/hardware/mISDN/w6692.c:570:	WriteW6692(card, W_XADDR, card->xaddr);
./isdn/hardware/mISDN/w6692.c:579:	if ((!(card->fmask & pots)) ||
./isdn/hardware/mISDN/w6692.c:585:	card->pctl |= ((wch->bch.nr & 2) ? W_PCTL_PCX : 0);
./isdn/hardware/mISDN/w6692.c:586:	WriteW6692(card, W_PCTL, card->pctl);
./isdn/hardware/mISDN/w6692.c:596:	if (!(card->fmask & pots))
./isdn/hardware/mISDN/w6692.c:611:	pr_debug("%s: B%d protocol %x-->%x\n", card->name,
./isdn/hardware/mISDN/w6692.c:615:		if ((card->fmask & pots) && (wch->b_mode & W_B_MODE_EPCM))
./isdn/hardware/mISDN/w6692.c:643:		pr_info("%s: protocol %x not known\n", card->name, pr);
./isdn/hardware/mISDN/w6692.c:670:	struct w6692_ch	*wch = &card->bc[ch];
./isdn/hardware/mISDN/w6692.c:675:	pr_debug("%s: B%d EXIR %02x\n", card->name, wch->bch.nr, stat);
./isdn/hardware/mISDN/w6692.c:681:				pr_debug("%s: B%d RDOV proto=%x\n", card->name,
./isdn/hardware/mISDN/w6692.c:690:						 card->name, wch->bch.nr);
./isdn/hardware/mISDN/w6692.c:697:						 card->name, wch->bch.nr);
./isdn/hardware/mISDN/w6692.c:720:			pr_debug("%s: B%d RDOV proto=%x\n", card->name,
./isdn/hardware/mISDN/w6692.c:736:			pr_debug("%s: B%d RDOV IRQ proto=%x\n", card->name,
./isdn/hardware/mISDN/w6692.c:748:			pr_debug("%s: B%d star %02x\n", card->name,
./isdn/hardware/mISDN/w6692.c:752:			pr_warning("%s: B%d XDOW proto=%x\n", card->name,
./isdn/hardware/mISDN/w6692.c:770:		pr_warning("%s: B%d XDUN proto=%x\n", card->name,
./isdn/hardware/mISDN/w6692.c:792:	spin_lock(&card->lock);
./isdn/hardware/mISDN/w6692.c:794:	if ((ista | card->imask) == card->imask) {
./isdn/hardware/mISDN/w6692.c:796:		spin_unlock(&card->lock);
./isdn/hardware/mISDN/w6692.c:799:	card->irqcnt++;
./isdn/hardware/mISDN/w6692.c:800:	pr_debug("%s: ista %02x\n", card->name, ista);
./isdn/hardware/mISDN/w6692.c:801:	ista &= ~card->imask;
./isdn/hardware/mISDN/w6692.c:815:		pr_debug("%s: W6692 spurious XINT!\n", card->name);
./isdn/hardware/mISDN/w6692.c:817:	spin_unlock(&card->lock);
./isdn/hardware/mISDN/w6692.c:829:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:833:			 card->name, rbch, star);
./isdn/hardware/mISDN/w6692.c:843:					card->name);
./isdn/hardware/mISDN/w6692.c:847:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:855:	setup_timer(&card->dch.timer, (void *)dbusy_timer_handler,
./isdn/hardware/mISDN/w6692.c:856:		    (u_long)&card->dch);
./isdn/hardware/mISDN/w6692.c:857:	w6692_mode(&card->bc[0], ISDN_P_NONE);
./isdn/hardware/mISDN/w6692.c:858:	w6692_mode(&card->bc[1], ISDN_P_NONE);
./isdn/hardware/mISDN/w6692.c:864:	card->state = W_L1CMD_RST;
./isdn/hardware/mISDN/w6692.c:868:	card->imask = 0x18;
./isdn/hardware/mISDN/w6692.c:870:	WriteW6692B(&card->bc[0], W_B_EXIM, 0);
./isdn/hardware/mISDN/w6692.c:871:	WriteW6692B(&card->bc[1], W_B_EXIM, 0);
./isdn/hardware/mISDN/w6692.c:875:	WriteW6692B(&card->bc[0], W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);
./isdn/hardware/mISDN/w6692.c:876:	WriteW6692B(&card->bc[1], W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);
./isdn/hardware/mISDN/w6692.c:878:	if (card->subtype == W6692_USR) {
./isdn/hardware/mISDN/w6692.c:883:		card->pctl = 0x80;
./isdn/hardware/mISDN/w6692.c:884:		card->xdata = 0;
./isdn/hardware/mISDN/w6692.c:885:		WriteW6692(card, W_PCTL, card->pctl);
./isdn/hardware/mISDN/w6692.c:886:		WriteW6692(card, W_XDATA, card->xdata);
./isdn/hardware/mISDN/w6692.c:888:		card->pctl = W_PCTL_OE5 | W_PCTL_OE4 | W_PCTL_OE2 |
./isdn/hardware/mISDN/w6692.c:890:		card->xaddr = 0x00;/* all sw off */
./isdn/hardware/mISDN/w6692.c:891:		if (card->fmask & pots)
./isdn/hardware/mISDN/w6692.c:892:			card->xdata |= 0x06;	/*  POWER UP/ LED OFF / ALAW */
./isdn/hardware/mISDN/w6692.c:893:		if (card->fmask & led)
./isdn/hardware/mISDN/w6692.c:894:			card->xdata |= 0x04;	/* LED OFF */
./isdn/hardware/mISDN/w6692.c:895:		if ((card->fmask & pots) || (card->fmask & led)) {
./isdn/hardware/mISDN/w6692.c:896:			WriteW6692(card, W_PCTL, card->pctl);
./isdn/hardware/mISDN/w6692.c:897:			WriteW6692(card, W_XADDR, card->xaddr);
./isdn/hardware/mISDN/w6692.c:898:			WriteW6692(card, W_XDATA, card->xdata);
./isdn/hardware/mISDN/w6692.c:902:					  card->name, val);
./isdn/hardware/mISDN/w6692.c:921:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:923:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:924:	if (request_irq(card->irq, w6692_irq, IRQF_SHARED, card->name, card)) {
./isdn/hardware/mISDN/w6692.c:925:		pr_info("%s: couldn't get interrupt %d\n", card->name,
./isdn/hardware/mISDN/w6692.c:926:			card->irq);
./isdn/hardware/mISDN/w6692.c:930:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:933:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:937:			pr_notice("%s: IRQ %d count %d\n", card->name,
./isdn/hardware/mISDN/w6692.c:938:				  card->irq, card->irqcnt);
./isdn/hardware/mISDN/w6692.c:939:		if (!card->irqcnt) {
./isdn/hardware/mISDN/w6692.c:941:				card->name, card->irq, 3 - cnt);
./isdn/hardware/mISDN/w6692.c:946:	free_irq(card->irq, card);
./isdn/hardware/mISDN/w6692.c:962:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:968:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:971:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:976:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:982:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:985:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:992:			card->name, __func__, hh->prim, hh->id);
./isdn/hardware/mISDN/w6692.c:1015:	bch = &card->bc[rq->adr.channel - 1].bch;
./isdn/hardware/mISDN/w6692.c:1033:		ret = l1_event(card->dch.l1, HW_TIMER3_VALUE | (cq->p1 & 0xff));
./isdn/hardware/mISDN/w6692.c:1036:		pr_info("%s: unknown CTRL OP %x\n", card->name, cq->op);
./isdn/hardware/mISDN/w6692.c:1052:	pr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);
./isdn/hardware/mISDN/w6692.c:1057:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1060:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1071:			card->name, __func__, cmd);
./isdn/hardware/mISDN/w6692.c:1089:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1095:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1098:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1120:	pr_debug("%s: cmd(%x) state(%02x)\n", card->name, cmd, card->state);
./isdn/hardware/mISDN/w6692.c:1123:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1125:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1128:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1130:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1133:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1134:		if (card->state != W_L1IND_DRD)
./isdn/hardware/mISDN/w6692.c:1137:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1155:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1157:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1170:		pr_debug("%s: %s unknown command %x\n", card->name,
./isdn/hardware/mISDN/w6692.c:1180:	pr_debug("%s: %s dev(%d) open from %p\n", card->name, __func__,
./isdn/hardware/mISDN/w6692.c:1181:		 card->dch.dev.id, caller);
./isdn/hardware/mISDN/w6692.c:1187:	rq->ch = &card->dch.dev.D;
./isdn/hardware/mISDN/w6692.c:1189:	if (card->dch.state == 7)
./isdn/hardware/mISDN/w6692.c:1204:	pr_debug("%s: DCTRL: %x %p\n", card->name, cmd, arg);
./isdn/hardware/mISDN/w6692.c:1215:			pr_info("%s: cannot get module\n", card->name);
./isdn/hardware/mISDN/w6692.c:1218:		pr_debug("%s: dev(%d) close from %p\n", card->name,
./isdn/hardware/mISDN/w6692.c:1226:		pr_debug("%s: unknown DCTRL command %x\n", card->name, cmd);
./isdn/hardware/mISDN/w6692.c:1237:	if (!request_region(card->addr, 256, card->name)) {
./isdn/hardware/mISDN/w6692.c:1238:		pr_info("%s: config port %x-%x already in use\n", card->name,
./isdn/hardware/mISDN/w6692.c:1239:			card->addr, card->addr + 255);
./isdn/hardware/mISDN/w6692.c:1243:	card->bc[0].addr = card->addr;
./isdn/hardware/mISDN/w6692.c:1244:	card->bc[1].addr = card->addr + 0x40;
./isdn/hardware/mISDN/w6692.c:1247:		pr_notice("%s ISTA=%02x\n", card->name, val);
./isdn/hardware/mISDN/w6692.c:1250:		pr_notice("%s IMASK=%02x\n", card->name, val);
./isdn/hardware/mISDN/w6692.c:1253:		pr_notice("%s D_EXIR=%02x\n", card->name, val);
./isdn/hardware/mISDN/w6692.c:1256:		pr_notice("%s D_EXIM=%02x\n", card->name, val);
./isdn/hardware/mISDN/w6692.c:1259:		pr_notice("%s D_RSTA=%02x\n", card->name, val);
./isdn/hardware/mISDN/w6692.c:1268:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1270:	w6692_mode(&card->bc[0], ISDN_P_NONE);
./isdn/hardware/mISDN/w6692.c:1271:	w6692_mode(&card->bc[1], ISDN_P_NONE);
./isdn/hardware/mISDN/w6692.c:1272:	if ((card->fmask & led) || card->subtype == W6692_USR) {
./isdn/hardware/mISDN/w6692.c:1273:		card->xdata |= 0x04;	/*  LED OFF */
./isdn/hardware/mISDN/w6692.c:1274:		WriteW6692(card, W_XDATA, card->xdata);
./isdn/hardware/mISDN/w6692.c:1276:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/w6692.c:1277:	free_irq(card->irq, card);
./isdn/hardware/mISDN/w6692.c:1278:	l1_event(card->dch.l1, CLOSE_CHANNEL);
./isdn/hardware/mISDN/w6692.c:1279:	mISDN_unregister_device(&card->dch.dev);
./isdn/hardware/mISDN/w6692.c:1280:	release_region(card->addr, 256);
./isdn/hardware/mISDN/w6692.c:1281:	mISDN_freebchannel(&card->bc[1].bch);
./isdn/hardware/mISDN/w6692.c:1282:	mISDN_freebchannel(&card->bc[0].bch);
./isdn/hardware/mISDN/w6692.c:1283:	mISDN_freedchannel(&card->dch);
./isdn/hardware/mISDN/w6692.c:1285:	list_del(&card->list);
./isdn/hardware/mISDN/w6692.c:1287:	pci_disable_device(card->pdev);
./isdn/hardware/mISDN/w6692.c:1288:	pci_set_drvdata(card->pdev, NULL);
./isdn/hardware/mISDN/w6692.c:1298:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "w6692.%d", w6692_cnt + 1);
./isdn/hardware/mISDN/w6692.c:1300:	list_add_tail(&card->list, &Cards);
./isdn/hardware/mISDN/w6692.c:1302:	card->fmask = (1 << w6692_cnt);
./isdn/hardware/mISDN/w6692.c:1304:	spin_lock_init(&card->lock);
./isdn/hardware/mISDN/w6692.c:1305:	mISDN_initdchannel(&card->dch, MAX_DFRAME_LEN_L1, W6692_ph_bh);
./isdn/hardware/mISDN/w6692.c:1306:	card->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0);
./isdn/hardware/mISDN/w6692.c:1307:	card->dch.dev.D.send = w6692_l2l1D;
./isdn/hardware/mISDN/w6692.c:1308:	card->dch.dev.D.ctrl = w6692_dctrl;
./isdn/hardware/mISDN/w6692.c:1309:	card->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
./isdn/hardware/mISDN/w6692.c:1311:	card->dch.hw = card;
./isdn/hardware/mISDN/w6692.c:1312:	card->dch.dev.nrbchan = 2;
./isdn/hardware/mISDN/w6692.c:1314:		mISDN_initbchannel(&card->bc[i].bch, MAX_DATA_MEM,
./isdn/hardware/mISDN/w6692.c:1316:		card->bc[i].bch.hw = card;
./isdn/hardware/mISDN/w6692.c:1317:		card->bc[i].bch.nr = i + 1;
./isdn/hardware/mISDN/w6692.c:1318:		card->bc[i].bch.ch.nr = i + 1;
./isdn/hardware/mISDN/w6692.c:1319:		card->bc[i].bch.ch.send = w6692_l2l1B;
./isdn/hardware/mISDN/w6692.c:1320:		card->bc[i].bch.ch.ctrl = w6692_bctrl;
./isdn/hardware/mISDN/w6692.c:1321:		set_channelmap(i + 1, card->dch.dev.channelmap);
./isdn/hardware/mISDN/w6692.c:1322:		list_add(&card->bc[i].bch.ch.list, &card->dch.dev.bchannels);
./isdn/hardware/mISDN/w6692.c:1327:	err = mISDN_register_device(&card->dch.dev, &card->pdev->dev,
./isdn/hardware/mISDN/w6692.c:1328:				    card->name);
./isdn/hardware/mISDN/w6692.c:1334:	err = create_l1(&card->dch, w6692_l1callback);
./isdn/hardware/mISDN/w6692.c:1341:	free_irq(card->irq, card);
./isdn/hardware/mISDN/w6692.c:1343:	mISDN_unregister_device(&card->dch.dev);
./isdn/hardware/mISDN/w6692.c:1345:	release_region(card->addr, 256);
./isdn/hardware/mISDN/w6692.c:1347:	mISDN_freebchannel(&card->bc[1].bch);
./isdn/hardware/mISDN/w6692.c:1348:	mISDN_freebchannel(&card->bc[0].bch);
./isdn/hardware/mISDN/w6692.c:1349:	mISDN_freedchannel(&card->dch);
./isdn/hardware/mISDN/w6692.c:1351:	list_del(&card->list);
./isdn/hardware/mISDN/w6692.c:1369:	card->pdev = pdev;
./isdn/hardware/mISDN/w6692.c:1370:	card->subtype = m->subtype;
./isdn/hardware/mISDN/w6692.c:1380:	card->addr = pci_resource_start(pdev, 1);
./isdn/hardware/mISDN/w6692.c:1381:	card->irq = pdev->irq;
./isdn/hardware/mISDN/avmfritz.c:153:	card->isac.dch.debug = debug;
./isdn/hardware/mISDN/avmfritz.c:154:	card->bch[0].debug = debug;
./isdn/hardware/mISDN/avmfritz.c:155:	card->bch[1].debug = debug;
./isdn/hardware/mISDN/avmfritz.c:1018:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/avmfritz.c:1019:	modehdlc(&card->bch[0], ISDN_P_NONE);
./isdn/hardware/mISDN/avmfritz.c:1020:	modehdlc(&card->bch[1], ISDN_P_NONE);
./isdn/hardware/mISDN/avmfritz.c:1021:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/avmfritz.c:1022:	card->isac.release(&card->isac);
./isdn/hardware/mISDN/avmfritz.c:1023:	free_irq(card->irq, card);
./isdn/hardware/mISDN/avmfritz.c:1024:	mISDN_freebchannel(&card->bch[1]);
./isdn/hardware/mISDN/avmfritz.c:1025:	mISDN_freebchannel(&card->bch[0]);
./isdn/hardware/mISDN/avmfritz.c:1026:	mISDN_unregister_device(&card->isac.dch.dev);
./isdn/hardware/mISDN/avmfritz.c:1027:	release_region(card->addr, 32);
./isdn/hardware/mISDN/avmfritz.c:1028:	pci_disable_device(card->pdev);
./isdn/hardware/mISDN/avmfritz.c:1029:	pci_set_drvdata(card->pdev, NULL);
./isdn/hardware/mISDN/avmfritz.c:1031:	list_del(&card->list);
./isdn/hardware/mISDN/avmfritz.c:1044:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "AVM.%d", AVM_cnt + 1);
./isdn/hardware/mISDN/avmfritz.c:1046:	list_add_tail(&card->list, &Cards);
./isdn/hardware/mISDN/avmfritz.c:1050:	card->isac.name = card->name;
./isdn/hardware/mISDN/avmfritz.c:1051:	spin_lock_init(&card->lock);
./isdn/hardware/mISDN/avmfritz.c:1052:	card->isac.hwlock = &card->lock;
./isdn/hardware/mISDN/avmfritz.c:1053:	mISDNisac_init(&card->isac, card);
./isdn/hardware/mISDN/avmfritz.c:1055:	card->isac.dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
./isdn/hardware/mISDN/avmfritz.c:1057:	card->isac.dch.dev.D.ctrl = avm_dctrl;
./isdn/hardware/mISDN/avmfritz.c:1059:		card->bch[i].nr = i + 1;
./isdn/hardware/mISDN/avmfritz.c:1060:		set_channelmap(i + 1, card->isac.dch.dev.channelmap);
./isdn/hardware/mISDN/avmfritz.c:1061:		if (AVM_FRITZ_PCIV2 == card->type)
./isdn/hardware/mISDN/avmfritz.c:1065:		mISDN_initbchannel(&card->bch[i], MAX_DATA_MEM, minsize);
./isdn/hardware/mISDN/avmfritz.c:1066:		card->bch[i].hw = card;
./isdn/hardware/mISDN/avmfritz.c:1067:		card->bch[i].ch.send = avm_l2l1B;
./isdn/hardware/mISDN/avmfritz.c:1068:		card->bch[i].ch.ctrl = avm_bctrl;
./isdn/hardware/mISDN/avmfritz.c:1069:		card->bch[i].ch.nr = i + 1;
./isdn/hardware/mISDN/avmfritz.c:1070:		list_add(&card->bch[i].ch.list, &card->isac.dch.dev.bchannels);
./isdn/hardware/mISDN/avmfritz.c:1075:	err = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,
./isdn/hardware/mISDN/avmfritz.c:1076:				    card->name);
./isdn/hardware/mISDN/avmfritz.c:1085:	mISDN_unregister_device(&card->isac.dch.dev);
./isdn/hardware/mISDN/avmfritz.c:1087:	release_region(card->addr, 32);
./isdn/hardware/mISDN/avmfritz.c:1089:	card->isac.release(&card->isac);
./isdn/hardware/mISDN/avmfritz.c:1090:	mISDN_freebchannel(&card->bch[1]);
./isdn/hardware/mISDN/avmfritz.c:1091:	mISDN_freebchannel(&card->bch[0]);
./isdn/hardware/mISDN/avmfritz.c:1093:	list_del(&card->list);
./isdn/hardware/mISDN/avmfritz.c:1111:		card->type = AVM_FRITZ_PCIV2;
./isdn/hardware/mISDN/avmfritz.c:1113:		card->type = AVM_FRITZ_PCI;
./isdn/hardware/mISDN/avmfritz.c:1114:	card->pdev = pdev;
./isdn/hardware/mISDN/avmfritz.c:1124:	card->addr = pci_resource_start(pdev, 1);
./isdn/hardware/mISDN/avmfritz.c:1125:	card->irq = pdev->irq;
./isdn/hardware/mISDN/netjet.c:108:	card->isac.dch.debug = debug;
./isdn/hardware/mISDN/netjet.c:109:	card->bc[0].bch.debug = debug;
./isdn/hardware/mISDN/netjet.c:110:	card->bc[1].bch.debug = debug;
./isdn/hardware/mISDN/netjet.c:138:	outb(0, card->base + NJ_IRQMASK0);
./isdn/hardware/mISDN/netjet.c:139:	outb(0, card->base + NJ_IRQMASK1);
./isdn/hardware/mISDN/netjet.c:149:	card->auxd &= 0xfc;
./isdn/hardware/mISDN/netjet.c:150:	card->auxd |= (offset >> 4) & 3;
./isdn/hardware/mISDN/netjet.c:151:	outb(card->auxd, card->base + NJ_AUXDATA);
./isdn/hardware/mISDN/netjet.c:152:	ret = inb(card->base + NJ_ISAC_OFF + ((offset & 0x0f) << 2));
./isdn/hardware/mISDN/netjet.c:161:	card->auxd &= 0xfc;
./isdn/hardware/mISDN/netjet.c:162:	card->auxd |= (offset >> 4) & 3;
./isdn/hardware/mISDN/netjet.c:163:	outb(card->auxd, card->base + NJ_AUXDATA);
./isdn/hardware/mISDN/netjet.c:164:	outb(value, card->base + NJ_ISAC_OFF + ((offset & 0x0f) << 2));
./isdn/hardware/mISDN/netjet.c:172:	card->auxd &= 0xfc;
./isdn/hardware/mISDN/netjet.c:173:	outb(card->auxd, card->base + NJ_AUXDATA);
./isdn/hardware/mISDN/netjet.c:174:	insb(card->base + NJ_ISAC_OFF, data, size);
./isdn/hardware/mISDN/netjet.c:182:	card->auxd &= 0xfc;
./isdn/hardware/mISDN/netjet.c:183:	outb(card->auxd, card->base + NJ_AUXDATA);
./isdn/hardware/mISDN/netjet.c:184:	outsb(card->base + NJ_ISAC_OFF, data, size);
./isdn/hardware/mISDN/netjet.c:193:	pr_debug("%s: B%1d fill %02x len %d idx %d/%d\n", card->name,
./isdn/hardware/mISDN/netjet.c:194:		 bc->bch.nr, fill, cnt, idx, card->send.idx);
./isdn/hardware/mISDN/netjet.c:201:		val = card->send.start[idx];
./isdn/hardware/mISDN/netjet.c:204:		card->send.start[idx++] = val;
./isdn/hardware/mISDN/netjet.c:205:		if (idx >= card->send.size)
./isdn/hardware/mISDN/netjet.c:215:	pr_debug("%s: B%1d protocol %x-->%x\n", card->name,
./isdn/hardware/mISDN/netjet.c:221:		fill_mem(bc, 0, card->send.size, 0xff);
./isdn/hardware/mISDN/netjet.c:224:		if ((card->bc[0].bch.state == ISDN_P_NONE) &&
./isdn/hardware/mISDN/netjet.c:225:		    (card->bc[1].bch.state == ISDN_P_NONE)) {
./isdn/hardware/mISDN/netjet.c:226:			card->dmactrl = 0;
./isdn/hardware/mISDN/netjet.c:227:			outb(card->dmactrl, card->base + NJ_DMACTRL);
./isdn/hardware/mISDN/netjet.c:228:			outb(0, card->base + NJ_IRQMASK0);
./isdn/hardware/mISDN/netjet.c:240:		bc->free = card->send.size / 2;
./isdn/hardware/mISDN/netjet.c:244:		if (!card->dmactrl) {
./isdn/hardware/mISDN/netjet.c:245:			card->dmactrl = 1;
./isdn/hardware/mISDN/netjet.c:246:			outb(card->dmactrl, card->base + NJ_DMACTRL);
./isdn/hardware/mISDN/netjet.c:247:			outb(0x0f, card->base + NJ_IRQMASK0);
./isdn/hardware/mISDN/netjet.c:254:		bc->free = card->send.size / 2;
./isdn/hardware/mISDN/netjet.c:260:		if (!card->dmactrl) {
./isdn/hardware/mISDN/netjet.c:261:			card->dmactrl = 1;
./isdn/hardware/mISDN/netjet.c:262:			outb(card->dmactrl, card->base + NJ_DMACTRL);
./isdn/hardware/mISDN/netjet.c:263:			outb(0x0f, card->base + NJ_IRQMASK0);
./isdn/hardware/mISDN/netjet.c:267:		pr_info("%s: %s protocol %x not handled\n", card->name,
./isdn/hardware/mISDN/netjet.c:271:	card->send.dmacur = inl(card->base + NJ_DMA_READ_ADR);
./isdn/hardware/mISDN/netjet.c:272:	card->recv.dmacur = inl(card->base + NJ_DMA_WRITE_ADR);
./isdn/hardware/mISDN/netjet.c:273:	card->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;
./isdn/hardware/mISDN/netjet.c:274:	card->recv.idx = (card->recv.dmacur - card->recv.dmastart) >> 2;
./isdn/hardware/mISDN/netjet.c:276:		 card->name, __func__,
./isdn/hardware/mISDN/netjet.c:277:		 inb(card->base + NJ_DMACTRL),
./isdn/hardware/mISDN/netjet.c:278:		 inb(card->base + NJ_IRQMASK0),
./isdn/hardware/mISDN/netjet.c:279:		 inb(card->base + NJ_IRQSTAT0),
./isdn/hardware/mISDN/netjet.c:280:		 card->send.idx,
./isdn/hardware/mISDN/netjet.c:281:		 card->recv.idx);
./isdn/hardware/mISDN/netjet.c:288:	outb(0xff, card->base + NJ_CTRL); /* Reset On */
./isdn/hardware/mISDN/netjet.c:293:	if (card->typ == NETJET_S_TJ320) /* TJ320 */
./isdn/hardware/mISDN/netjet.c:294:		card->ctrlreg = 0x40;  /* Reset Off and status read clear */
./isdn/hardware/mISDN/netjet.c:296:		card->ctrlreg = 0x00;  /* Reset Off and status read clear */
./isdn/hardware/mISDN/netjet.c:297:	outb(card->ctrlreg, card->base + NJ_CTRL);
./isdn/hardware/mISDN/netjet.c:301:	card->auxd = 0;
./isdn/hardware/mISDN/netjet.c:302:	card->dmactrl = 0;
./isdn/hardware/mISDN/netjet.c:303:	outb(~NJ_ISACIRQ, card->base + NJ_AUXCTRL);
./isdn/hardware/mISDN/netjet.c:304:	outb(NJ_ISACIRQ,  card->base + NJ_IRQMASK1);
./isdn/hardware/mISDN/netjet.c:305:	outb(card->auxd, card->base + NJ_AUXDATA);
./isdn/hardware/mISDN/netjet.c:313:	card->dma_p = pci_alloc_consistent(card->pdev, NJ_DMA_SIZE,
./isdn/hardware/mISDN/netjet.c:314:					   &card->dma);
./isdn/hardware/mISDN/netjet.c:315:	if (!card->dma_p) {
./isdn/hardware/mISDN/netjet.c:316:		pr_info("%s: No DMA memory\n", card->name);
./isdn/hardware/mISDN/netjet.c:319:	if ((u64)card->dma > 0xffffffff) {
./isdn/hardware/mISDN/netjet.c:320:		pr_info("%s: DMA outside 32 bit\n", card->name);
./isdn/hardware/mISDN/netjet.c:324:		card->bc[i].hsbuf = kmalloc(NJ_DMA_TXSIZE, GFP_ATOMIC);
./isdn/hardware/mISDN/netjet.c:325:		if (!card->bc[i].hsbuf) {
./isdn/hardware/mISDN/netjet.c:326:			pr_info("%s: no B%d send buffer\n", card->name, i + 1);
./isdn/hardware/mISDN/netjet.c:329:		card->bc[i].hrbuf = kmalloc(NJ_DMA_RXSIZE, GFP_ATOMIC);
./isdn/hardware/mISDN/netjet.c:330:		if (!card->bc[i].hrbuf) {
./isdn/hardware/mISDN/netjet.c:331:			pr_info("%s: no B%d recv buffer\n", card->name, i + 1);
./isdn/hardware/mISDN/netjet.c:335:	memset(card->dma_p, 0xff, NJ_DMA_SIZE);
./isdn/hardware/mISDN/netjet.c:337:	card->send.start = card->dma_p;
./isdn/hardware/mISDN/netjet.c:338:	card->send.dmastart = (u32)card->dma;
./isdn/hardware/mISDN/netjet.c:339:	card->send.dmaend = card->send.dmastart +
./isdn/hardware/mISDN/netjet.c:341:	card->send.dmairq = card->send.dmastart +
./isdn/hardware/mISDN/netjet.c:343:	card->send.size = NJ_DMA_TXSIZE;
./isdn/hardware/mISDN/netjet.c:347:			  " size %zu u32\n", card->name,
./isdn/hardware/mISDN/netjet.c:348:			  card->send.dmastart, card->send.dmairq,
./isdn/hardware/mISDN/netjet.c:349:			  card->send.dmaend, card->send.start, card->send.size);
./isdn/hardware/mISDN/netjet.c:351:	outl(card->send.dmastart, card->base + NJ_DMA_READ_START);
./isdn/hardware/mISDN/netjet.c:352:	outl(card->send.dmairq, card->base + NJ_DMA_READ_IRQ);
./isdn/hardware/mISDN/netjet.c:353:	outl(card->send.dmaend, card->base + NJ_DMA_READ_END);
./isdn/hardware/mISDN/netjet.c:355:	card->recv.start = card->dma_p + (NJ_DMA_SIZE / 2);
./isdn/hardware/mISDN/netjet.c:356:	card->recv.dmastart = (u32)card->dma  + (NJ_DMA_SIZE / 2);
./isdn/hardware/mISDN/netjet.c:357:	card->recv.dmaend = card->recv.dmastart +
./isdn/hardware/mISDN/netjet.c:359:	card->recv.dmairq = card->recv.dmastart +
./isdn/hardware/mISDN/netjet.c:361:	card->recv.size = NJ_DMA_RXSIZE;
./isdn/hardware/mISDN/netjet.c:365:			  " size %zu u32\n", card->name,
./isdn/hardware/mISDN/netjet.c:366:			  card->recv.dmastart, card->recv.dmairq,
./isdn/hardware/mISDN/netjet.c:367:			  card->recv.dmaend, card->recv.start, card->recv.size);
./isdn/hardware/mISDN/netjet.c:369:	outl(card->recv.dmastart, card->base + NJ_DMA_WRITE_START);
./isdn/hardware/mISDN/netjet.c:370:	outl(card->recv.dmairq, card->base + NJ_DMA_WRITE_IRQ);
./isdn/hardware/mISDN/netjet.c:371:	outl(card->recv.dmaend, card->base + NJ_DMA_WRITE_END);
./isdn/hardware/mISDN/netjet.c:385:		pr_info("%s: B%1d overrun at idx %d\n", card->name,
./isdn/hardware/mISDN/netjet.c:397:			   card->name, bc->bch.nr, cnt);
./isdn/hardware/mISDN/netjet.c:406:		val = card->recv.start[idx++];
./isdn/hardware/mISDN/netjet.c:409:		if (idx >= card->recv.size)
./isdn/hardware/mISDN/netjet.c:426:				snprintf(card->log, LOG_SIZE,
./isdn/hardware/mISDN/netjet.c:428:					 card->name, stat);
./isdn/hardware/mISDN/netjet.c:429:				print_hex_dump_bytes(card->log,
./isdn/hardware/mISDN/netjet.c:437:					   card->name, bc->bch.nr, cnt);
./isdn/hardware/mISDN/netjet.c:442:				card->name, bc->bch.nr);
./isdn/hardware/mISDN/netjet.c:445:				card->name, bc->bch.nr);
./isdn/hardware/mISDN/netjet.c:448:				card->name, bc->bch.nr, bc->bch.maxlen);
./isdn/hardware/mISDN/netjet.c:459:	int cnt = card->recv.size / 2;
./isdn/hardware/mISDN/netjet.c:462:	card->last_is0 &= ~NJ_IRQM0_WR_MASK;
./isdn/hardware/mISDN/netjet.c:463:	card->last_is0 |= (irq_stat & NJ_IRQM0_WR_MASK);
./isdn/hardware/mISDN/netjet.c:468:		idx = card->recv.size - 1;
./isdn/hardware/mISDN/netjet.c:470:	if (test_bit(FLG_ACTIVE, &card->bc[0].bch.Flags))
./isdn/hardware/mISDN/netjet.c:471:		read_dma(&card->bc[0], idx, cnt);
./isdn/hardware/mISDN/netjet.c:472:	if (test_bit(FLG_ACTIVE, &card->bc[1].bch.Flags))
./isdn/hardware/mISDN/netjet.c:473:		read_dma(&card->bc[1], idx, cnt);
./isdn/hardware/mISDN/netjet.c:480:	card->send.dmacur = inl(card->base | NJ_DMA_READ_ADR);
./isdn/hardware/mISDN/netjet.c:481:	card->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;
./isdn/hardware/mISDN/netjet.c:482:	if (bc->free > card->send.size / 2)
./isdn/hardware/mISDN/netjet.c:483:		bc->free = card->send.size / 2;
./isdn/hardware/mISDN/netjet.c:488:	if (card->send.idx < ((card->send.size / 2) - 1))
./isdn/hardware/mISDN/netjet.c:489:		bc->idx = (card->recv.size / 2) - 1;
./isdn/hardware/mISDN/netjet.c:491:		bc->idx = card->recv.size - 1;
./isdn/hardware/mISDN/netjet.c:493:	pr_debug("%s: %s B%1d free %d idx %d/%d\n", card->name,
./isdn/hardware/mISDN/netjet.c:494:		 __func__, bc->bch.nr, bc->free, bc->idx, card->send.idx);
./isdn/hardware/mISDN/netjet.c:509:	pr_debug("%s: %s B%1d %d state %x idx %d/%d\n", card->name,
./isdn/hardware/mISDN/netjet.c:511:		 bc->idx, card->send.idx);
./isdn/hardware/mISDN/netjet.c:516:	pr_debug("%s: B%1d hdlc encoded %d flags\n", card->name,
./isdn/hardware/mISDN/netjet.c:522:		if (bc->idx >= card->send.size)
./isdn/hardware/mISDN/netjet.c:524:		v = card->send.start[bc->idx];
./isdn/hardware/mISDN/netjet.c:527:		card->send.start[bc->idx++] = v;
./isdn/hardware/mISDN/netjet.c:530:		snprintf(card->log, LOG_SIZE, "B%1d-send %s %d ",
./isdn/hardware/mISDN/netjet.c:531:			 bc->bch.nr, card->name, count);
./isdn/hardware/mISDN/netjet.c:532:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, p, count);
./isdn/hardware/mISDN/netjet.c:550:		count = card->send.size >> 1;
./isdn/hardware/mISDN/netjet.c:557:			 card->name, __func__, bc->bch.nr, count, bc->free,
./isdn/hardware/mISDN/netjet.c:559:			 bc->idx, card->send.idx);
./isdn/hardware/mISDN/netjet.c:567:		pr_debug("%s: B%1d hdlc encoded %d in %d\n", card->name,
./isdn/hardware/mISDN/netjet.c:585:			if (bc->idx >= card->send.size)
./isdn/hardware/mISDN/netjet.c:587:			v = card->send.start[bc->idx];
./isdn/hardware/mISDN/netjet.c:590:			card->send.start[bc->idx++] = v;
./isdn/hardware/mISDN/netjet.c:594:			if (bc->idx >= card->send.size)
./isdn/hardware/mISDN/netjet.c:596:			v = card->send.start[bc->idx];
./isdn/hardware/mISDN/netjet.c:600:			card->send.start[bc->idx++] = v;
./isdn/hardware/mISDN/netjet.c:604:		snprintf(card->log, LOG_SIZE, "B%1d-send %s %d ",
./isdn/hardware/mISDN/netjet.c:605:			 bc->bch.nr, card->name, count);
./isdn/hardware/mISDN/netjet.c:606:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, p, count);
./isdn/hardware/mISDN/netjet.c:643:	bc->free += card->send.size / 2;
./isdn/hardware/mISDN/netjet.c:644:	if (bc->free >= card->send.size) {
./isdn/hardware/mISDN/netjet.c:646:			pr_info("%s: B%1d TX underrun state %x\n", card->name,
./isdn/hardware/mISDN/netjet.c:650:		bc->free = card->send.size;
./isdn/hardware/mISDN/netjet.c:658:		pr_debug("%s: B%1d TX no data free %d idx %d/%d\n", card->name,
./isdn/hardware/mISDN/netjet.c:659:			 bc->bch.nr, bc->free, bc->idx, card->send.idx);
./isdn/hardware/mISDN/netjet.c:662:			if (bc->free == card->send.size)
./isdn/hardware/mISDN/netjet.c:674:	if ((irq_stat & card->last_is0) & NJ_IRQM0_RD_MASK) {
./isdn/hardware/mISDN/netjet.c:676:			card->name, irq_stat, card->last_is0);
./isdn/hardware/mISDN/netjet.c:679:		card->last_is0 &= ~NJ_IRQM0_RD_MASK;
./isdn/hardware/mISDN/netjet.c:680:		card->last_is0 |= (irq_stat & NJ_IRQM0_RD_MASK);
./isdn/hardware/mISDN/netjet.c:683:		if (test_bit(FLG_ACTIVE, &card->bc[i].bch.Flags))
./isdn/hardware/mISDN/netjet.c:684:			send_tiger_bc(card, &card->bc[i]);
./isdn/hardware/mISDN/netjet.c:694:	spin_lock(&card->lock);
./isdn/hardware/mISDN/netjet.c:695:	s0val = inb(card->base | NJ_IRQSTAT0);
./isdn/hardware/mISDN/netjet.c:696:	s1val = inb(card->base | NJ_IRQSTAT1);
./isdn/hardware/mISDN/netjet.c:699:		spin_unlock(&card->lock);
./isdn/hardware/mISDN/netjet.c:702:	pr_debug("%s: IRQSTAT0 %02x IRQSTAT1 %02x\n", card->name, s0val, s1val);
./isdn/hardware/mISDN/netjet.c:703:	card->irqcnt++;
./isdn/hardware/mISDN/netjet.c:707:			mISDNisac_irq(&card->isac, val);
./isdn/hardware/mISDN/netjet.c:712:		outb(s0val, card->base | NJ_IRQSTAT0);
./isdn/hardware/mISDN/netjet.c:717:	card->recv.dmacur = inl(card->base | NJ_DMA_WRITE_ADR);
./isdn/hardware/mISDN/netjet.c:718:	card->recv.idx = (card->recv.dmacur - card->recv.dmastart) >> 2;
./isdn/hardware/mISDN/netjet.c:719:	if (card->recv.dmacur < card->recv.dmairq)
./isdn/hardware/mISDN/netjet.c:724:	card->send.dmacur = inl(card->base | NJ_DMA_READ_ADR);
./isdn/hardware/mISDN/netjet.c:725:	card->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;
./isdn/hardware/mISDN/netjet.c:726:	if (card->send.dmacur < card->send.dmairq)
./isdn/hardware/mISDN/netjet.c:731:	pr_debug("%s: DMA Status %02x/%02x/%02x %d/%d\n", card->name,
./isdn/hardware/mISDN/netjet.c:732:		 s1val, s0val, card->last_is0,
./isdn/hardware/mISDN/netjet.c:733:		 card->recv.idx, card->send.idx);
./isdn/hardware/mISDN/netjet.c:735:	if (s0val != card->last_is0) {
./isdn/hardware/mISDN/netjet.c:737:		    (card->last_is0 & NJ_IRQM0_RD_MASK))
./isdn/hardware/mISDN/netjet.c:741:		    (card->last_is0 & NJ_IRQM0_WR_MASK))
./isdn/hardware/mISDN/netjet.c:746:	spin_unlock(&card->lock);
./isdn/hardware/mISDN/netjet.c:762:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:768:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:771:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:776:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:782:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:785:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:811:	pr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);
./isdn/hardware/mISDN/netjet.c:816:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:819:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:829:		pr_info("%s: %s unknown prim(%x)\n", card->name, __func__, cmd);
./isdn/hardware/mISDN/netjet.c:849:		ret = card->isac.ctrl(&card->isac, HW_TESTLOOP, cq->channel);
./isdn/hardware/mISDN/netjet.c:852:		ret = card->isac.ctrl(&card->isac, HW_TIMER3_VALUE, cq->p1);
./isdn/hardware/mISDN/netjet.c:855:		pr_info("%s: %s unknown Op %x\n", card->name, __func__, cq->op);
./isdn/hardware/mISDN/netjet.c:871:	bch = &card->bc[rq->adr.channel - 1].bch;
./isdn/hardware/mISDN/netjet.c:892:	pr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);
./isdn/hardware/mISDN/netjet.c:897:			err = card->isac.open(&card->isac, rq);
./isdn/hardware/mISDN/netjet.c:903:			pr_info("%s: cannot get module\n", card->name);
./isdn/hardware/mISDN/netjet.c:906:		pr_debug("%s: dev(%d) close from %p\n", card->name, dch->dev.id,
./isdn/hardware/mISDN/netjet.c:915:			 card->name, __func__, cmd);
./isdn/hardware/mISDN/netjet.c:927:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:929:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:931:	card->irq = card->pdev->irq;
./isdn/hardware/mISDN/netjet.c:932:	if (request_irq(card->irq, nj_irq, IRQF_SHARED, card->name, card)) {
./isdn/hardware/mISDN/netjet.c:934:			card->name, card->irq);
./isdn/hardware/mISDN/netjet.c:935:		card->irq = -1;
./isdn/hardware/mISDN/netjet.c:939:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:941:	ret = card->isac.init(&card->isac);
./isdn/hardware/mISDN/netjet.c:947:	mode_tiger(&card->bc[0], ISDN_P_NONE);
./isdn/hardware/mISDN/netjet.c:948:	mode_tiger(&card->bc[1], ISDN_P_NONE);
./isdn/hardware/mISDN/netjet.c:950:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:961:	if (card->base_s) {
./isdn/hardware/mISDN/netjet.c:962:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:964:		mode_tiger(&card->bc[0], ISDN_P_NONE);
./isdn/hardware/mISDN/netjet.c:965:		mode_tiger(&card->bc[1], ISDN_P_NONE);
./isdn/hardware/mISDN/netjet.c:966:		card->isac.release(&card->isac);
./isdn/hardware/mISDN/netjet.c:967:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/netjet.c:968:		release_region(card->base, card->base_s);
./isdn/hardware/mISDN/netjet.c:969:		card->base_s = 0;
./isdn/hardware/mISDN/netjet.c:971:	if (card->irq > 0)
./isdn/hardware/mISDN/netjet.c:972:		free_irq(card->irq, card);
./isdn/hardware/mISDN/netjet.c:973:	if (card->isac.dch.dev.dev.class)
./isdn/hardware/mISDN/netjet.c:974:		mISDN_unregister_device(&card->isac.dch.dev);
./isdn/hardware/mISDN/netjet.c:977:		mISDN_freebchannel(&card->bc[i].bch);
./isdn/hardware/mISDN/netjet.c:978:		kfree(card->bc[i].hsbuf);
./isdn/hardware/mISDN/netjet.c:979:		kfree(card->bc[i].hrbuf);
./isdn/hardware/mISDN/netjet.c:981:	if (card->dma_p)
./isdn/hardware/mISDN/netjet.c:982:		pci_free_consistent(card->pdev, NJ_DMA_SIZE,
./isdn/hardware/mISDN/netjet.c:983:				    card->dma_p, card->dma);
./isdn/hardware/mISDN/netjet.c:985:	list_del(&card->list);
./isdn/hardware/mISDN/netjet.c:987:	pci_clear_master(card->pdev);
./isdn/hardware/mISDN/netjet.c:988:	pci_disable_device(card->pdev);
./isdn/hardware/mISDN/netjet.c:989:	pci_set_drvdata(card->pdev, NULL);
./isdn/hardware/mISDN/netjet.c:997:	card->base = pci_resource_start(card->pdev, 0);
./isdn/hardware/mISDN/netjet.c:998:	card->base_s = pci_resource_len(card->pdev, 0);
./isdn/hardware/mISDN/netjet.c:999:	if (!request_region(card->base, card->base_s, card->name)) {
./isdn/hardware/mISDN/netjet.c:1001:			card->name, card->base,
./isdn/hardware/mISDN/netjet.c:1002:			(u32)(card->base + card->base_s - 1));
./isdn/hardware/mISDN/netjet.c:1003:		card->base_s = 0;
./isdn/hardware/mISDN/netjet.c:1006:	ASSIGN_FUNC(nj, ISAC, card->isac);
./isdn/hardware/mISDN/netjet.c:1017:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "netjet.%d", nj_cnt + 1);
./isdn/hardware/mISDN/netjet.c:1019:	list_add_tail(&card->list, &Cards);
./isdn/hardware/mISDN/netjet.c:1023:	card->isac.name = card->name;
./isdn/hardware/mISDN/netjet.c:1024:	spin_lock_init(&card->lock);
./isdn/hardware/mISDN/netjet.c:1025:	card->isac.hwlock = &card->lock;
./isdn/hardware/mISDN/netjet.c:1026:	mISDNisac_init(&card->isac, card);
./isdn/hardware/mISDN/netjet.c:1028:	card->isac.dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
./isdn/hardware/mISDN/netjet.c:1030:	card->isac.dch.dev.D.ctrl = nj_dctrl;
./isdn/hardware/mISDN/netjet.c:1032:		card->bc[i].bch.nr = i + 1;
./isdn/hardware/mISDN/netjet.c:1033:		set_channelmap(i + 1, card->isac.dch.dev.channelmap);
./isdn/hardware/mISDN/netjet.c:1034:		mISDN_initbchannel(&card->bc[i].bch, MAX_DATA_MEM,
./isdn/hardware/mISDN/netjet.c:1036:		card->bc[i].bch.hw = card;
./isdn/hardware/mISDN/netjet.c:1037:		card->bc[i].bch.ch.send = nj_l2l1B;
./isdn/hardware/mISDN/netjet.c:1038:		card->bc[i].bch.ch.ctrl = nj_bctrl;
./isdn/hardware/mISDN/netjet.c:1039:		card->bc[i].bch.ch.nr = i + 1;
./isdn/hardware/mISDN/netjet.c:1040:		list_add(&card->bc[i].bch.ch.list,
./isdn/hardware/mISDN/netjet.c:1041:			 &card->isac.dch.dev.bchannels);
./isdn/hardware/mISDN/netjet.c:1042:		card->bc[i].bch.hw = card;
./isdn/hardware/mISDN/netjet.c:1047:	err = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,
./isdn/hardware/mISDN/netjet.c:1048:				    card->name);
./isdn/hardware/mISDN/netjet.c:1093:	card->pdev = pdev;
./isdn/hardware/mISDN/netjet.c:1112:		card->typ = NETJET_S_TJ320;
./isdn/hardware/mISDN/netjet.c:1114:		card->typ = NETJET_S_TJ300;
./isdn/hardware/mISDN/netjet.c:1116:	card->base = pci_resource_start(pdev, 0);
./isdn/hardware/mISDN/netjet.c:1117:	card->irq = pdev->irq;
./isdn/hardware/mISDN/mISDNinfineon.c:241:	card->ipac.isac.dch.debug = debug;
./isdn/hardware/mISDN/mISDNinfineon.c:242:	card->ipac.hscx[0].bch.debug = debug;
./isdn/hardware/mISDN/mISDNinfineon.c:243:	card->ipac.hscx[1].bch.debug = debug;
./isdn/hardware/mISDN/mISDNinfineon.c:869:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/mISDNinfineon.c:871:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/mISDNinfineon.c:872:	card->ipac.isac.release(&card->ipac.isac);
./isdn/hardware/mISDN/mISDNinfineon.c:873:	free_irq(card->irq, card);
./isdn/hardware/mISDN/mISDNinfineon.c:874:	mISDN_unregister_device(&card->ipac.isac.dch.dev);
./isdn/hardware/mISDN/mISDNinfineon.c:877:	list_del(&card->list);
./isdn/hardware/mISDN/mISDNinfineon.c:879:	switch (card->ci->typ) {
./isdn/hardware/mISDN/mISDNinfineon.c:886:			if (card->sc[i])
./isdn/hardware/mISDN/mISDNinfineon.c:887:				release_card(card->sc[i]);
./isdn/hardware/mISDN/mISDNinfineon.c:888:			card->sc[i] = NULL;
./isdn/hardware/mISDN/mISDNinfineon.c:891:		pci_disable_device(card->pdev);
./isdn/hardware/mISDN/mISDNinfineon.c:892:		pci_set_drvdata(card->pdev, NULL);
./isdn/hardware/mISDN/mISDNinfineon.c:905:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "%s.%d", card->ci->name,
./isdn/hardware/mISDN/mISDNinfineon.c:908:	list_add_tail(&card->list, &Cards);
./isdn/hardware/mISDN/mISDNinfineon.c:912:	card->ipac.isac.name = card->name;
./isdn/hardware/mISDN/mISDNinfineon.c:913:	card->ipac.name = card->name;
./isdn/hardware/mISDN/mISDNinfineon.c:914:	card->ipac.owner = THIS_MODULE;
./isdn/hardware/mISDN/mISDNinfineon.c:915:	spin_lock_init(&card->lock);
./isdn/hardware/mISDN/mISDNinfineon.c:916:	card->ipac.isac.hwlock = &card->lock;
./isdn/hardware/mISDN/mISDNinfineon.c:917:	card->ipac.hwlock = &card->lock;
./isdn/hardware/mISDN/mISDNinfineon.c:918:	card->ipac.ctrl = (void *)&inf_ctrl;
./isdn/hardware/mISDN/mISDNinfineon.c:924:	card->ipac.isac.dch.dev.Bprotocols =
./isdn/hardware/mISDN/mISDNinfineon.c:925:		mISDNipac_init(&card->ipac, card);
./isdn/hardware/mISDN/mISDNinfineon.c:927:	if (card->ipac.isac.dch.dev.Bprotocols == 0)
./isdn/hardware/mISDN/mISDNinfineon.c:930:	err = mISDN_register_device(&card->ipac.isac.dch.dev,
./isdn/hardware/mISDN/mISDNinfineon.c:931:				    &card->pdev->dev, card->name);
./isdn/hardware/mISDN/mISDNinfineon.c:941:	mISDN_unregister_device(&card->ipac.isac.dch.dev);
./isdn/hardware/mISDN/mISDNinfineon.c:943:	card->ipac.release(&card->ipac);
./isdn/hardware/mISDN/mISDNinfineon.c:947:	list_del(&card->list);
./isdn/hardware/mISDN/mISDNinfineon.c:1087:	card->pdev = pdev;
./isdn/hardware/mISDN/mISDNinfineon.c:1093:	card->ci = get_card_info(ent->driver_data);
./isdn/hardware/mISDN/mISDNinfineon.c:1094:	if (!card->ci) {
./isdn/hardware/mISDN/mISDNinfineon.c:1102:			  card->ci->full, pci_name(pdev));
./isdn/hardware/mISDN/mISDNinfineon.c:1104:	card->irq = pdev->irq;
./isdn/hardware/mISDN/mISDNinfineon.c:1122:			sc->irq = card->irq;
./isdn/hardware/mISDN/mISDNinfineon.c:1123:			sc->pdev = card->pdev;
./isdn/hardware/mISDN/mISDNinfineon.c:1124:			sc->ci = card->ci + i;
./isdn/hardware/mISDN/mISDNinfineon.c:1132:				card->sc[i - 1] = sc;
./isdn/hardware/mISDN/speedfax.c:91:	card->isac.dch.debug = debug;
./isdn/hardware/mISDN/speedfax.c:92:	card->isar.ch[0].bch.debug = debug;
./isdn/hardware/mISDN/speedfax.c:93:	card->isar.ch[1].bch.debug = debug;
./isdn/hardware/mISDN/speedfax.c:357:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/mISDN/speedfax.c:359:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/mISDN/speedfax.c:360:	card->isac.release(&card->isac);
./isdn/hardware/mISDN/speedfax.c:361:	free_irq(card->irq, card);
./isdn/hardware/mISDN/speedfax.c:362:	card->isar.release(&card->isar);
./isdn/hardware/mISDN/speedfax.c:363:	mISDN_unregister_device(&card->isac.dch.dev);
./isdn/hardware/mISDN/speedfax.c:364:	release_region(card->cfg, 256);
./isdn/hardware/mISDN/speedfax.c:365:	pci_disable_device(card->pdev);
./isdn/hardware/mISDN/speedfax.c:366:	pci_set_drvdata(card->pdev, NULL);
./isdn/hardware/mISDN/speedfax.c:368:	list_del(&card->list);
./isdn/hardware/mISDN/speedfax.c:381:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "Speedfax.%d", sfax_cnt + 1);
./isdn/hardware/mISDN/speedfax.c:383:	list_add_tail(&card->list, &Cards);
./isdn/hardware/mISDN/speedfax.c:386:	spin_lock_init(&card->lock);
./isdn/hardware/mISDN/speedfax.c:387:	card->isac.hwlock = &card->lock;
./isdn/hardware/mISDN/speedfax.c:388:	card->isar.hwlock = &card->lock;
./isdn/hardware/mISDN/speedfax.c:389:	card->isar.ctrl = (void *)&sfax_ctrl;
./isdn/hardware/mISDN/speedfax.c:390:	card->isac.name = card->name;
./isdn/hardware/mISDN/speedfax.c:391:	card->isar.name = card->name;
./isdn/hardware/mISDN/speedfax.c:392:	card->isar.owner = THIS_MODULE;
./isdn/hardware/mISDN/speedfax.c:394:	err = request_firmware(&firmware, "isdn/ISAR.BIN", &card->pdev->dev);
./isdn/hardware/mISDN/speedfax.c:397:			card->name, err);
./isdn/hardware/mISDN/speedfax.c:402:			  card->name, firmware->size);
./isdn/hardware/mISDN/speedfax.c:404:	mISDNisac_init(&card->isac, card);
./isdn/hardware/mISDN/speedfax.c:406:	card->isac.dch.dev.D.ctrl = sfax_dctrl;
./isdn/hardware/mISDN/speedfax.c:407:	card->isac.dch.dev.Bprotocols =
./isdn/hardware/mISDN/speedfax.c:408:		mISDNisar_init(&card->isar, card);
./isdn/hardware/mISDN/speedfax.c:410:		set_channelmap(i + 1, card->isac.dch.dev.channelmap);
./isdn/hardware/mISDN/speedfax.c:411:		list_add(&card->isar.ch[i].bch.ch.list,
./isdn/hardware/mISDN/speedfax.c:412:			 &card->isac.dch.dev.bchannels);
./isdn/hardware/mISDN/speedfax.c:418:	err = card->isar.init(&card->isar);
./isdn/hardware/mISDN/speedfax.c:421:	err = mISDN_register_device(&card->isac.dch.dev,
./isdn/hardware/mISDN/speedfax.c:422:				    &card->pdev->dev, card->name);
./isdn/hardware/mISDN/speedfax.c:428:	err = card->isar.firmware(&card->isar, firmware->data, firmware->size);
./isdn/hardware/mISDN/speedfax.c:436:	free_irq(card->irq, card);
./isdn/hardware/mISDN/speedfax.c:438:	mISDN_unregister_device(&card->isac.dch.dev);
./isdn/hardware/mISDN/speedfax.c:440:	release_region(card->cfg, 256);
./isdn/hardware/mISDN/speedfax.c:442:	card->isac.release(&card->isac);
./isdn/hardware/mISDN/speedfax.c:443:	card->isar.release(&card->isar);
./isdn/hardware/mISDN/speedfax.c:446:	pci_disable_device(card->pdev);
./isdn/hardware/mISDN/speedfax.c:448:	list_del(&card->list);
./isdn/hardware/mISDN/speedfax.c:464:	card->pdev = pdev;
./isdn/hardware/mISDN/speedfax.c:474:	card->cfg = pci_resource_start(pdev, 0);
./isdn/hardware/mISDN/speedfax.c:475:	card->irq = pdev->irq;
./isdn/hardware/mISDN/hfcpci.c:2086:	card->dch.debug = debug;
./isdn/hardware/mISDN/hfcpci.c:2087:	spin_lock_init(&card->lock);
./isdn/hardware/mISDN/hfcpci.c:2088:	mISDN_initdchannel(&card->dch, MAX_DFRAME_LEN_L1, ph_state);
./isdn/hardware/mISDN/hfcpci.c:2089:	card->dch.hw = card;
./isdn/hardware/mISDN/hfcpci.c:2090:	card->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);
./isdn/hardware/mISDN/hfcpci.c:2091:	card->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
./isdn/hardware/mISDN/hfcpci.c:2093:	card->dch.dev.D.send = hfcpci_l2l1D;
./isdn/hardware/mISDN/hfcpci.c:2094:	card->dch.dev.D.ctrl = hfc_dctrl;
./isdn/hardware/mISDN/hfcpci.c:2095:	card->dch.dev.nrbchan = 2;
./isdn/hardware/mISDN/hfcpci.c:2097:		card->bch[i].nr = i + 1;
./isdn/hardware/mISDN/hfcpci.c:2098:		set_channelmap(i + 1, card->dch.dev.channelmap);
./isdn/hardware/mISDN/hfcpci.c:2099:		card->bch[i].debug = debug;
./isdn/hardware/mISDN/hfcpci.c:2100:		mISDN_initbchannel(&card->bch[i], MAX_DATA_MEM, poll >> 1);
./isdn/hardware/mISDN/hfcpci.c:2101:		card->bch[i].hw = card;
./isdn/hardware/mISDN/hfcpci.c:2102:		card->bch[i].ch.send = hfcpci_l2l1B;
./isdn/hardware/mISDN/hfcpci.c:2103:		card->bch[i].ch.ctrl = hfc_bctrl;
./isdn/hardware/mISDN/hfcpci.c:2104:		card->bch[i].ch.nr = i + 1;
./isdn/hardware/mISDN/hfcpci.c:2105:		list_add(&card->bch[i].ch.list, &card->dch.dev.bchannels);
./isdn/hardware/mISDN/hfcpci.c:2111:	err = mISDN_register_device(&card->dch.dev, &card->pdev->dev, name);
./isdn/hardware/mISDN/hfcpci.c:2118:	mISDN_freebchannel(&card->bch[1]);
./isdn/hardware/mISDN/hfcpci.c:2119:	mISDN_freebchannel(&card->bch[0]);
./isdn/hardware/mISDN/hfcpci.c:2120:	mISDN_freedchannel(&card->dch);
./isdn/hardware/mISDN/hfcpci.c:2227:	card->pdev = pdev;
./isdn/hardware/mISDN/hfcpci.c:2228:	card->subtype = m->subtype;
./isdn/hardware/mISDN/hfcpci.c:2238:	card->irq = pdev->irq;
./isdn/hardware/avm/b1pci.c:55:		cinfo->card ? cinfo->card->port : 0x0,
./isdn/hardware/avm/b1pci.c:56:		cinfo->card ? cinfo->card->irq : 0,
./isdn/hardware/avm/b1pci.c:57:		cinfo->card ? cinfo->card->revision : 0
./isdn/hardware/avm/b1pci.c:77:	cinfo = card->ctrlinfo;
./isdn/hardware/avm/b1pci.c:78:	sprintf(card->name, "b1pci-%x", p->port);
./isdn/hardware/avm/b1pci.c:79:	card->port = p->port;
./isdn/hardware/avm/b1pci.c:80:	card->irq = p->irq;
./isdn/hardware/avm/b1pci.c:81:	card->cardtype = avm_b1pci;
./isdn/hardware/avm/b1pci.c:83:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./isdn/hardware/avm/b1pci.c:85:		       card->port, card->port + AVMB1_PORTLEN);
./isdn/hardware/avm/b1pci.c:89:	b1_reset(card->port);
./isdn/hardware/avm/b1pci.c:90:	retval = b1_detect(card->port, card->cardtype);
./isdn/hardware/avm/b1pci.c:93:		       card->port, retval);
./isdn/hardware/avm/b1pci.c:97:	b1_reset(card->port);
./isdn/hardware/avm/b1pci.c:100:	retval = request_irq(card->irq, b1_interrupt, IRQF_SHARED, card->name, card);
./isdn/hardware/avm/b1pci.c:102:		printk(KERN_ERR "b1pci: unable to get IRQ %d.\n", card->irq);
./isdn/hardware/avm/b1pci.c:116:	strcpy(cinfo->capi_ctrl.name, card->name);
./isdn/hardware/avm/b1pci.c:125:	if (card->revision >= 4) {
./isdn/hardware/avm/b1pci.c:127:		       card->port, card->irq, card->revision);
./isdn/hardware/avm/b1pci.c:130:		       card->port, card->irq, card->revision);
./isdn/hardware/avm/b1pci.c:137:	free_irq(card->irq, card);
./isdn/hardware/avm/b1pci.c:139:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/b1pci.c:149:	avmctrl_info *cinfo = card->ctrlinfo;
./isdn/hardware/avm/b1pci.c:150:	unsigned int port = card->port;
./isdn/hardware/avm/b1pci.c:156:	free_irq(card->irq, card);
./isdn/hardware/avm/b1pci.c:157:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/b1pci.c:173:		cinfo->card ? cinfo->card->port : 0x0,
./isdn/hardware/avm/b1pci.c:174:		cinfo->card ? cinfo->card->irq : 0,
./isdn/hardware/avm/b1pci.c:175:		cinfo->card ? cinfo->card->membase : 0,
./isdn/hardware/avm/b1pci.c:176:		cinfo->card ? cinfo->card->revision : 0
./isdn/hardware/avm/b1pci.c:196:	card->dma = avmcard_dma_alloc("b1pci", pdev, 2048 + 128, 2048 + 128);
./isdn/hardware/avm/b1pci.c:197:	if (!card->dma) {
./isdn/hardware/avm/b1pci.c:203:	cinfo = card->ctrlinfo;
./isdn/hardware/avm/b1pci.c:204:	sprintf(card->name, "b1pciv4-%x", p->port);
./isdn/hardware/avm/b1pci.c:205:	card->port = p->port;
./isdn/hardware/avm/b1pci.c:206:	card->irq = p->irq;
./isdn/hardware/avm/b1pci.c:207:	card->membase = p->membase;
./isdn/hardware/avm/b1pci.c:208:	card->cardtype = avm_b1pci;
./isdn/hardware/avm/b1pci.c:210:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./isdn/hardware/avm/b1pci.c:212:		       card->port, card->port + AVMB1_PORTLEN);
./isdn/hardware/avm/b1pci.c:217:	card->mbase = ioremap(card->membase, 64);
./isdn/hardware/avm/b1pci.c:218:	if (!card->mbase) {
./isdn/hardware/avm/b1pci.c:220:		       card->membase);
./isdn/hardware/avm/b1pci.c:230:		       card->port, retval);
./isdn/hardware/avm/b1pci.c:237:	retval = request_irq(card->irq, b1dma_interrupt, IRQF_SHARED, card->name, card);
./isdn/hardware/avm/b1pci.c:240:		       card->irq);
./isdn/hardware/avm/b1pci.c:255:	strcpy(cinfo->capi_ctrl.name, card->name);
./isdn/hardware/avm/b1pci.c:262:	card->cardnr = cinfo->capi_ctrl.cnr;
./isdn/hardware/avm/b1pci.c:265:	       card->port, card->irq, card->membase, card->revision);
./isdn/hardware/avm/b1pci.c:271:	free_irq(card->irq, card);
./isdn/hardware/avm/b1pci.c:273:	iounmap(card->mbase);
./isdn/hardware/avm/b1pci.c:275:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/b1pci.c:277:	avmcard_dma_free(card->dma);
./isdn/hardware/avm/b1pci.c:288:	avmctrl_info *cinfo = card->ctrlinfo;
./isdn/hardware/avm/b1pci.c:293:	free_irq(card->irq, card);
./isdn/hardware/avm/b1pci.c:294:	iounmap(card->mbase);
./isdn/hardware/avm/b1pci.c:295:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/b1pci.c:296:	avmcard_dma_free(card->dma);
./isdn/hardware/avm/b1pci.c:352:	if (card->dma)
./isdn/hardware/avm/b1dma.c:88:	writel(value, card->mbase + off);
./isdn/hardware/avm/b1dma.c:93:	return readl(card->mbase + off);
./isdn/hardware/avm/b1dma.c:113:		while (!b1dma_tx_empty(card->port)
./isdn/hardware/avm/b1dma.c:115:		if (!b1dma_tx_empty(card->port))
./isdn/hardware/avm/b1dma.c:117:		t1outp(card->port, 0x01, *s++);
./isdn/hardware/avm/b1dma.c:127:		while (!b1dma_rx_full(card->port)
./isdn/hardware/avm/b1dma.c:129:		if (!b1dma_rx_full(card->port))
./isdn/hardware/avm/b1dma.c:131:		*s++ = t1inp(card->port, 0x00);
./isdn/hardware/avm/b1dma.c:220:	card->csr = 0x0;
./isdn/hardware/avm/b1dma.c:221:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./isdn/hardware/avm/b1dma.c:226:	t1outp(card->port, 0x10, 0x00);
./isdn/hardware/avm/b1dma.c:227:	t1outp(card->port, 0x07, 0x00);
./isdn/hardware/avm/b1dma.c:234:	if (card->cardtype == avm_t1pci)
./isdn/hardware/avm/b1dma.c:253:	card->csr = 0x0;
./isdn/hardware/avm/b1dma.c:254:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./isdn/hardware/avm/b1dma.c:271:	t1outp(card->port, 0x10, 0x00);
./isdn/hardware/avm/b1dma.c:272:	t1outp(card->port, 0x07, 0x00);
./isdn/hardware/avm/b1dma.c:274:	t1outp(card->port, 0x02, 0x02);
./isdn/hardware/avm/b1dma.c:275:	t1outp(card->port, 0x03, 0x02);
./isdn/hardware/avm/b1dma.c:277:	if ((t1inp(card->port, 0x02) & 0xFE) != 0x02
./isdn/hardware/avm/b1dma.c:278:	    || t1inp(card->port, 0x3) != 0x03)
./isdn/hardware/avm/b1dma.c:281:	t1outp(card->port, 0x02, 0x00);
./isdn/hardware/avm/b1dma.c:282:	t1outp(card->port, 0x03, 0x00);
./isdn/hardware/avm/b1dma.c:284:	if ((t1inp(card->port, 0x02) & 0xFE) != 0x00
./isdn/hardware/avm/b1dma.c:285:	    || t1inp(card->port, 0x3) != 0x01)
./isdn/hardware/avm/b1dma.c:354:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:356:	skb_queue_tail(&card->dma->send_queue, skb);
./isdn/hardware/avm/b1dma.c:358:	if (!(card->csr & EN_TX_TC_INT)) {
./isdn/hardware/avm/b1dma.c:360:		b1dma_writel(card, card->csr, AMCC_INTCSR);
./isdn/hardware/avm/b1dma.c:363:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:370:	avmcard_dmainfo *dma = card->dma;
./isdn/hardware/avm/b1dma.c:404:			printk(KERN_INFO "%s: send ack\n", card->name);
./isdn/hardware/avm/b1dma.c:418:	card->csr |= EN_TX_TC_INT;
./isdn/hardware/avm/b1dma.c:433:		       card->name);
./isdn/hardware/avm/b1dma.c:449:	avmctrl_info *cinfo = &card->ctrlinfo[0];
./isdn/hardware/avm/b1dma.c:450:	avmcard_dmainfo *dma = card->dma;
./isdn/hardware/avm/b1dma.c:465:		MsgLen = _get_slice(&p, card->msgbuf);
./isdn/hardware/avm/b1dma.c:466:		DataB3Len = _get_slice(&p, card->databuf);
./isdn/hardware/avm/b1dma.c:469:			memset(card->msgbuf + MsgLen, 0, 30 - MsgLen);
./isdn/hardware/avm/b1dma.c:471:			CAPIMSG_SETLEN(card->msgbuf, 30);
./isdn/hardware/avm/b1dma.c:475:			       card->name);
./isdn/hardware/avm/b1dma.c:477:			skb_put_data(skb, card->msgbuf, MsgLen);
./isdn/hardware/avm/b1dma.c:478:			skb_put_data(skb, card->databuf, DataB3Len);
./isdn/hardware/avm/b1dma.c:486:		MsgLen = _get_slice(&p, card->msgbuf);
./isdn/hardware/avm/b1dma.c:489:			       card->name);
./isdn/hardware/avm/b1dma.c:491:			skb_put_data(skb, card->msgbuf, MsgLen);
./isdn/hardware/avm/b1dma.c:493:				spin_lock(&card->lock);
./isdn/hardware/avm/b1dma.c:497:				spin_unlock(&card->lock);
./isdn/hardware/avm/b1dma.c:508:		spin_lock(&card->lock);
./isdn/hardware/avm/b1dma.c:510:		spin_unlock(&card->lock);
./isdn/hardware/avm/b1dma.c:519:			spin_lock(&card->lock);
./isdn/hardware/avm/b1dma.c:521:			spin_unlock(&card->lock);
./isdn/hardware/avm/b1dma.c:527:		printk(KERN_INFO "%s: receive poll\n", card->name);
./isdn/hardware/avm/b1dma.c:543:		       card->name,
./isdn/hardware/avm/b1dma.c:551:		MsgLen = _get_slice(&p, card->msgbuf);
./isdn/hardware/avm/b1dma.c:552:		card->msgbuf[MsgLen] = 0;
./isdn/hardware/avm/b1dma.c:554:		       && (card->msgbuf[MsgLen - 1] == '\n'
./isdn/hardware/avm/b1dma.c:555:			   || card->msgbuf[MsgLen - 1] == '\r')) {
./isdn/hardware/avm/b1dma.c:556:			card->msgbuf[MsgLen - 1] = 0;
./isdn/hardware/avm/b1dma.c:560:		       card->name, ApplId, card->msgbuf);
./isdn/hardware/avm/b1dma.c:564:		MsgLen = _get_slice(&p, card->msgbuf);
./isdn/hardware/avm/b1dma.c:565:		card->msgbuf[MsgLen] = 0;
./isdn/hardware/avm/b1dma.c:567:		       && (card->msgbuf[MsgLen - 1] == '\n'
./isdn/hardware/avm/b1dma.c:568:			   || card->msgbuf[MsgLen - 1] == '\r')) {
./isdn/hardware/avm/b1dma.c:569:			card->msgbuf[MsgLen - 1] = 0;
./isdn/hardware/avm/b1dma.c:572:		printk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);
./isdn/hardware/avm/b1dma.c:577:		       card->name, b1cmd);
./isdn/hardware/avm/b1dma.c:589:	spin_lock(&card->lock);
./isdn/hardware/avm/b1dma.c:593:		spin_unlock(&card->lock);
./isdn/hardware/avm/b1dma.c:597:	newcsr = card->csr | (status & ALL_INT);
./isdn/hardware/avm/b1dma.c:603:		struct avmcard_dmainfo *dma = card->dma;
./isdn/hardware/avm/b1dma.c:605:		if (card->dma->recvlen == 0) {
./isdn/hardware/avm/b1dma.c:615:				       card->name, rxlen);
./isdn/hardware/avm/b1dma.c:619:			spin_unlock(&card->lock);
./isdn/hardware/avm/b1dma.c:622:			spin_lock(&card->lock);
./isdn/hardware/avm/b1dma.c:629:		if (skb_queue_empty(&card->dma->send_queue))
./isdn/hardware/avm/b1dma.c:630:			card->csr &= ~EN_TX_TC_INT;
./isdn/hardware/avm/b1dma.c:634:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./isdn/hardware/avm/b1dma.c:636:	spin_unlock(&card->lock);
./isdn/hardware/avm/b1dma.c:654:	unsigned int base = card->port;
./isdn/hardware/avm/b1dma.c:662:		       card->name);
./isdn/hardware/avm/b1dma.c:671:			printk(KERN_ERR "%s: b1dma_loaded: got 0x%x, firmware not running in dword mode\n", card->name, ans);
./isdn/hardware/avm/b1dma.c:675:	printk(KERN_ERR "%s: b1dma_loaded: firmware not running\n", card->name);
./isdn/hardware/avm/b1dma.c:689:		       card->name);
./isdn/hardware/avm/b1dma.c:698:	_put_word(&p, card->cardnr - 1);
./isdn/hardware/avm/b1dma.c:715:		       card->name);
./isdn/hardware/avm/b1dma.c:723:			       card->name);
./isdn/hardware/avm/b1dma.c:730:		printk(KERN_ERR "%s: failed to load t4file.\n", card->name);
./isdn/hardware/avm/b1dma.c:734:	card->csr = AVM_FLAG;
./isdn/hardware/avm/b1dma.c:735:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./isdn/hardware/avm/b1dma.c:739:	t1outp(card->port, 0x07, 0x30);
./isdn/hardware/avm/b1dma.c:740:	t1outp(card->port, 0x10, 0xF0);
./isdn/hardware/avm/b1dma.c:742:	card->dma->recvlen = 0;
./isdn/hardware/avm/b1dma.c:743:	b1dma_writel(card, card->dma->recvbuf.dmaaddr, AMCC_RXPTR);
./isdn/hardware/avm/b1dma.c:745:	card->csr |= EN_RX_TC_INT;
./isdn/hardware/avm/b1dma.c:746:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./isdn/hardware/avm/b1dma.c:759:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:764:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:788:		       card->name);
./isdn/hardware/avm/b1dma.c:815:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:817:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:822:		       card->name);
./isdn/hardware/avm/b1dma.c:846:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:851:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:871:	seq_printf(m, "%-16s %s\n", "name", card->name);
./isdn/hardware/avm/b1dma.c:872:	seq_printf(m, "%-16s 0x%x\n", "io", card->port);
./isdn/hardware/avm/b1dma.c:873:	seq_printf(m, "%-16s %d\n", "irq", card->irq);
./isdn/hardware/avm/b1dma.c:874:	seq_printf(m, "%-16s 0x%lx\n", "membase", card->membase);
./isdn/hardware/avm/b1dma.c:875:	switch (card->cardtype) {
./isdn/hardware/avm/b1dma.c:895:	if (card->cardtype != avm_m1) {
./isdn/hardware/avm/b1dma.c:909:	if (card->cardtype != avm_m1) {
./isdn/hardware/avm/b1dma.c:923:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:925:	txoff = (dma_addr_t)b1dma_readl(card, AMCC_TXPTR)-card->dma->sendbuf.dmaaddr;
./isdn/hardware/avm/b1dma.c:928:	rxoff = (dma_addr_t)b1dma_readl(card, AMCC_RXPTR)-card->dma->recvbuf.dmaaddr;
./isdn/hardware/avm/b1dma.c:933:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1dma.c:935:	seq_printf(m, "%-16s 0x%lx\n", "csr (cached)", (unsigned long)card->csr);
./isdn/hardware/avm/c4.c:151:	while (c4inmeml(card->mbase + DOORBELL) != 0xffffffff) {
./isdn/hardware/avm/c4.c:165:	c4outmeml(card->mbase + MBOX_PEEK_POKE, off);
./isdn/hardware/avm/c4.c:166:	c4outmeml(card->mbase + DOORBELL, DBELL_ADDR);
./isdn/hardware/avm/c4.c:171:	c4outmeml(card->mbase + MBOX_PEEK_POKE, value);
./isdn/hardware/avm/c4.c:172:	c4outmeml(card->mbase + DOORBELL, DBELL_DATA | DBELL_ADDR);
./isdn/hardware/avm/c4.c:182:	c4outmeml(card->mbase + MBOX_PEEK_POKE, off);
./isdn/hardware/avm/c4.c:183:	c4outmeml(card->mbase + DOORBELL, DBELL_RNWR | DBELL_ADDR);
./isdn/hardware/avm/c4.c:188:	*valuep = c4inmeml(card->mbase + MBOX_PEEK_POKE);
./isdn/hardware/avm/c4.c:213:			       card->name);
./isdn/hardware/avm/c4.c:230:			       card->name);
./isdn/hardware/avm/c4.c:300:	c4outmeml(card->mbase + DOORBELL, DBELL_RESET_ARM);
./isdn/hardware/avm/c4.c:303:	while (c4inmeml(card->mbase + DOORBELL) != 0xffffffff) {
./isdn/hardware/avm/c4.c:306:		c4outmeml(card->mbase + DOORBELL, DBELL_ADDR);
./isdn/hardware/avm/c4.c:320:	c4outmeml(card->mbase + PCI_OUT_INT_MASK, 0x0c);
./isdn/hardware/avm/c4.c:321:	if (c4inmeml(card->mbase + PCI_OUT_INT_MASK) != 0x0c)
./isdn/hardware/avm/c4.c:324:	c4outmeml(card->mbase + DOORBELL, DBELL_RESET_ARM);
./isdn/hardware/avm/c4.c:327:	while (c4inmeml(card->mbase + DOORBELL) != 0xffffffff) {
./isdn/hardware/avm/c4.c:330:		c4outmeml(card->mbase + DOORBELL, DBELL_ADDR);
./isdn/hardware/avm/c4.c:337:	c4outmeml(card->mbase + MAILBOX_0, 0x55aa55aa);
./isdn/hardware/avm/c4.c:338:	if (c4inmeml(card->mbase + MAILBOX_0) != 0x55aa55aa) return 3;
./isdn/hardware/avm/c4.c:340:	c4outmeml(card->mbase + MAILBOX_0, 0xaa55aa55);
./isdn/hardware/avm/c4.c:341:	if (c4inmeml(card->mbase + MAILBOX_0) != 0xaa55aa55) return 4;
./isdn/hardware/avm/c4.c:412:	avmcard_dmainfo *dma = card->dma;
./isdn/hardware/avm/c4.c:420:	if (card->csr & DBELL_DOWN_ARM) { /* tx busy */
./isdn/hardware/avm/c4.c:427:		printk(KERN_DEBUG "%s: tx underrun\n", card->name);
./isdn/hardware/avm/c4.c:451:		printk(KERN_DEBUG "%s: tx put msg len=%d\n", card->name, txlen);
./isdn/hardware/avm/c4.c:457:			printk(KERN_INFO "%s: ack to c4\n", card->name);
./isdn/hardware/avm/c4.c:461:		       card->name, skb->data[2], txlen);
./isdn/hardware/avm/c4.c:468:	c4outmeml(card->mbase + MBOX_DOWN_ADDR, dma->sendbuf.dmaaddr);
./isdn/hardware/avm/c4.c:469:	c4outmeml(card->mbase + MBOX_DOWN_LEN, txlen);
./isdn/hardware/avm/c4.c:471:	card->csr |= DBELL_DOWN_ARM;
./isdn/hardware/avm/c4.c:473:	c4outmeml(card->mbase + DOORBELL, DBELL_DOWN_ARM);
./isdn/hardware/avm/c4.c:488:		       card->name);
./isdn/hardware/avm/c4.c:497:	skb_queue_tail(&card->dma->send_queue, skb);
./isdn/hardware/avm/c4.c:505:	avmcard_dmainfo *dma = card->dma;
./isdn/hardware/avm/c4.c:516:	printk(KERN_DEBUG "%s: rx 0x%x len=%lu\n", card->name,
./isdn/hardware/avm/c4.c:524:		MsgLen = _get_slice(&p, card->msgbuf);
./isdn/hardware/avm/c4.c:525:		DataB3Len = _get_slice(&p, card->databuf);
./isdn/hardware/avm/c4.c:526:		cidx = CAPIMSG_CONTROLLER(card->msgbuf)-card->cardnr;
./isdn/hardware/avm/c4.c:527:		if (cidx >= card->nlogcontr) cidx = 0;
./isdn/hardware/avm/c4.c:528:		ctrl = &card->ctrlinfo[cidx].capi_ctrl;
./isdn/hardware/avm/c4.c:531:			memset(card->msgbuf + MsgLen, 0, 30 - MsgLen);
./isdn/hardware/avm/c4.c:533:			CAPIMSG_SETLEN(card->msgbuf, 30);
./isdn/hardware/avm/c4.c:537:			       card->name);
./isdn/hardware/avm/c4.c:539:			skb_put_data(skb, card->msgbuf, MsgLen);
./isdn/hardware/avm/c4.c:540:			skb_put_data(skb, card->databuf, DataB3Len);
./isdn/hardware/avm/c4.c:548:		MsgLen = _get_slice(&p, card->msgbuf);
./isdn/hardware/avm/c4.c:549:		cidx = CAPIMSG_CONTROLLER(card->msgbuf)-card->cardnr;
./isdn/hardware/avm/c4.c:550:		if (cidx >= card->nlogcontr) cidx = 0;
./isdn/hardware/avm/c4.c:551:		cinfo = &card->ctrlinfo[cidx];
./isdn/hardware/avm/c4.c:552:		ctrl = &card->ctrlinfo[cidx].capi_ctrl;
./isdn/hardware/avm/c4.c:556:			       card->name);
./isdn/hardware/avm/c4.c:558:			skb_put_data(skb, card->msgbuf, MsgLen);
./isdn/hardware/avm/c4.c:573:		cidx = (NCCI & 0x7f) - card->cardnr;
./isdn/hardware/avm/c4.c:574:		if (cidx >= card->nlogcontr) cidx = 0;
./isdn/hardware/avm/c4.c:576:		capilib_new_ncci(&card->ctrlinfo[cidx].ncci_head, ApplId, NCCI, WindowSize);
./isdn/hardware/avm/c4.c:586:			cidx = (NCCI & 0x7f) - card->cardnr;
./isdn/hardware/avm/c4.c:587:			if (cidx >= card->nlogcontr) cidx = 0;
./isdn/hardware/avm/c4.c:588:			capilib_free_ncci(&card->ctrlinfo[cidx].ncci_head, ApplId, NCCI);
./isdn/hardware/avm/c4.c:594:		printk(KERN_INFO "%s: poll from c4\n", card->name);
./isdn/hardware/avm/c4.c:598:		for (cidx = 0; cidx < card->nr_controllers; cidx++) {
./isdn/hardware/avm/c4.c:599:			ctrl = &card->ctrlinfo[cidx].capi_ctrl;
./isdn/hardware/avm/c4.c:605:		for (cidx = 0; cidx < card->nr_controllers; cidx++) {
./isdn/hardware/avm/c4.c:606:			ctrl = &card->ctrlinfo[cidx].capi_ctrl;
./isdn/hardware/avm/c4.c:613:		cidx = card->nlogcontr;
./isdn/hardware/avm/c4.c:614:		if (cidx >= card->nr_controllers) {
./isdn/hardware/avm/c4.c:616:			       card->name, cidx + 1);
./isdn/hardware/avm/c4.c:619:		card->nlogcontr++;
./isdn/hardware/avm/c4.c:620:		cinfo = &card->ctrlinfo[cidx];
./isdn/hardware/avm/c4.c:625:		       card->name,
./isdn/hardware/avm/c4.c:633:		MsgLen = _get_slice(&p, card->msgbuf);
./isdn/hardware/avm/c4.c:634:		card->msgbuf[MsgLen] = 0;
./isdn/hardware/avm/c4.c:636:		       && (card->msgbuf[MsgLen - 1] == '\n'
./isdn/hardware/avm/c4.c:637:			   || card->msgbuf[MsgLen - 1] == '\r')) {
./isdn/hardware/avm/c4.c:638:			card->msgbuf[MsgLen - 1] = 0;
./isdn/hardware/avm/c4.c:642:		       card->name, ApplId, card->msgbuf);
./isdn/hardware/avm/c4.c:646:		MsgLen = _get_slice(&p, card->msgbuf);
./isdn/hardware/avm/c4.c:647:		card->msgbuf[MsgLen] = 0;
./isdn/hardware/avm/c4.c:649:		       && (card->msgbuf[MsgLen - 1] == '\n'
./isdn/hardware/avm/c4.c:650:			   || card->msgbuf[MsgLen - 1] == '\r')) {
./isdn/hardware/avm/c4.c:651:			card->msgbuf[MsgLen - 1] = 0;
./isdn/hardware/avm/c4.c:654:		printk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);
./isdn/hardware/avm/c4.c:659:		       card->name, b1cmd);
./isdn/hardware/avm/c4.c:671:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:672:	status = c4inmeml(card->mbase + DOORBELL);
./isdn/hardware/avm/c4.c:676:		c4outmeml(card->mbase + PCI_OUT_INT_MASK, 0x0c);
./isdn/hardware/avm/c4.c:677:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:678:		if (card->nlogcontr == 0)
./isdn/hardware/avm/c4.c:680:		printk(KERN_ERR "%s: unexpected reset\n", card->name);
./isdn/hardware/avm/c4.c:681:		for (i = 0; i < card->nr_controllers; i++) {
./isdn/hardware/avm/c4.c:682:			avmctrl_info *cinfo = &card->ctrlinfo[i];
./isdn/hardware/avm/c4.c:684:			spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:686:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:689:		card->nlogcontr = 0;
./isdn/hardware/avm/c4.c:695:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:698:	c4outmeml(card->mbase + DOORBELL, status);
./isdn/hardware/avm/c4.c:701:		card->dma->recvlen = c4inmeml(card->mbase + MBOX_UP_LEN);
./isdn/hardware/avm/c4.c:702:		c4outmeml(card->mbase + MBOX_UP_LEN, 0);
./isdn/hardware/avm/c4.c:704:		card->dma->recvlen = 0;
./isdn/hardware/avm/c4.c:705:		c4outmeml(card->mbase + MBOX_UP_LEN, card->dma->recvbuf.size);
./isdn/hardware/avm/c4.c:706:		c4outmeml(card->mbase + DOORBELL, DBELL_UP_ARM);
./isdn/hardware/avm/c4.c:710:		card->csr &= ~DBELL_DOWN_ARM;
./isdn/hardware/avm/c4.c:712:	} else if (card->csr & DBELL_DOWN_HOST) {
./isdn/hardware/avm/c4.c:713:		if (c4inmeml(card->mbase + MBOX_DOWN_LEN) == 0) {
./isdn/hardware/avm/c4.c:714:			card->csr &= ~DBELL_DOWN_ARM;
./isdn/hardware/avm/c4.c:718:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:740:		       card->name);
./isdn/hardware/avm/c4.c:749:	_put_word(&p, card->cardnr - 1);
./isdn/hardware/avm/c4.c:752:	skb_queue_tail(&card->dma->send_queue, skb);
./isdn/hardware/avm/c4.c:753:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:755:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:767:		       card->name);
./isdn/hardware/avm/c4.c:777:	skb_queue_tail(&card->dma->send_queue, skb);
./isdn/hardware/avm/c4.c:778:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:780:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:793:		       card->name);
./isdn/hardware/avm/c4.c:806:	skb_queue_tail(&card->dma->send_queue, skb);
./isdn/hardware/avm/c4.c:808:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:810:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:863:		       card->name);
./isdn/hardware/avm/c4.c:868:	card->csr = 0;
./isdn/hardware/avm/c4.c:869:	c4outmeml(card->mbase + MBOX_UP_LEN, 0);
./isdn/hardware/avm/c4.c:870:	c4outmeml(card->mbase + MBOX_DOWN_LEN, 0);
./isdn/hardware/avm/c4.c:871:	c4outmeml(card->mbase + DOORBELL, DBELL_INIT);
./isdn/hardware/avm/c4.c:873:	c4outmeml(card->mbase + DOORBELL,
./isdn/hardware/avm/c4.c:876:	c4outmeml(card->mbase + PCI_OUT_INT_MASK, 0x08);
./isdn/hardware/avm/c4.c:878:	card->dma->recvlen = 0;
./isdn/hardware/avm/c4.c:879:	c4outmeml(card->mbase + MBOX_UP_ADDR, card->dma->recvbuf.dmaaddr);
./isdn/hardware/avm/c4.c:880:	c4outmeml(card->mbase + MBOX_UP_LEN, card->dma->recvbuf.size);
./isdn/hardware/avm/c4.c:881:	c4outmeml(card->mbase + DOORBELL, DBELL_UP_ARM);
./isdn/hardware/avm/c4.c:887:			       card->name);
./isdn/hardware/avm/c4.c:906:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:910:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:912:	for (i = 0; i < card->nr_controllers; i++) {
./isdn/hardware/avm/c4.c:913:		cinfo = &card->ctrlinfo[i];
./isdn/hardware/avm/c4.c:917:	card->nlogcontr = 0;
./isdn/hardware/avm/c4.c:931:	for (i = 0; i < card->nr_controllers; i++) {
./isdn/hardware/avm/c4.c:932:		cinfo = &card->ctrlinfo[i];
./isdn/hardware/avm/c4.c:936:	free_irq(card->irq, card);
./isdn/hardware/avm/c4.c:937:	iounmap(card->mbase);
./isdn/hardware/avm/c4.c:938:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/c4.c:939:	avmcard_dma_free(card->dma);
./isdn/hardware/avm/c4.c:959:	if (ctrl->cnr == card->cardnr) {
./isdn/hardware/avm/c4.c:968:			       card->name);
./isdn/hardware/avm/c4.c:982:		skb_queue_tail(&card->dma->send_queue, skb);
./isdn/hardware/avm/c4.c:984:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:986:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:1000:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:1002:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:1004:	if (ctrl->cnr == card->cardnr) {
./isdn/hardware/avm/c4.c:1008:			       card->name);
./isdn/hardware/avm/c4.c:1018:		skb_queue_tail(&card->dma->send_queue, skb);
./isdn/hardware/avm/c4.c:1019:		spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:1021:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:1035:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/c4.c:1043:		skb_queue_tail(&card->dma->send_queue, skb);
./isdn/hardware/avm/c4.c:1046:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/c4.c:1061:		cinfo->card ? cinfo->card->port : 0x0,
./isdn/hardware/avm/c4.c:1062:		cinfo->card ? cinfo->card->irq : 0,
./isdn/hardware/avm/c4.c:1063:		cinfo->card ? cinfo->card->membase : 0
./isdn/hardware/avm/c4.c:1076:	seq_printf(m, "%-16s %s\n", "name", card->name);
./isdn/hardware/avm/c4.c:1077:	seq_printf(m, "%-16s 0x%x\n", "io", card->port);
./isdn/hardware/avm/c4.c:1078:	seq_printf(m, "%-16s %d\n", "irq", card->irq);
./isdn/hardware/avm/c4.c:1079:	seq_printf(m, "%-16s 0x%lx\n", "membase", card->membase);
./isdn/hardware/avm/c4.c:1080:	switch (card->cardtype) {
./isdn/hardware/avm/c4.c:1100:	if (card->cardtype != avm_m1) {
./isdn/hardware/avm/c4.c:1114:	if (card->cardtype != avm_m1) {
./isdn/hardware/avm/c4.c:1159:	card->dma = avmcard_dma_alloc("c4", dev, 2048 + 128, 2048 + 128);
./isdn/hardware/avm/c4.c:1160:	if (!card->dma) {
./isdn/hardware/avm/c4.c:1166:	sprintf(card->name, "c%d-%x", nr_controllers, p->port);
./isdn/hardware/avm/c4.c:1167:	card->port = p->port;
./isdn/hardware/avm/c4.c:1168:	card->irq = p->irq;
./isdn/hardware/avm/c4.c:1169:	card->membase = p->membase;
./isdn/hardware/avm/c4.c:1170:	card->cardtype = (nr_controllers == 4) ? avm_c4 : avm_c2;
./isdn/hardware/avm/c4.c:1172:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./isdn/hardware/avm/c4.c:1174:		       card->port, card->port + AVMB1_PORTLEN);
./isdn/hardware/avm/c4.c:1179:	card->mbase = ioremap(card->membase, 128);
./isdn/hardware/avm/c4.c:1180:	if (card->mbase == NULL) {
./isdn/hardware/avm/c4.c:1182:		       card->membase);
./isdn/hardware/avm/c4.c:1190:		       card->port, retval);
./isdn/hardware/avm/c4.c:1196:	retval = request_irq(card->irq, c4_interrupt, IRQF_SHARED, card->name, card);
./isdn/hardware/avm/c4.c:1198:		printk(KERN_ERR "c4: unable to get IRQ %d.\n", card->irq);
./isdn/hardware/avm/c4.c:1204:		cinfo = &card->ctrlinfo[i];
./isdn/hardware/avm/c4.c:1215:		strcpy(cinfo->capi_ctrl.name, card->name);
./isdn/hardware/avm/c4.c:1221:				cinfo = &card->ctrlinfo[i];
./isdn/hardware/avm/c4.c:1227:			card->cardnr = cinfo->capi_ctrl.cnr;
./isdn/hardware/avm/c4.c:1231:	       nr_controllers, card->port, card->irq,
./isdn/hardware/avm/c4.c:1232:	       card->membase);
./isdn/hardware/avm/c4.c:1237:	free_irq(card->irq, card);
./isdn/hardware/avm/c4.c:1239:	iounmap(card->mbase);
./isdn/hardware/avm/c4.c:1241:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/c4.c:1243:	avmcard_dma_free(card->dma);
./isdn/hardware/avm/t1isa.c:138:	avmctrl_info *cinfo = &card->ctrlinfo[0];
./isdn/hardware/avm/t1isa.c:150:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:152:	while (b1_rx_full(card->port)) {
./isdn/hardware/avm/t1isa.c:154:		b1cmd = b1_get_byte(card->port);
./isdn/hardware/avm/t1isa.c:160:			ApplId = (unsigned) b1_get_word(card->port);
./isdn/hardware/avm/t1isa.c:161:			MsgLen = t1_get_slice(card->port, card->msgbuf);
./isdn/hardware/avm/t1isa.c:162:			DataB3Len = t1_get_slice(card->port, card->databuf);
./isdn/hardware/avm/t1isa.c:163:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:166:				memset(card->msgbuf + MsgLen, 0, 30 - MsgLen);
./isdn/hardware/avm/t1isa.c:168:				CAPIMSG_SETLEN(card->msgbuf, 30);
./isdn/hardware/avm/t1isa.c:172:				       card->name);
./isdn/hardware/avm/t1isa.c:174:				skb_put_data(skb, card->msgbuf, MsgLen);
./isdn/hardware/avm/t1isa.c:175:				skb_put_data(skb, card->databuf, DataB3Len);
./isdn/hardware/avm/t1isa.c:182:			ApplId = (unsigned) b1_get_word(card->port);
./isdn/hardware/avm/t1isa.c:183:			MsgLen = t1_get_slice(card->port, card->msgbuf);
./isdn/hardware/avm/t1isa.c:185:				spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:187:				       card->name);
./isdn/hardware/avm/t1isa.c:189:				skb_put_data(skb, card->msgbuf, MsgLen);
./isdn/hardware/avm/t1isa.c:194:				spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:201:			ApplId = b1_get_word(card->port);
./isdn/hardware/avm/t1isa.c:202:			NCCI = b1_get_word(card->port);
./isdn/hardware/avm/t1isa.c:203:			WindowSize = b1_get_word(card->port);
./isdn/hardware/avm/t1isa.c:205:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:210:			ApplId = b1_get_word(card->port);
./isdn/hardware/avm/t1isa.c:211:			NCCI = b1_get_word(card->port);
./isdn/hardware/avm/t1isa.c:214:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:218:			b1_put_byte(card->port, SEND_POLLACK);
./isdn/hardware/avm/t1isa.c:219:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:224:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:230:			cinfo->versionlen = t1_get_slice(card->port, cinfo->versionbuf);
./isdn/hardware/avm/t1isa.c:231:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:234:			       card->name,
./isdn/hardware/avm/t1isa.c:241:			ApplId = (unsigned) b1_get_word(card->port);
./isdn/hardware/avm/t1isa.c:242:			MsgLen = t1_get_slice(card->port, card->msgbuf);
./isdn/hardware/avm/t1isa.c:243:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:244:			card->msgbuf[MsgLen] = 0;
./isdn/hardware/avm/t1isa.c:246:			       && (card->msgbuf[MsgLen - 1] == '\n'
./isdn/hardware/avm/t1isa.c:247:				   || card->msgbuf[MsgLen - 1] == '\r')) {
./isdn/hardware/avm/t1isa.c:248:				card->msgbuf[MsgLen - 1] = 0;
./isdn/hardware/avm/t1isa.c:252:			       card->name, ApplId, card->msgbuf);
./isdn/hardware/avm/t1isa.c:256:			MsgLen = t1_get_slice(card->port, card->msgbuf);
./isdn/hardware/avm/t1isa.c:257:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:258:			card->msgbuf[MsgLen] = 0;
./isdn/hardware/avm/t1isa.c:260:			       && (card->msgbuf[MsgLen - 1] == '\n'
./isdn/hardware/avm/t1isa.c:261:				   || card->msgbuf[MsgLen - 1] == '\r')) {
./isdn/hardware/avm/t1isa.c:262:				card->msgbuf[MsgLen - 1] = 0;
./isdn/hardware/avm/t1isa.c:265:			printk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);
./isdn/hardware/avm/t1isa.c:270:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:271:			printk(KERN_ERR "%s: card reseted ?\n", card->name);
./isdn/hardware/avm/t1isa.c:274:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:276:			       card->name, b1cmd);
./isdn/hardware/avm/t1isa.c:289:	unsigned int port = card->port;
./isdn/hardware/avm/t1isa.c:299:		       card->name);
./isdn/hardware/avm/t1isa.c:307:			       card->name);
./isdn/hardware/avm/t1isa.c:313:		printk(KERN_ERR "%s: failed to load t4file.\n", card->name);
./isdn/hardware/avm/t1isa.c:317:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:318:	b1_setinterrupt(port, card->irq, card->cardtype);
./isdn/hardware/avm/t1isa.c:323:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:332:	unsigned int port = card->port;
./isdn/hardware/avm/t1isa.c:340:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:342:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:356:	t1_disable_irq(card->port);
./isdn/hardware/avm/t1isa.c:357:	b1_reset(card->port);
./isdn/hardware/avm/t1isa.c:358:	b1_reset(card->port);
./isdn/hardware/avm/t1isa.c:359:	t1_reset(card->port);
./isdn/hardware/avm/t1isa.c:362:	free_irq(card->irq, card);
./isdn/hardware/avm/t1isa.c:363:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/t1isa.c:385:	cinfo = card->ctrlinfo;
./isdn/hardware/avm/t1isa.c:386:	card->port = pci_resource_start(pdev, 0);
./isdn/hardware/avm/t1isa.c:387:	card->irq = pdev->irq;
./isdn/hardware/avm/t1isa.c:388:	card->cardtype = avm_t1isa;
./isdn/hardware/avm/t1isa.c:389:	card->cardnr = cardnr;
./isdn/hardware/avm/t1isa.c:390:	sprintf(card->name, "t1isa-%x", card->port);
./isdn/hardware/avm/t1isa.c:392:	if (!(((card->port & 0x7) == 0) && ((card->port & 0x30) != 0x30))) {
./isdn/hardware/avm/t1isa.c:393:		printk(KERN_WARNING "t1isa: invalid port 0x%x.\n", card->port);
./isdn/hardware/avm/t1isa.c:397:	if (hema_irq_table[card->irq & 0xf] == 0) {
./isdn/hardware/avm/t1isa.c:398:		printk(KERN_WARNING "t1isa: irq %d not valid.\n", card->irq);
./isdn/hardware/avm/t1isa.c:402:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./isdn/hardware/avm/t1isa.c:404:		       card->port, card->port + AVMB1_PORTLEN);
./isdn/hardware/avm/t1isa.c:408:	retval = request_irq(card->irq, t1isa_interrupt, 0, card->name, card);
./isdn/hardware/avm/t1isa.c:410:		printk(KERN_INFO "t1isa: unable to get IRQ %d.\n", card->irq);
./isdn/hardware/avm/t1isa.c:415:	if ((retval = t1_detectandinit(card->port, card->irq, card->cardnr)) != 0) {
./isdn/hardware/avm/t1isa.c:417:		       card->port, retval);
./isdn/hardware/avm/t1isa.c:421:	t1_disable_irq(card->port);
./isdn/hardware/avm/t1isa.c:422:	b1_reset(card->port);
./isdn/hardware/avm/t1isa.c:434:	strcpy(cinfo->capi_ctrl.name, card->name);
./isdn/hardware/avm/t1isa.c:443:	       card->port, card->irq, card->cardnr);
./isdn/hardware/avm/t1isa.c:449:	free_irq(card->irq, card);
./isdn/hardware/avm/t1isa.c:451:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/t1isa.c:462:	unsigned int port = card->port;
./isdn/hardware/avm/t1isa.c:469:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:476:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:488:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/t1isa.c:503:		cinfo->card ? cinfo->card->port : 0x0,
./isdn/hardware/avm/t1isa.c:504:		cinfo->card ? cinfo->card->irq : 0,
./isdn/hardware/avm/t1isa.c:505:		cinfo->card ? cinfo->card->cardnr : 0
./isdn/hardware/avm/t1pci.c:62:	card->dma = avmcard_dma_alloc("t1pci", pdev, 2048 + 128, 2048 + 128);
./isdn/hardware/avm/t1pci.c:63:	if (!card->dma) {
./isdn/hardware/avm/t1pci.c:69:	cinfo = card->ctrlinfo;
./isdn/hardware/avm/t1pci.c:70:	sprintf(card->name, "t1pci-%x", p->port);
./isdn/hardware/avm/t1pci.c:71:	card->port = p->port;
./isdn/hardware/avm/t1pci.c:72:	card->irq = p->irq;
./isdn/hardware/avm/t1pci.c:73:	card->membase = p->membase;
./isdn/hardware/avm/t1pci.c:74:	card->cardtype = avm_t1pci;
./isdn/hardware/avm/t1pci.c:76:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./isdn/hardware/avm/t1pci.c:78:		       card->port, card->port + AVMB1_PORTLEN);
./isdn/hardware/avm/t1pci.c:83:	card->mbase = ioremap(card->membase, 64);
./isdn/hardware/avm/t1pci.c:84:	if (!card->mbase) {
./isdn/hardware/avm/t1pci.c:86:		       card->membase);
./isdn/hardware/avm/t1pci.c:97:			       card->port, retval);
./isdn/hardware/avm/t1pci.c:100:			       card->port, retval);
./isdn/hardware/avm/t1pci.c:106:	retval = request_irq(card->irq, b1dma_interrupt, IRQF_SHARED, card->name, card);
./isdn/hardware/avm/t1pci.c:108:		printk(KERN_ERR "t1pci: unable to get IRQ %d.\n", card->irq);
./isdn/hardware/avm/t1pci.c:123:	strcpy(cinfo->capi_ctrl.name, card->name);
./isdn/hardware/avm/t1pci.c:131:	card->cardnr = cinfo->capi_ctrl.cnr;
./isdn/hardware/avm/t1pci.c:134:	       card->port, card->irq, card->membase);
./isdn/hardware/avm/t1pci.c:140:	free_irq(card->irq, card);
./isdn/hardware/avm/t1pci.c:142:	iounmap(card->mbase);
./isdn/hardware/avm/t1pci.c:144:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/t1pci.c:146:	avmcard_dma_free(card->dma);
./isdn/hardware/avm/t1pci.c:158:	avmctrl_info *cinfo = card->ctrlinfo;
./isdn/hardware/avm/t1pci.c:163:	free_irq(card->irq, card);
./isdn/hardware/avm/t1pci.c:164:	iounmap(card->mbase);
./isdn/hardware/avm/t1pci.c:165:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/t1pci.c:166:	avmcard_dma_free(card->dma);
./isdn/hardware/avm/t1pci.c:181:		cinfo->card ? cinfo->card->port : 0x0,
./isdn/hardware/avm/t1pci.c:182:		cinfo->card ? cinfo->card->irq : 0,
./isdn/hardware/avm/t1pci.c:183:		cinfo->card ? cinfo->card->membase : 0
./isdn/hardware/avm/b1.c:81:	card->ctrlinfo = cinfo;
./isdn/hardware/avm/b1.c:86:	spin_lock_init(&card->lock);
./isdn/hardware/avm/b1.c:87:	card->nr_controllers = nr_controllers;
./isdn/hardware/avm/b1.c:96:	kfree(card->ctrlinfo);
./isdn/hardware/avm/b1.c:147:	card->class = inb(card->port + B1_ANALYSE);
./isdn/hardware/avm/b1.c:148:	card->revision = inb(card->port + B1_REVISION);
./isdn/hardware/avm/b1.c:157:	unsigned int base = card->port;
./isdn/hardware/avm/b1.c:171:				       card->name);
./isdn/hardware/avm/b1.c:187:				       card->name);
./isdn/hardware/avm/b1.c:198:	unsigned int base = card->port;
./isdn/hardware/avm/b1.c:247:	unsigned int base = card->port;
./isdn/hardware/avm/b1.c:258:		       card->name);
./isdn/hardware/avm/b1.c:268:			       card->name, ans);
./isdn/hardware/avm/b1.c:272:	printk(KERN_ERR "%s: b1_loaded: firmware not running\n", card->name);
./isdn/hardware/avm/b1.c:282:	unsigned int port = card->port;
./isdn/hardware/avm/b1.c:291:		       card->name);
./isdn/hardware/avm/b1.c:301:			       card->name);
./isdn/hardware/avm/b1.c:307:		printk(KERN_ERR "%s: failed to load t4file.\n", card->name);
./isdn/hardware/avm/b1.c:311:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1.c:312:	b1_setinterrupt(port, card->irq, card->cardtype);
./isdn/hardware/avm/b1.c:317:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:326:	unsigned int port = card->port;
./isdn/hardware/avm/b1.c:333:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1.c:335:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:345:	unsigned int port = card->port;
./isdn/hardware/avm/b1.c:353:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1.c:360:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:367:	unsigned int port = card->port;
./isdn/hardware/avm/b1.c:370:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1.c:374:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:381:	unsigned int port = card->port;
./isdn/hardware/avm/b1.c:388:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1.c:395:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:408:	spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:460:	       card->name, ctrl->cnr, cinfo->cardname);
./isdn/hardware/avm/b1.c:465:		       card->name,
./isdn/hardware/avm/b1.c:479:		       card->name,
./isdn/hardware/avm/b1.c:493:	avmctrl_info *cinfo = &card->ctrlinfo[0];
./isdn/hardware/avm/b1.c:505:	spin_lock_irqsave(&card->lock, flags);
./isdn/hardware/avm/b1.c:507:	if (!b1_rx_full(card->port)) {
./isdn/hardware/avm/b1.c:508:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:512:	b1cmd = b1_get_byte(card->port);
./isdn/hardware/avm/b1.c:518:		ApplId = (unsigned) b1_get_word(card->port);
./isdn/hardware/avm/b1.c:519:		MsgLen = b1_get_slice(card->port, card->msgbuf);
./isdn/hardware/avm/b1.c:520:		DataB3Len = b1_get_slice(card->port, card->databuf);
./isdn/hardware/avm/b1.c:521:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:524:			memset(card->msgbuf + MsgLen, 0, 30-MsgLen);
./isdn/hardware/avm/b1.c:526:			CAPIMSG_SETLEN(card->msgbuf, 30);
./isdn/hardware/avm/b1.c:530:			       card->name);
./isdn/hardware/avm/b1.c:532:			skb_put_data(skb, card->msgbuf, MsgLen);
./isdn/hardware/avm/b1.c:533:			skb_put_data(skb, card->databuf, DataB3Len);
./isdn/hardware/avm/b1.c:540:		ApplId = (unsigned) b1_get_word(card->port);
./isdn/hardware/avm/b1.c:541:		MsgLen = b1_get_slice(card->port, card->msgbuf);
./isdn/hardware/avm/b1.c:544:			       card->name);
./isdn/hardware/avm/b1.c:545:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:547:			skb_put_data(skb, card->msgbuf, MsgLen);
./isdn/hardware/avm/b1.c:552:			spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:559:		ApplId = b1_get_word(card->port);
./isdn/hardware/avm/b1.c:560:		NCCI = b1_get_word(card->port);
./isdn/hardware/avm/b1.c:561:		WindowSize = b1_get_word(card->port);
./isdn/hardware/avm/b1.c:563:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:568:		ApplId = b1_get_word(card->port);
./isdn/hardware/avm/b1.c:569:		NCCI = b1_get_word(card->port);
./isdn/hardware/avm/b1.c:572:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:576:		/* b1_put_byte(card->port, SEND_POLLACK); */
./isdn/hardware/avm/b1.c:577:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:582:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:588:		cinfo->versionlen = b1_get_slice(card->port, cinfo->versionbuf);
./isdn/hardware/avm/b1.c:589:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:592:		       card->name,
./isdn/hardware/avm/b1.c:599:		ApplId = (unsigned) b1_get_word(card->port);
./isdn/hardware/avm/b1.c:600:		MsgLen = b1_get_slice(card->port, card->msgbuf);
./isdn/hardware/avm/b1.c:601:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:602:		card->msgbuf[MsgLen] = 0;
./isdn/hardware/avm/b1.c:604:		       && (card->msgbuf[MsgLen - 1] == '\n'
./isdn/hardware/avm/b1.c:605:			   || card->msgbuf[MsgLen - 1] == '\r')) {
./isdn/hardware/avm/b1.c:606:			card->msgbuf[MsgLen - 1] = 0;
./isdn/hardware/avm/b1.c:610:		       card->name, ApplId, card->msgbuf);
./isdn/hardware/avm/b1.c:614:		MsgLen = b1_get_slice(card->port, card->msgbuf);
./isdn/hardware/avm/b1.c:615:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:616:		card->msgbuf[MsgLen] = 0;
./isdn/hardware/avm/b1.c:618:		       && (card->msgbuf[MsgLen - 1] == '\n'
./isdn/hardware/avm/b1.c:619:			   || card->msgbuf[MsgLen - 1] == '\r')) {
./isdn/hardware/avm/b1.c:620:			card->msgbuf[MsgLen - 1] = 0;
./isdn/hardware/avm/b1.c:623:		printk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);
./isdn/hardware/avm/b1.c:627:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:628:		printk(KERN_ERR "%s: card removed ?\n", card->name);
./isdn/hardware/avm/b1.c:631:		spin_unlock_irqrestore(&card->lock, flags);
./isdn/hardware/avm/b1.c:633:		       card->name, b1cmd);
./isdn/hardware/avm/b1.c:648:	seq_printf(m, "%-16s %s\n", "name", card->name);
./isdn/hardware/avm/b1.c:649:	seq_printf(m, "%-16s 0x%x\n", "io", card->port);
./isdn/hardware/avm/b1.c:650:	seq_printf(m, "%-16s %d\n", "irq", card->irq);
./isdn/hardware/avm/b1.c:651:	switch (card->cardtype) {
./isdn/hardware/avm/b1.c:664:	if (card->cardtype == avm_t1isa)
./isdn/hardware/avm/b1.c:665:		seq_printf(m, "%-16s %d\n", "cardnr", card->cardnr);
./isdn/hardware/avm/b1.c:673:	if (card->cardtype != avm_m1) {
./isdn/hardware/avm/b1.c:687:	if (card->cardtype != avm_m1) {
./isdn/hardware/avm/b1pcmcia.c:44:	unsigned int port = card->port;
./isdn/hardware/avm/b1pcmcia.c:50:	free_irq(card->irq, card);
./isdn/hardware/avm/b1pcmcia.c:74:	cinfo = card->ctrlinfo;
./isdn/hardware/avm/b1pcmcia.c:77:	case avm_m1: sprintf(card->name, "m1-%x", port); break;
./isdn/hardware/avm/b1pcmcia.c:78:	case avm_m2: sprintf(card->name, "m2-%x", port); break;
./isdn/hardware/avm/b1pcmcia.c:79:	default: sprintf(card->name, "b1pcmcia-%x", port); break;
./isdn/hardware/avm/b1pcmcia.c:81:	card->port = port;
./isdn/hardware/avm/b1pcmcia.c:82:	card->irq = irq;
./isdn/hardware/avm/b1pcmcia.c:83:	card->cardtype = cardtype;
./isdn/hardware/avm/b1pcmcia.c:85:	retval = request_irq(card->irq, b1_interrupt, IRQF_SHARED, card->name, card);
./isdn/hardware/avm/b1pcmcia.c:88:		       card->irq);
./isdn/hardware/avm/b1pcmcia.c:92:	b1_reset(card->port);
./isdn/hardware/avm/b1pcmcia.c:93:	if ((retval = b1_detect(card->port, card->cardtype)) != 0) {
./isdn/hardware/avm/b1pcmcia.c:95:		       card->port, retval);
./isdn/hardware/avm/b1pcmcia.c:99:	b1_reset(card->port);
./isdn/hardware/avm/b1pcmcia.c:112:	strcpy(cinfo->capi_ctrl.name, card->name);
./isdn/hardware/avm/b1pcmcia.c:126:	       cardname, card->port, card->irq, card->revision);
./isdn/hardware/avm/b1pcmcia.c:128:	list_add(&card->list, &cards);
./isdn/hardware/avm/b1pcmcia.c:132:	free_irq(card->irq, card);
./isdn/hardware/avm/b1pcmcia.c:150:		cinfo->card ? cinfo->card->port : 0x0,
./isdn/hardware/avm/b1pcmcia.c:151:		cinfo->card ? cinfo->card->irq : 0,
./isdn/hardware/avm/b1pcmcia.c:152:		cinfo->card ? cinfo->card->revision : 0
./isdn/hardware/avm/b1pcmcia.c:181:		if (card->port == port && card->irq == irq) {
./isdn/hardware/avm/b1pcmcia.c:182:			b1pcmcia_remove_ctr(&card->ctrlinfo[0].capi_ctrl);
./isdn/hardware/avm/b1isa.c:50:	b1_reset(card->port);
./isdn/hardware/avm/b1isa.c:51:	b1_reset(card->port);
./isdn/hardware/avm/b1isa.c:54:	free_irq(card->irq, card);
./isdn/hardware/avm/b1isa.c:55:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/b1isa.c:76:	cinfo = card->ctrlinfo;
./isdn/hardware/avm/b1isa.c:78:	card->port = pci_resource_start(pdev, 0);
./isdn/hardware/avm/b1isa.c:79:	card->irq = pdev->irq;
./isdn/hardware/avm/b1isa.c:80:	card->cardtype = avm_b1isa;
./isdn/hardware/avm/b1isa.c:81:	sprintf(card->name, "b1isa-%x", card->port);
./isdn/hardware/avm/b1isa.c:83:	if (card->port != 0x150 && card->port != 0x250
./isdn/hardware/avm/b1isa.c:84:	    && card->port != 0x300 && card->port != 0x340) {
./isdn/hardware/avm/b1isa.c:85:		printk(KERN_WARNING "b1isa: invalid port 0x%x.\n", card->port);
./isdn/hardware/avm/b1isa.c:89:	if (b1_irq_table[card->irq & 0xf] == 0) {
./isdn/hardware/avm/b1isa.c:90:		printk(KERN_WARNING "b1isa: irq %d not valid.\n", card->irq);
./isdn/hardware/avm/b1isa.c:94:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./isdn/hardware/avm/b1isa.c:96:		       card->port, card->port + AVMB1_PORTLEN);
./isdn/hardware/avm/b1isa.c:100:	retval = request_irq(card->irq, b1_interrupt, 0, card->name, card);
./isdn/hardware/avm/b1isa.c:102:		printk(KERN_ERR "b1isa: unable to get IRQ %d.\n", card->irq);
./isdn/hardware/avm/b1isa.c:105:	b1_reset(card->port);
./isdn/hardware/avm/b1isa.c:106:	if ((retval = b1_detect(card->port, card->cardtype)) != 0) {
./isdn/hardware/avm/b1isa.c:108:		       card->port, retval);
./isdn/hardware/avm/b1isa.c:112:	b1_reset(card->port);
./isdn/hardware/avm/b1isa.c:125:	strcpy(cinfo->capi_ctrl.name, card->name);
./isdn/hardware/avm/b1isa.c:134:	       card->port, card->irq, card->revision);
./isdn/hardware/avm/b1isa.c:140:	free_irq(card->irq, card);
./isdn/hardware/avm/b1isa.c:142:	release_region(card->port, AVMB1_PORTLEN);
./isdn/hardware/avm/b1isa.c:158:		cinfo->card ? cinfo->card->port : 0x0,
./isdn/hardware/avm/b1isa.c:159:		cinfo->card ? cinfo->card->irq : 0,
./isdn/hardware/avm/b1isa.c:160:		cinfo->card ? cinfo->card->revision : 0
./isdn/capi/capidrv.c:345:	plcip->next = card->plci_list;
./isdn/capi/capidrv.c:346:	card->plci_list = plcip;
./isdn/capi/capidrv.c:347:	card->bchans[chan].plcip = plcip;
./isdn/capi/capidrv.c:355:	for (p = card->plci_list; p; p = p->next)
./isdn/capi/capidrv.c:364:	for (p = card->plci_list; p; p = p->next)
./isdn/capi/capidrv.c:373:	for (p = card->plci_list; p; p = p->next)
./isdn/capi/capidrv.c:383:	for (pp = &card->plci_list; *pp; pp = &(*pp)->next) {
./isdn/capi/capidrv.c:386:			card->bchans[plcip->chan].plcip = NULL;
./isdn/capi/capidrv.c:387:			card->bchans[plcip->chan].disconnecting = 0;
./isdn/capi/capidrv.c:388:			card->bchans[plcip->chan].incoming = 0;
./isdn/capi/capidrv.c:394:	       card->contrnr, plcip, plcip->plci);
./isdn/capi/capidrv.c:419:	card->bchans[plcip->chan].nccip = nccip;
./isdn/capi/capidrv.c:463:	card->bchans[nccip->chan].nccip = NULL;
./isdn/capi/capidrv.c:549:		if (card->state == p->actstate && p->event == event) {
./isdn/capi/capidrv.c:552:				       card->contrnr, card->state, p->nextstate);
./isdn/capi/capidrv.c:553:			card->state = p->nextstate;
./isdn/capi/capidrv.c:559:	       card->contrnr, card->state, event);
./isdn/capi/capidrv.c:569:	card->bchans[plci->chan].contr = NULL;
./isdn/capi/capidrv.c:571:	cmd.driver = card->myid;
./isdn/capi/capidrv.c:573:	card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:647:				       card->contrnr, plci->plci, plci->state, p->nextstate);
./isdn/capi/capidrv.c:656:	       card->contrnr, plci->plci, plci->state, event);
./isdn/capi/capidrv.c:669:				 card->msgid++,
./isdn/capi/capidrv.c:680:	cmd.driver = card->myid;
./isdn/capi/capidrv.c:682:	card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:736:				       card->contrnr, ncci->ncci, ncci->state, p->nextstate);
./isdn/capi/capidrv.c:751:	       card->contrnr, ncci->ncci, ncci->state, event);
./isdn/capi/capidrv.c:759:	for (i = 0; i < card->nbchan; i++) {
./isdn/capi/capidrv.c:760:		if (card->bchans[i].plcip == NULL) {
./isdn/capi/capidrv.c:761:			card->bchans[i].disconnecting = 0;
./isdn/capi/capidrv.c:980:			       card->contrnr, cmsg->Info, capi_info2str(cmsg->Info), card->cipmask);
./isdn/capi/capidrv.c:983:		} else if (card->cipmask == 0) {
./isdn/capi/capidrv.c:1017:			       card->contrnr,
./isdn/capi/capidrv.c:1034:				       card->contrnr,
./isdn/capi/capidrv.c:1052:		       card->contrnr,
./isdn/capi/capidrv.c:1060:	       card->contrnr,
./isdn/capi/capidrv.c:1073:		printk(KERN_ERR "capidrv-%d: incoming call on not existing bchan ?\n", card->contrnr);
./isdn/capi/capidrv.c:1076:	bchan = &card->bchans[chan];
./isdn/capi/capidrv.c:1078:		printk(KERN_ERR "capidrv-%d: incoming call: no memory, sorry.\n", card->contrnr);
./isdn/capi/capidrv.c:1086:	cmd.driver = card->myid;
./isdn/capi/capidrv.c:1101:	       card->contrnr,
./isdn/capi/capidrv.c:1109:		       card->contrnr,
./isdn/capi/capidrv.c:1114:	switch (card->interface.statcallb(&cmd)) {
./isdn/capi/capidrv.c:1127:		       card->contrnr,
./isdn/capi/capidrv.c:1145:			       card->contrnr,
./isdn/capi/capidrv.c:1152:					    card->msgid++,
./isdn/capi/capidrv.c:1163:			       card->contrnr,
./isdn/capi/capidrv.c:1208:			       card->contrnr,
./isdn/capi/capidrv.c:1217:		card->bchans[plcip->chan].disconnecting = 1;
./isdn/capi/capidrv.c:1227:			       card->contrnr,
./isdn/capi/capidrv.c:1235:		card->bchans[plcip->chan].disconnecting = 1;
./isdn/capi/capidrv.c:1241:			       card->contrnr,
./isdn/capi/capidrv.c:1255:			       card->contrnr,
./isdn/capi/capidrv.c:1276:		if (card->bchans[plcip->chan].incoming) {
./isdn/capi/capidrv.c:1288:				printk(KERN_ERR "capidrv-%d: no mem for ncci, sorry\n", card->contrnr);
./isdn/capi/capidrv.c:1293:						 card->msgid++,
./isdn/capi/capidrv.c:1303:			cmd.driver = card->myid;
./isdn/capi/capidrv.c:1305:			card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:1317:				cmd.driver = card->myid;
./isdn/capi/capidrv.c:1325:				card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:1332:			       card->contrnr, cdb->buf);
./isdn/capi/capidrv.c:1336:			       card->contrnr, cmsg->InfoNumber);
./isdn/capi/capidrv.c:1354:		       card->contrnr,
./isdn/capi/capidrv.c:1361:	       card->contrnr,
./isdn/capi/capidrv.c:1367:	       card->contrnr,
./isdn/capi/capidrv.c:1398:		cmd.driver = card->myid;
./isdn/capi/capidrv.c:1400:		card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:1403:		       card->contrnr, nccip->chan, nccip->ncci);
./isdn/capi/capidrv.c:1418:							  card->msgid++,
./isdn/capi/capidrv.c:1427:			printk(KERN_ERR "capidrv-%d: no mem for ncci, sorry\n",							card->contrnr);
./isdn/capi/capidrv.c:1430:			       card->contrnr,
./isdn/capi/capidrv.c:1436:					  card->msgid++,
./isdn/capi/capidrv.c:1454:			       card->contrnr,
./isdn/capi/capidrv.c:1487:		cmd.driver = card->myid;
./isdn/capi/capidrv.c:1490:		card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:1497:		card->bchans[nccip->chan].disconnecting = 1;
./isdn/capi/capidrv.c:1509:			       card->contrnr,
./isdn/capi/capidrv.c:1535:		       card->contrnr,
./isdn/capi/capidrv.c:1542:	       card->contrnr,
./isdn/capi/capidrv.c:1548:	       card->contrnr,
./isdn/capi/capidrv.c:1568:		       card->contrnr,
./isdn/capi/capidrv.c:1575:	card->interface.rcvcallb_skb(card->myid, nccip->chan, skb);
./isdn/capi/capidrv.c:1638:		       card->contrnr, len);
./isdn/capi/capidrv.c:1662:	cmd.driver = card->myid;
./isdn/capi/capidrv.c:1664:	card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:1677:		       card->contrnr, debugmode);
./isdn/capi/capidrv.c:1681:		       card->contrnr, c->arg);
./isdn/capi/capidrv.c:1804:			       card->contrnr,
./isdn/capi/capidrv.c:1811:		bchan = &card->bchans[c->arg % card->nbchan];
./isdn/capi/capidrv.c:1815:			       card->contrnr,
./isdn/capi/capidrv.c:1832:			printk(KERN_ERR "capidrv-%d: WARNING: invalid leased linedefinition \"%s\"\n", card->contrnr, bchan->num);
./isdn/capi/capidrv.c:1838:				printk(KERN_DEBUG "capidrv-%d: connecting leased line\n", card->contrnr);
./isdn/capi/capidrv.c:1851:				      card->msgid++,
./isdn/capi/capidrv.c:1852:				      card->contrnr,	/* adr */
./isdn/capi/capidrv.c:1873:		if ((plcip = new_plci(card, (c->arg % card->nbchan))) == NULL) {
./isdn/capi/capidrv.c:1875:			cmd.driver = card->myid;
./isdn/capi/capidrv.c:1876:			cmd.arg = (c->arg % card->nbchan);
./isdn/capi/capidrv.c:1877:			card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:1889:		bchan = &card->bchans[c->arg % card->nbchan];
./isdn/capi/capidrv.c:1892:			       card->contrnr,
./isdn/capi/capidrv.c:1897:				       card->msgid++,
./isdn/capi/capidrv.c:1916:			       card->contrnr);
./isdn/capi/capidrv.c:1926:			       card->contrnr,
./isdn/capi/capidrv.c:1933:			       card->contrnr,
./isdn/capi/capidrv.c:1935:		bchan = &card->bchans[c->arg % card->nbchan];
./isdn/capi/capidrv.c:1940:				       card->contrnr,
./isdn/capi/capidrv.c:1948:						    card->msgid++,
./isdn/capi/capidrv.c:1969:							 card->msgid++,
./isdn/capi/capidrv.c:1981:				       card->contrnr,
./isdn/capi/capidrv.c:1987:		       card->contrnr,
./isdn/capi/capidrv.c:1995:			       card->contrnr,
./isdn/capi/capidrv.c:1997:		bchan = &card->bchans[(c->arg & 0xff) % card->nbchan];
./isdn/capi/capidrv.c:2004:			       card->contrnr,
./isdn/capi/capidrv.c:2006:		bchan = &card->bchans[(c->arg & 0xff) % card->nbchan];
./isdn/capi/capidrv.c:2013:			       card->contrnr,
./isdn/capi/capidrv.c:2015:		bchan = &card->bchans[c->arg % card->nbchan];
./isdn/capi/capidrv.c:2022:			       card->contrnr, c->arg);
./isdn/capi/capidrv.c:2023:		bchan = &card->bchans[c->arg % card->nbchan];
./isdn/capi/capidrv.c:2029:		       card->contrnr, c->command);
./isdn/capi/capidrv.c:2068:		       card->contrnr, len, skb, doack);
./isdn/capi/capidrv.c:2069:	bchan = &card->bchans[channel % card->nbchan];
./isdn/capi/capidrv.c:2073:		       card->contrnr, card->name, channel);
./isdn/capi/capidrv.c:2094:	capi_fill_DATA_B3_REQ(&sendcmsg, global.ap.applid, card->msgid++,
./isdn/capi/capidrv.c:2107:		       card->contrnr);
./isdn/capi/capidrv.c:2115:			       card->contrnr);
./isdn/capi/capidrv.c:2120:		       card->contrnr, skb_headroom(skb), msglen);
./isdn/capi/capidrv.c:2130:			       card->contrnr, errcode, capi_info2str(errcode));
./isdn/capi/capidrv.c:2143:			       card->contrnr, errcode, capi_info2str(errcode));
./isdn/capi/capidrv.c:2163:		if (put_user(*card->q931_read++, p))
./isdn/capi/capidrv.c:2165:		if (card->q931_read > card->q931_end)
./isdn/capi/capidrv.c:2166:			card->q931_read = card->q931_buf;
./isdn/capi/capidrv.c:2176:	u16 contr = card->contrnr;
./isdn/capi/capidrv.c:2183:		       card->name, errcode);
./isdn/capi/capidrv.c:2188:		       card->name, manufacturer);
./isdn/capi/capidrv.c:2194:		       card->name, errcode);
./isdn/capi/capidrv.c:2203:		printk(KERN_INFO "%s: D2 trace enabled\n", card->name);
./isdn/capi/capidrv.c:2205:					   card->msgid++,
./isdn/capi/capidrv.c:2212:		printk(KERN_INFO "%s: D3 trace enabled\n", card->name);
./isdn/capi/capidrv.c:2214:					   card->msgid++,
./isdn/capi/capidrv.c:2228:			     card->msgid++,
./isdn/capi/capidrv.c:2229:			     card->contrnr, /* controller */
./isdn/capi/capidrv.c:2231:			     card->cipmask,
./isdn/capi/capidrv.c:2232:			     card->cipmask2,
./isdn/capi/capidrv.c:2241:	if (card->state != ST_LISTEN_NONE && card->state != ST_LISTEN_ACTIVE)
./isdn/capi/capidrv.c:2242:		printk(KERN_ERR "%s: controller dead ??\n", card->name);
./isdn/capi/capidrv.c:2244:	mod_timer(&card->listentimer, jiffies + 60 * HZ);
./isdn/capi/capidrv.c:2266:	card->owner = THIS_MODULE;
./isdn/capi/capidrv.c:2267:	setup_timer(&card->listentimer, listentimerfunc, (unsigned long)card);
./isdn/capi/capidrv.c:2268:	strcpy(card->name, id);
./isdn/capi/capidrv.c:2269:	card->contrnr = contr;
./isdn/capi/capidrv.c:2270:	card->nbchan = profp->nbchannel;
./isdn/capi/capidrv.c:2271:	card->bchans = kmalloc(sizeof(capidrv_bchan) * card->nbchan, GFP_ATOMIC);
./isdn/capi/capidrv.c:2272:	if (!card->bchans) {
./isdn/capi/capidrv.c:2275:		module_put(card->owner);
./isdn/capi/capidrv.c:2279:	card->interface.channels = profp->nbchannel;
./isdn/capi/capidrv.c:2280:	card->interface.maxbufsize = 2048;
./isdn/capi/capidrv.c:2281:	card->interface.command = if_command;
./isdn/capi/capidrv.c:2282:	card->interface.writebuf_skb = if_sendbuf;
./isdn/capi/capidrv.c:2283:	card->interface.writecmd = NULL;
./isdn/capi/capidrv.c:2284:	card->interface.readstat = if_readstat;
./isdn/capi/capidrv.c:2285:	card->interface.features =
./isdn/capi/capidrv.c:2294:		card->interface.features |=
./isdn/capi/capidrv.c:2299:		card->interface.features |= ISDN_FEATURE_L2_MODEM;
./isdn/capi/capidrv.c:2300:	card->interface.hl_hdrlen = 22; /* len of DATA_B3_REQ */
./isdn/capi/capidrv.c:2301:	strncpy(card->interface.id, id, sizeof(card->interface.id) - 1);
./isdn/capi/capidrv.c:2304:	card->q931_read = card->q931_buf;
./isdn/capi/capidrv.c:2305:	card->q931_write = card->q931_buf;
./isdn/capi/capidrv.c:2306:	card->q931_end = card->q931_buf + sizeof(card->q931_buf) - 1;
./isdn/capi/capidrv.c:2308:	if (!register_isdn(&card->interface)) {
./isdn/capi/capidrv.c:2310:		kfree(card->bchans);
./isdn/capi/capidrv.c:2311:		module_put(card->owner);
./isdn/capi/capidrv.c:2315:	card->myid = card->interface.channels;
./isdn/capi/capidrv.c:2316:	memset(card->bchans, 0, sizeof(capidrv_bchan) * card->nbchan);
./isdn/capi/capidrv.c:2317:	for (i = 0; i < card->nbchan; i++) {
./isdn/capi/capidrv.c:2318:		card->bchans[i].contr = card;
./isdn/capi/capidrv.c:2322:	card->next = global.contr_list;
./isdn/capi/capidrv.c:2328:	cmd.driver = card->myid;
./isdn/capi/capidrv.c:2329:	card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:2331:	card->cipmask = 0x1FFF03FF;	/* any */
./isdn/capi/capidrv.c:2332:	card->cipmask2 = 0;
./isdn/capi/capidrv.c:2335:	mod_timer(&card->listentimer, jiffies + 60 * HZ);
./isdn/capi/capidrv.c:2338:	       card->name, card->nbchan);
./isdn/capi/capidrv.c:2352:	for (card = global.contr_list; card; card = card->next) {
./isdn/capi/capidrv.c:2353:		if (card->contrnr == contr)
./isdn/capi/capidrv.c:2367:	del_timer(&card->listentimer);
./isdn/capi/capidrv.c:2371:		       card->contrnr, card->myid);
./isdn/capi/capidrv.c:2374:	cmd.driver = card->myid;
./isdn/capi/capidrv.c:2375:	card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:2377:	while (card->nbchan) {
./isdn/capi/capidrv.c:2380:		cmd.driver = card->myid;
./isdn/capi/capidrv.c:2381:		cmd.arg = card->nbchan - 1;
./isdn/capi/capidrv.c:2385:			       card->contrnr, card->myid, cmd.arg);
./isdn/capi/capidrv.c:2386:		card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:2388:		if (card->bchans[card->nbchan - 1].nccip)
./isdn/capi/capidrv.c:2389:			free_ncci(card, card->bchans[card->nbchan - 1].nccip);
./isdn/capi/capidrv.c:2390:		if (card->bchans[card->nbchan - 1].plcip)
./isdn/capi/capidrv.c:2391:			free_plci(card, card->bchans[card->nbchan - 1].plcip);
./isdn/capi/capidrv.c:2392:		if (card->plci_list)
./isdn/capi/capidrv.c:2394:		card->nbchan--;
./isdn/capi/capidrv.c:2396:	kfree(card->bchans);
./isdn/capi/capidrv.c:2397:	card->bchans = NULL;
./isdn/capi/capidrv.c:2401:		       card->contrnr, card->myid);
./isdn/capi/capidrv.c:2404:	cmd.driver = card->myid;
./isdn/capi/capidrv.c:2405:	card->interface.statcallb(&cmd);
./isdn/capi/capidrv.c:2409:		       card->contrnr, card->myid);
./isdn/capi/capidrv.c:2415:			card->next = NULL;
./isdn/capi/capidrv.c:2422:	module_put(card->owner);
./isdn/capi/capidrv.c:2423:	printk(KERN_INFO "%s: now down.\n", card->name);
./atm/idt77252.h:44:        (((vpi) << card->vcibits) | ((vci) & card->vcimask))
./atm/idt77252.h:438:#define SAR_REG_DR0	(card->membase + 0x00)
./atm/idt77252.h:439:#define SAR_REG_DR1	(card->membase + 0x04)
./atm/idt77252.h:440:#define SAR_REG_DR2	(card->membase + 0x08)
./atm/idt77252.h:441:#define SAR_REG_DR3	(card->membase + 0x0C)
./atm/idt77252.h:442:#define SAR_REG_CMD	(card->membase + 0x10)
./atm/idt77252.h:443:#define SAR_REG_CFG	(card->membase + 0x14)
./atm/idt77252.h:444:#define SAR_REG_STAT	(card->membase + 0x18)
./atm/idt77252.h:445:#define SAR_REG_RSQB	(card->membase + 0x1C)
./atm/idt77252.h:446:#define SAR_REG_RSQT	(card->membase + 0x20)
./atm/idt77252.h:447:#define SAR_REG_RSQH	(card->membase + 0x24)
./atm/idt77252.h:448:#define SAR_REG_CDC	(card->membase + 0x28)
./atm/idt77252.h:449:#define SAR_REG_VPEC	(card->membase + 0x2C)
./atm/idt77252.h:450:#define SAR_REG_ICC	(card->membase + 0x30)
./atm/idt77252.h:451:#define SAR_REG_RAWCT	(card->membase + 0x34)
./atm/idt77252.h:452:#define SAR_REG_TMR	(card->membase + 0x38)
./atm/idt77252.h:453:#define SAR_REG_TSTB	(card->membase + 0x3C)
./atm/idt77252.h:454:#define SAR_REG_TSQB	(card->membase + 0x40)
./atm/idt77252.h:455:#define SAR_REG_TSQT	(card->membase + 0x44)
./atm/idt77252.h:456:#define SAR_REG_TSQH	(card->membase + 0x48)
./atm/idt77252.h:457:#define SAR_REG_GP	(card->membase + 0x4C)
./atm/idt77252.h:458:#define SAR_REG_VPM	(card->membase + 0x50)
./atm/idt77252.h:459:#define SAR_REG_RXFD	(card->membase + 0x54)
./atm/idt77252.h:460:#define SAR_REG_RXFT	(card->membase + 0x58)
./atm/idt77252.h:461:#define SAR_REG_RXFH	(card->membase + 0x5C)
./atm/idt77252.h:462:#define SAR_REG_RAWHND	(card->membase + 0x60)
./atm/idt77252.h:463:#define SAR_REG_RXSTAT	(card->membase + 0x64)
./atm/idt77252.h:464:#define SAR_REG_ABRSTD	(card->membase + 0x68)
./atm/idt77252.h:465:#define SAR_REG_ABRRQ	(card->membase + 0x6C)
./atm/idt77252.h:466:#define SAR_REG_VBRRQ	(card->membase + 0x70)
./atm/idt77252.h:467:#define SAR_REG_RTBL	(card->membase + 0x74)
./atm/idt77252.h:468:#define SAR_REG_MDFCT	(card->membase + 0x78)
./atm/idt77252.h:469:#define SAR_REG_TXSTAT	(card->membase + 0x7C)
./atm/idt77252.h:470:#define SAR_REG_TCMDQ	(card->membase + 0x80)
./atm/idt77252.h:471:#define SAR_REG_IRCP	(card->membase + 0x84)
./atm/idt77252.h:472:#define SAR_REG_FBQP0	(card->membase + 0x88)
./atm/idt77252.h:473:#define SAR_REG_FBQP1	(card->membase + 0x8C)
./atm/idt77252.h:474:#define SAR_REG_FBQP2	(card->membase + 0x90)
./atm/idt77252.h:475:#define SAR_REG_FBQP3	(card->membase + 0x94)
./atm/idt77252.h:476:#define SAR_REG_FBQS0	(card->membase + 0x98)
./atm/idt77252.h:477:#define SAR_REG_FBQS1	(card->membase + 0x9C)
./atm/idt77252.h:478:#define SAR_REG_FBQS2	(card->membase + 0xA0)
./atm/idt77252.h:479:#define SAR_REG_FBQS3	(card->membase + 0xA4)
./atm/idt77252.h:480:#define SAR_REG_FBQWP0	(card->membase + 0xA8)
./atm/idt77252.h:481:#define SAR_REG_FBQWP1	(card->membase + 0xAC)
./atm/idt77252.h:482:#define SAR_REG_FBQWP2	(card->membase + 0xB0)
./atm/idt77252.h:483:#define SAR_REG_FBQWP3	(card->membase + 0xB4)
./atm/idt77252.h:484:#define SAR_REG_NOW	(card->membase + 0xB8)
./atm/lanai.c:223: * This is the card-specific per-vcc data.  Note that unlike some other
./atm/solos-pci.c:76:#define RX_BUF(card, nr) ((card->buffers) + (nr)*(card->buffer_size)*2)
./atm/solos-pci.c:77:#define TX_BUF(card, nr) ((card->buffers) + (nr)*(card->buffer_size)*2 + (card->buffer_size))
./atm/solos-pci.c:78:#define FLASH_BUF ((card->buffers) + 4*(card->buffer_size)*2)
./atm/solos-pci.c:204:		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in solos_param_show()\n");
./atm/solos-pci.c:223:	spin_lock_irq(&card->param_queue_lock);
./atm/solos-pci.c:224:	list_add(&prm.list, &card->param_queue);
./atm/solos-pci.c:225:	spin_unlock_irq(&card->param_queue_lock);
./atm/solos-pci.c:229:	wait_event_timeout(card->param_wq, prm.response, 5 * HZ);
./atm/solos-pci.c:231:	spin_lock_irq(&card->param_queue_lock);
./atm/solos-pci.c:233:	spin_unlock_irq(&card->param_queue_lock);
./atm/solos-pci.c:260:		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in solos_param_store()\n");
./atm/solos-pci.c:279:	spin_lock_irq(&card->param_queue_lock);
./atm/solos-pci.c:280:	list_add(&prm.list, &card->param_queue);
./atm/solos-pci.c:281:	spin_unlock_irq(&card->param_queue_lock);
./atm/solos-pci.c:285:	wait_event_timeout(card->param_wq, prm.response, 5 * HZ);
./atm/solos-pci.c:287:	spin_lock_irq(&card->param_queue_lock);
./atm/solos-pci.c:289:	spin_unlock_irq(&card->param_queue_lock);
./atm/solos-pci.c:311:		dev_warn(&card->dev->dev, "Unexpected parameter response: '%s'\n",
./atm/solos-pci.c:353:	if (!card->atmdev[port])
./atm/solos-pci.c:362:		dev_warn(&card->dev->dev, "Unexpected status interrupt version\n");
./atm/solos-pci.c:366:		dev_warn(&card->dev->dev, "Unexpected status interrupt version %d\n",
./atm/solos-pci.c:375:		dev_dbg(&card->dev->dev, "Status packet indicated Solos error on port %d (starting up?)\n",
./atm/solos-pci.c:397:		atm_dev_signal_change(card->atmdev[port], ATM_PHY_SIG_LOST);
./atm/solos-pci.c:398:		dev_info(&card->dev->dev, "Port %d: %s\n", port, state_str);
./atm/solos-pci.c:409:	dev_info(&card->dev->dev, "Port %d: %s @%d/%d kb/s%s%s%s%s\n",
./atm/solos-pci.c:413:	card->atmdev[port]->link_rate = rate_down / 424;
./atm/solos-pci.c:414:	atm_dev_signal_change(card->atmdev[port], ATM_PHY_SIG_FOUND);
./atm/solos-pci.c:439:	spin_lock_irqsave(&card->param_queue_lock, flags);
./atm/solos-pci.c:440:	list_for_each_entry(prm, &card->param_queue, list) {
./atm/solos-pci.c:444:			wake_up(&card->param_wq);
./atm/solos-pci.c:449:	spin_unlock_irqrestore(&card->param_queue_lock, flags);
./atm/solos-pci.c:461:	spin_lock(&card->cli_queue_lock);
./atm/solos-pci.c:462:	skb = skb_dequeue(&card->cli_queue[SOLOS_CHAN(atmdev)]);
./atm/solos-pci.c:463:	spin_unlock(&card->cli_queue_lock);
./atm/solos-pci.c:480:		dev_dbg(&card->dev->dev, "Command is too big.  Dropping request\n");
./atm/solos-pci.c:485:		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in send_command()\n");
./atm/solos-pci.c:536:	spin_lock_irq(&card->param_queue_lock);
./atm/solos-pci.c:537:	data32 = ioread32(card->config_regs + GPIO_STATUS);
./atm/solos-pci.c:540:		iowrite32(data32, card->config_regs + GPIO_STATUS);
./atm/solos-pci.c:543:		iowrite32(data32, card->config_regs + GPIO_STATUS);
./atm/solos-pci.c:547:	spin_unlock_irq(&card->param_queue_lock);
./atm/solos-pci.c:559:	data32 = ioread32(card->config_regs + GPIO_STATUS);
./atm/solos-pci.c:573:	data32 = ioread32(card->config_regs + GPIO_STATUS);
./atm/solos-pci.c:647:		if (card->atmel_flash)
./atm/solos-pci.c:654:		if (card->atmel_flash)
./atm/solos-pci.c:660:		if (card->fpga_version > LEGACY_BUFFERS){
./atm/solos-pci.c:662:			if (card->atmel_flash)
./atm/solos-pci.c:667:			dev_info(&card->dev->dev, "FPGA version doesn't support"
./atm/solos-pci.c:673:		if (card->fpga_version > LEGACY_BUFFERS){
./atm/solos-pci.c:675:			if (card->atmel_flash)
./atm/solos-pci.c:680:			dev_info(&card->dev->dev, "FPGA version doesn't support"
./atm/solos-pci.c:689:	if (request_firmware(&fw, fw_name, &card->dev->dev))
./atm/solos-pci.c:692:	dev_info(&card->dev->dev, "Flash upgrade starting\n");
./atm/solos-pci.c:695:	iowrite32(DRIVER_VERSION, card->config_regs + DRIVER_VER);
./atm/solos-pci.c:698:	dev_info(&card->dev->dev, "Firmware size: %zd\n", fw->size);
./atm/solos-pci.c:699:	dev_info(&card->dev->dev, "Number of blocks: %d\n", numblocks);
./atm/solos-pci.c:701:	dev_info(&card->dev->dev, "Changing FPGA to Update mode\n");
./atm/solos-pci.c:702:	iowrite32(1, card->config_regs + FPGA_MODE);
./atm/solos-pci.c:703:	(void) ioread32(card->config_regs + FPGA_MODE); 
./atm/solos-pci.c:707:		dev_info(&card->dev->dev, "Set FPGA Flash mode to FPGA Chip Erase\n");
./atm/solos-pci.c:709:		dev_info(&card->dev->dev, "Set FPGA Flash mode to Solos Chip Erase\n");
./atm/solos-pci.c:710:	iowrite32((chip * 2), card->config_regs + FLASH_MODE);
./atm/solos-pci.c:713:	iowrite32(1, card->config_regs + WRITE_FLASH);
./atm/solos-pci.c:714:	wait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));
./atm/solos-pci.c:720:		iowrite32(0, card->config_regs + WRITE_FLASH);
./atm/solos-pci.c:723:		/* dev_info(&card->dev->dev, "Set FPGA Flash mode to Block Write\n"); */
./atm/solos-pci.c:724:		iowrite32(((chip * 2) + 1), card->config_regs + FLASH_MODE);
./atm/solos-pci.c:729:			if (card->atmel_flash)
./atm/solos-pci.c:733:			if(card->fpga_version > LEGACY_BUFFERS)
./atm/solos-pci.c:740:		iowrite32(offset / blocksize, card->config_regs + FLASH_BLOCK);
./atm/solos-pci.c:741:		iowrite32(1, card->config_regs + WRITE_FLASH);
./atm/solos-pci.c:742:		wait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));
./atm/solos-pci.c:746:	iowrite32(0, card->config_regs + WRITE_FLASH);
./atm/solos-pci.c:747:	iowrite32(0, card->config_regs + FPGA_MODE);
./atm/solos-pci.c:748:	iowrite32(0, card->config_regs + FLASH_MODE);
./atm/solos-pci.c:749:	dev_info(&card->dev->dev, "Returning FPGA to Data mode\n");
./atm/solos-pci.c:758:	iowrite32(0, card->config_regs + IRQ_CLEAR);
./atm/solos-pci.c:761:	if (card->atmdev[0])
./atm/solos-pci.c:762:		tasklet_schedule(&card->tlet);
./atm/solos-pci.c:764:		wake_up(&card->fw_wq);
./atm/solos-pci.c:783:	for (port = 0; port < card->nr_ports; port++) {
./atm/solos-pci.c:790:			if (card->using_dma) {
./atm/solos-pci.c:791:				skb = card->rx_skb[port];
./atm/solos-pci.c:792:				card->rx_skb[port] = NULL;
./atm/solos-pci.c:794:				dma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,
./atm/solos-pci.c:809:				if (size > (card->buffer_size - sizeof(*header))){
./atm/solos-pci.c:810:					dev_warn(&card->dev->dev, "Invalid buffer size\n");
./atm/solos-pci.c:822:						dev_warn(&card->dev->dev, "Failed to allocate sk_buff for RX\n");
./atm/solos-pci.c:831:				dev_info(&card->dev->dev, "Received: port %d\n", port);
./atm/solos-pci.c:832:				dev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",
./atm/solos-pci.c:840:				vcc = find_vcc(card->atmdev[port], le16_to_cpu(header->vpi),
./atm/solos-pci.c:844:						dev_warn(&card->dev->dev, "Received packet for unknown VPI.VCI %d.%d on port %d\n",
./atm/solos-pci.c:858:					dev_warn(&card->dev->dev, "Bad status packet of %d bytes on port %d:\n", skb->len, port);
./atm/solos-pci.c:868:				spin_lock(&card->cli_queue_lock);
./atm/solos-pci.c:869:				if (skb_queue_len(&card->cli_queue[port]) > 10) {
./atm/solos-pci.c:871:						dev_warn(&card->dev->dev, "Dropping console response on port %d\n",
./atm/solos-pci.c:875:					skb_queue_tail(&card->cli_queue[port], skb);
./atm/solos-pci.c:876:				spin_unlock(&card->cli_queue_lock);
./atm/solos-pci.c:881:		if (card->using_dma && card->atmdev[port] &&
./atm/solos-pci.c:882:		    !card->rx_skb[port]) {
./atm/solos-pci.c:889:					dma_map_single(&card->dev->dev, skb->data,
./atm/solos-pci.c:892:					  card->config_regs + RX_DMA_ADDR(port));
./atm/solos-pci.c:893:				card->rx_skb[port] = skb;
./atm/solos-pci.c:896:					dev_warn(&card->dev->dev, "Failed to allocate RX skb");
./atm/solos-pci.c:899:				tasklet_schedule(&card->tlet);
./atm/solos-pci.c:904:		iowrite32(rx_done, card->config_regs + FLAGS_ADDR);
./atm/solos-pci.c:937:		dev_warn(&card->dev->dev, "Unsupported ATM type %d\n",
./atm/solos-pci.c:945:			dev_warn(&card->dev->dev, "Failed to allocate sk_buff in popen()\n");
./atm/solos-pci.c:971:	spin_lock(&card->tx_queue_lock);
./atm/solos-pci.c:972:	skb_queue_walk_safe(&card->tx_queue[port], skb, tmpskb) {
./atm/solos-pci.c:974:			skb_unlink(skb, &card->tx_queue[port]);
./atm/solos-pci.c:978:	spin_unlock(&card->tx_queue_lock);
./atm/solos-pci.c:982:		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in pclose()\n");
./atm/solos-pci.c:995:	if (!wait_event_timeout(card->param_wq, !skb_shared(skb), 5 * HZ))
./atm/solos-pci.c:996:		dev_warn(&card->dev->dev,
./atm/solos-pci.c:1004:	tasklet_unlock_wait(&card->tlet);
./atm/solos-pci.c:1048:	spin_lock_irqsave(&card->tx_queue_lock, flags);
./atm/solos-pci.c:1049:	old_len = skb_queue_len(&card->tx_queue[port]);
./atm/solos-pci.c:1050:	skb_queue_tail(&card->tx_queue[port], skb);
./atm/solos-pci.c:1052:		card->tx_mask |= (1 << port);
./atm/solos-pci.c:1053:	spin_unlock_irqrestore(&card->tx_queue_lock, flags);
./atm/solos-pci.c:1070:	spin_lock_irqsave(&card->tx_lock, flags);
./atm/solos-pci.c:1072:	card_flags = ioread32(card->config_regs + FLAGS_ADDR);
./atm/solos-pci.c:1080:	tx_pending = card->tx_mask & ~card_flags;
./atm/solos-pci.c:1084:			struct sk_buff *oldskb = card->tx_skb[port];
./atm/solos-pci.c:1086:				dma_unmap_single(&card->dev->dev, SKB_CB(oldskb)->dma_addr,
./atm/solos-pci.c:1088:				card->tx_skb[port] = NULL;
./atm/solos-pci.c:1090:			spin_lock(&card->tx_queue_lock);
./atm/solos-pci.c:1091:			skb = skb_dequeue(&card->tx_queue[port]);
./atm/solos-pci.c:1093:				card->tx_mask &= ~(1 << port);
./atm/solos-pci.c:1094:			spin_unlock(&card->tx_queue_lock);
./atm/solos-pci.c:1096:			if (skb && !card->using_dma) {
./atm/solos-pci.c:1100:			} else if (skb && card->using_dma) {
./atm/solos-pci.c:1102:				if ((unsigned long)data & card->dma_alignment) {
./atm/solos-pci.c:1103:					data = card->dma_bounce + (BUF_SIZE * port);
./atm/solos-pci.c:1106:				SKB_CB(skb)->dma_addr = dma_map_single(&card->dev->dev, data,
./atm/solos-pci.c:1108:				card->tx_skb[port] = skb;
./atm/solos-pci.c:1110:					  card->config_regs + TX_DMA_ADDR(port));
./atm/solos-pci.c:1122:				dev_info(&card->dev->dev, "Transmitted: port %d\n",
./atm/solos-pci.c:1124:				dev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",
./atm/solos-pci.c:1137:				wake_up(&card->param_wq);
./atm/solos-pci.c:1143:		iowrite32(tx_started, card->config_regs + FLAGS_ADDR);
./atm/solos-pci.c:1145:	spin_unlock_irqrestore(&card->tx_lock, flags);
./atm/solos-pci.c:1157:		dev_warn(&card->dev->dev, "Length of PDU is too large. Dropping PDU.\n");
./atm/solos-pci.c:1171:			dev_warn(&card->dev->dev, "pskb_expand_head failed.\n");
./atm/solos-pci.c:1217:	card->dev = dev;
./atm/solos-pci.c:1218:	init_waitqueue_head(&card->fw_wq);
./atm/solos-pci.c:1219:	init_waitqueue_head(&card->param_wq);
./atm/solos-pci.c:1239:	card->config_regs = pci_iomap(dev, 0, CONFIG_RAM_SIZE);
./atm/solos-pci.c:1240:	if (!card->config_regs) {
./atm/solos-pci.c:1245:	card->buffers = pci_iomap(dev, 1, DATA_RAM_SIZE);
./atm/solos-pci.c:1246:	if (!card->buffers) {
./atm/solos-pci.c:1253:		iowrite32(1, card->config_regs + FPGA_MODE);
./atm/solos-pci.c:1254:		ioread32(card->config_regs + FPGA_MODE);
./atm/solos-pci.c:1256:		iowrite32(0, card->config_regs + FPGA_MODE);
./atm/solos-pci.c:1257:		ioread32(card->config_regs + FPGA_MODE);
./atm/solos-pci.c:1260:	data32 = ioread32(card->config_regs + FPGA_VER);
./atm/solos-pci.c:1264:	card->fpga_version = FPGA_VERSION(major_ver,minor_ver);
./atm/solos-pci.c:1265:	if (card->fpga_version > LEGACY_BUFFERS)
./atm/solos-pci.c:1266:		card->buffer_size = BUF_SIZE;
./atm/solos-pci.c:1268:		card->buffer_size = OLD_BUF_SIZE;
./atm/solos-pci.c:1282:		card->atmel_flash = 1;
./atm/solos-pci.c:1284:		card->atmel_flash = 0;
./atm/solos-pci.c:1286:	data32 = ioread32(card->config_regs + PORTS);
./atm/solos-pci.c:1287:	card->nr_ports = (data32 & 0x000000FF);
./atm/solos-pci.c:1289:	if (card->fpga_version >= DMA_SUPPORTED) {
./atm/solos-pci.c:1291:		card->using_dma = 1;
./atm/solos-pci.c:1293:			card->dma_alignment = 3;
./atm/solos-pci.c:1294:			card->dma_bounce = kmalloc(card->nr_ports * BUF_SIZE, GFP_KERNEL);
./atm/solos-pci.c:1295:			if (!card->dma_bounce) {
./atm/solos-pci.c:1296:				dev_warn(&card->dev->dev, "Failed to allocate DMA bounce buffers\n");
./atm/solos-pci.c:1303:		card->using_dma = 0;
./atm/solos-pci.c:1305:		iowrite32(0xF0, card->config_regs + FLAGS_ADDR);
./atm/solos-pci.c:1310:	tasklet_init(&card->tlet, solos_bh, (unsigned long)card);
./atm/solos-pci.c:1311:	spin_lock_init(&card->tx_lock);
./atm/solos-pci.c:1312:	spin_lock_init(&card->tx_queue_lock);
./atm/solos-pci.c:1313:	spin_lock_init(&card->cli_queue_lock);
./atm/solos-pci.c:1314:	spin_lock_init(&card->param_queue_lock);
./atm/solos-pci.c:1315:	INIT_LIST_HEAD(&card->param_queue);
./atm/solos-pci.c:1320:		dev_dbg(&card->dev->dev, "Failed to request interrupt IRQ: %d\n", dev->irq);
./atm/solos-pci.c:1324:	iowrite32(1, card->config_regs + IRQ_EN_ADDR);
./atm/solos-pci.c:1342:	if (card->fpga_version >= DMA_SUPPORTED &&
./atm/solos-pci.c:1343:	    sysfs_create_group(&card->dev->dev.kobj, &gpio_attr_group))
./atm/solos-pci.c:1344:		dev_err(&card->dev->dev, "Could not register parameter group for GPIOs\n");
./atm/solos-pci.c:1349:	iowrite32(0, card->config_regs + IRQ_EN_ADDR);
./atm/solos-pci.c:1351:	tasklet_kill(&card->tlet);
./atm/solos-pci.c:1354:	kfree(card->dma_bounce);
./atm/solos-pci.c:1355:	pci_iounmap(dev, card->buffers);
./atm/solos-pci.c:1357:	pci_iounmap(dev, card->config_regs);
./atm/solos-pci.c:1369:	for (i = 0; i < card->nr_ports; i++) {
./atm/solos-pci.c:1373:		skb_queue_head_init(&card->tx_queue[i]);
./atm/solos-pci.c:1374:		skb_queue_head_init(&card->cli_queue[i]);
./atm/solos-pci.c:1376:		card->atmdev[i] = atm_dev_register("solos-pci", parent, &fpga_ops, -1, NULL);
./atm/solos-pci.c:1377:		if (!card->atmdev[i]) {
./atm/solos-pci.c:1378:			dev_err(&card->dev->dev, "Could not register ATM device %d\n", i);
./atm/solos-pci.c:1382:		if (device_create_file(&card->atmdev[i]->class_dev, &dev_attr_console))
./atm/solos-pci.c:1383:			dev_err(&card->dev->dev, "Could not register console for ATM device %d\n", i);
./atm/solos-pci.c:1384:		if (sysfs_create_group(&card->atmdev[i]->class_dev.kobj, &solos_attr_group))
./atm/solos-pci.c:1385:			dev_err(&card->dev->dev, "Could not register parameter group for ATM device %d\n", i);
./atm/solos-pci.c:1387:		dev_info(&card->dev->dev, "Registered ATM device %d\n", card->atmdev[i]->number);
./atm/solos-pci.c:1389:		card->atmdev[i]->ci_range.vpi_bits = 8;
./atm/solos-pci.c:1390:		card->atmdev[i]->ci_range.vci_bits = 16;
./atm/solos-pci.c:1391:		card->atmdev[i]->dev_data = card;
./atm/solos-pci.c:1392:		card->atmdev[i]->phy_data = (void *)(unsigned long)i;
./atm/solos-pci.c:1393:		atm_dev_signal_change(card->atmdev[i], ATM_PHY_SIG_FOUND);
./atm/solos-pci.c:1397:			dev_warn(&card->dev->dev, "Failed to allocate sk_buff in atm_init()\n");
./atm/solos-pci.c:1417:	for (i = 0; i < card->nr_ports; i++) {
./atm/solos-pci.c:1418:		if (card->atmdev[i]) {
./atm/solos-pci.c:1421:			dev_info(&card->dev->dev, "Unregistering ATM device %d\n", card->atmdev[i]->number);
./atm/solos-pci.c:1423:			sysfs_remove_group(&card->atmdev[i]->class_dev.kobj, &solos_attr_group);
./atm/solos-pci.c:1424:			atm_dev_deregister(card->atmdev[i]);
./atm/solos-pci.c:1426:			skb = card->rx_skb[i];
./atm/solos-pci.c:1428:				dma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,
./atm/solos-pci.c:1432:			skb = card->tx_skb[i];
./atm/solos-pci.c:1434:				dma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,
./atm/solos-pci.c:1438:			while ((skb = skb_dequeue(&card->tx_queue[i])))
./atm/solos-pci.c:1450:	iowrite32(0, card->config_regs + IRQ_EN_ADDR);
./atm/solos-pci.c:1453:	iowrite32(1, card->config_regs + FPGA_MODE);
./atm/solos-pci.c:1454:	(void)ioread32(card->config_regs + FPGA_MODE); 
./atm/solos-pci.c:1456:	if (card->fpga_version >= DMA_SUPPORTED)
./atm/solos-pci.c:1457:		sysfs_remove_group(&card->dev->dev.kobj, &gpio_attr_group);
./atm/solos-pci.c:1462:	tasklet_kill(&card->tlet);
./atm/solos-pci.c:1464:	kfree(card->dma_bounce);
./atm/solos-pci.c:1467:	iowrite32(0, card->config_regs + FPGA_MODE);
./atm/solos-pci.c:1468:	(void)ioread32(card->config_regs + FPGA_MODE); 
./atm/solos-pci.c:1470:	pci_iounmap(dev, card->buffers);
./atm/solos-pci.c:1471:	pci_iounmap(dev, card->config_regs);
./atm/nicstar.c:204:	i = card->index;
./atm/nicstar.c:209:	if (card->atmdev->phy && card->atmdev->phy->stop)
./atm/nicstar.c:210:		card->atmdev->phy->stop(card->atmdev);
./atm/nicstar.c:213:	writel(0x00000000, card->membase + CFG);
./atm/nicstar.c:216:	atm_dev_deregister(card->atmdev);
./atm/nicstar.c:223:	PRINTK("nicstar%d: freeing %d huge buffers.\n", i, card->hbpool.count);
./atm/nicstar.c:224:	while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL) {
./atm/nicstar.c:231:	       card->iovpool.count);
./atm/nicstar.c:232:	while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL) {
./atm/nicstar.c:237:	while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
./atm/nicstar.c:239:	while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
./atm/nicstar.c:241:	free_scq(card, card->scq0, NULL);
./atm/nicstar.c:243:		if (card->scd2vc[j] != NULL)
./atm/nicstar.c:244:			free_scq(card, card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
./atm/nicstar.c:246:	idr_destroy(&card->idr);
./atm/nicstar.c:247:	dma_free_coherent(&card->pcidev->dev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,
./atm/nicstar.c:248:			  card->rsq.org, card->rsq.dma);
./atm/nicstar.c:249:	dma_free_coherent(&card->pcidev->dev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,
./atm/nicstar.c:250:			  card->tsq.org, card->tsq.dma);
./atm/nicstar.c:251:	free_irq(card->pcidev->irq, card);
./atm/nicstar.c:252:	iounmap(card->membase);
./atm/nicstar.c:315:	spin_lock_irqsave(&card->res_lock, flags);
./atm/nicstar.c:317:	writel(sram_address, card->membase + CMD);
./atm/nicstar.c:319:	data = readl(card->membase + DR0);
./atm/nicstar.c:320:	spin_unlock_irqrestore(&card->res_lock, flags);
./atm/nicstar.c:332:	spin_lock_irqsave(&card->res_lock, flags);
./atm/nicstar.c:335:		writel(*(value++), card->membase + i);
./atm/nicstar.c:337:	   so card->membase + DR0 == card->membase */
./atm/nicstar.c:341:	writel(sram_address, card->membase + CMD);
./atm/nicstar.c:342:	spin_unlock_irqrestore(&card->res_lock, flags);
./atm/nicstar.c:383:	spin_lock_init(&card->int_lock);
./atm/nicstar.c:384:	spin_lock_init(&card->res_lock);
./atm/nicstar.c:388:	card->index = i;
./atm/nicstar.c:389:	card->atmdev = NULL;
./atm/nicstar.c:390:	card->pcidev = pcidev;
./atm/nicstar.c:392:	card->membase = ioremap(membase, NS_IOREMAP_SIZE);
./atm/nicstar.c:393:	if (!card->membase) {
./atm/nicstar.c:399:	PRINTK("nicstar%d: membase at 0x%p.\n", i, card->membase);
./atm/nicstar.c:430:	data = readl(card->membase + STAT);
./atm/nicstar.c:432:		writel(NS_STAT_TMROF, card->membase + STAT);
./atm/nicstar.c:435:	writel(NS_CFG_SWRST, card->membase + CFG);
./atm/nicstar.c:437:	writel(0x00000000, card->membase + CFG);
./atm/nicstar.c:440:	writel(0x00000008, card->membase + GP);
./atm/nicstar.c:442:	writel(0x00000001, card->membase + GP);
./atm/nicstar.c:445:	writel(NS_CMD_WRITE_UTILITY | 0x00000100, card->membase + CMD);	/* Sync UTOPIA with SAR clock */
./atm/nicstar.c:450:	writel(NS_CMD_READ_UTILITY | 0x00000200, card->membase + CMD);
./atm/nicstar.c:452:	data = readl(card->membase + DR0);
./atm/nicstar.c:456:		card->max_pcr = ATM_25_PCR;
./atm/nicstar.c:458:		writel(0x00000008, card->membase + DR0);
./atm/nicstar.c:459:		writel(NS_CMD_WRITE_UTILITY | 0x00000200, card->membase + CMD);
./atm/nicstar.c:461:		writel(NS_STAT_SFBQF, card->membase + STAT);
./atm/nicstar.c:464:		writel(0x00000022, card->membase + DR0);
./atm/nicstar.c:465:		writel(NS_CMD_WRITE_UTILITY | 0x00000202, card->membase + CMD);
./atm/nicstar.c:471:		card->max_pcr = ATM_OC3_PCR;
./atm/nicstar.c:474:		writel(0x00000002, card->membase + DR0);
./atm/nicstar.c:475:		writel(NS_CMD_WRITE_UTILITY | 0x00000205, card->membase + CMD);
./atm/nicstar.c:484:	writel(0x00000000, card->membase + GP);
./atm/nicstar.c:493:		card->sram_size = 128;
./atm/nicstar.c:495:		card->sram_size = 32;
./atm/nicstar.c:496:	PRINTK("nicstar%d: %dK x 32bit SRAM size.\n", i, card->sram_size);
./atm/nicstar.c:498:	card->rct_size = NS_MAX_RCTSIZE;
./atm/nicstar.c:501:	if (card->sram_size == 128)
./atm/nicstar.c:506:	if (card->sram_size == 32) {
./atm/nicstar.c:510:		card->rct_size = 4096;
./atm/nicstar.c:516:	card->vpibits = NS_VPIBITS;
./atm/nicstar.c:517:	if (card->rct_size == 4096)
./atm/nicstar.c:518:		card->vcibits = 12 - NS_VPIBITS;
./atm/nicstar.c:519:	else			/* card->rct_size == 16384 */
./atm/nicstar.c:520:		card->vcibits = 14 - NS_VPIBITS;
./atm/nicstar.c:524:		nicstar_init_eprom(card->membase);
./atm/nicstar.c:527:	writel(0x00000000, card->membase + VPM);
./atm/nicstar.c:530:	card->tsq.org = dma_alloc_coherent(&card->pcidev->dev,
./atm/nicstar.c:532:					   &card->tsq.dma, GFP_KERNEL);
./atm/nicstar.c:533:	if (card->tsq.org == NULL) {
./atm/nicstar.c:539:	card->tsq.base = PTR_ALIGN(card->tsq.org, NS_TSQ_ALIGNMENT);
./atm/nicstar.c:540:	card->tsq.next = card->tsq.base;
./atm/nicstar.c:541:	card->tsq.last = card->tsq.base + (NS_TSQ_NUM_ENTRIES - 1);
./atm/nicstar.c:543:		ns_tsi_init(card->tsq.base + j);
./atm/nicstar.c:544:	writel(0x00000000, card->membase + TSQH);
./atm/nicstar.c:545:	writel(ALIGN(card->tsq.dma, NS_TSQ_ALIGNMENT), card->membase + TSQB);
./atm/nicstar.c:546:	PRINTK("nicstar%d: TSQ base at 0x%p.\n", i, card->tsq.base);
./atm/nicstar.c:549:	card->rsq.org = dma_alloc_coherent(&card->pcidev->dev,
./atm/nicstar.c:551:					   &card->rsq.dma, GFP_KERNEL);
./atm/nicstar.c:552:	if (card->rsq.org == NULL) {
./atm/nicstar.c:558:	card->rsq.base = PTR_ALIGN(card->rsq.org, NS_RSQ_ALIGNMENT);
./atm/nicstar.c:559:	card->rsq.next = card->rsq.base;
./atm/nicstar.c:560:	card->rsq.last = card->rsq.base + (NS_RSQ_NUM_ENTRIES - 1);
./atm/nicstar.c:562:		ns_rsqe_init(card->rsq.base + j);
./atm/nicstar.c:563:	writel(0x00000000, card->membase + RSQH);
./atm/nicstar.c:564:	writel(ALIGN(card->rsq.dma, NS_RSQ_ALIGNMENT), card->membase + RSQB);
./atm/nicstar.c:565:	PRINTK("nicstar%d: RSQ base at 0x%p.\n", i, card->rsq.base);
./atm/nicstar.c:568:	card->scq1 = NULL;
./atm/nicstar.c:569:	card->scq2 = NULL;
./atm/nicstar.c:570:	card->scq0 = get_scq(card, VBR_SCQSIZE, NS_VRSCD0);
./atm/nicstar.c:571:	if (card->scq0 == NULL) {
./atm/nicstar.c:577:	u32d[0] = scq_virt_to_bus(card->scq0, card->scq0->base);
./atm/nicstar.c:584:	card->scq0->scd = NS_VRSCD0;
./atm/nicstar.c:585:	PRINTK("nicstar%d: VBR-SCQ0 base at 0x%p.\n", i, card->scq0->base);
./atm/nicstar.c:588:	card->tst_addr = NS_TST0;
./atm/nicstar.c:589:	card->tst_free_entries = NS_TST_NUM_ENTRIES;
./atm/nicstar.c:600:		card->tste2vc[j] = NULL;
./atm/nicstar.c:601:	writel(NS_TST0 << 2, card->membase + TSTB);
./atm/nicstar.c:612:	for (j = 0; j < card->rct_size; j++)
./atm/nicstar.c:615:	memset(card->vcmap, 0, sizeof(card->vcmap));
./atm/nicstar.c:618:		card->scd2vc[j] = NULL;
./atm/nicstar.c:621:	card->sbnr.min = MIN_SB;
./atm/nicstar.c:622:	card->sbnr.init = NUM_SB;
./atm/nicstar.c:623:	card->sbnr.max = MAX_SB;
./atm/nicstar.c:624:	card->lbnr.min = MIN_LB;
./atm/nicstar.c:625:	card->lbnr.init = NUM_LB;
./atm/nicstar.c:626:	card->lbnr.max = MAX_LB;
./atm/nicstar.c:627:	card->iovnr.min = MIN_IOVB;
./atm/nicstar.c:628:	card->iovnr.init = NUM_IOVB;
./atm/nicstar.c:629:	card->iovnr.max = MAX_IOVB;
./atm/nicstar.c:630:	card->hbnr.min = MIN_HB;
./atm/nicstar.c:631:	card->hbnr.init = NUM_HB;
./atm/nicstar.c:632:	card->hbnr.max = MAX_HB;
./atm/nicstar.c:634:	card->sm_handle = NULL;
./atm/nicstar.c:635:	card->sm_addr = 0x00000000;
./atm/nicstar.c:636:	card->lg_handle = NULL;
./atm/nicstar.c:637:	card->lg_addr = 0x00000000;
./atm/nicstar.c:639:	card->efbie = 1;	/* To prevent push_rxbufs from enabling the interrupt */
./atm/nicstar.c:641:	idr_init(&card->idr);
./atm/nicstar.c:644:	skb_queue_head_init(&card->hbpool.queue);
./atm/nicstar.c:645:	card->hbpool.count = 0;
./atm/nicstar.c:658:		skb_queue_tail(&card->hbpool.queue, hb);
./atm/nicstar.c:659:		card->hbpool.count++;
./atm/nicstar.c:663:	skb_queue_head_init(&card->lbpool.queue);
./atm/nicstar.c:664:	card->lbpool.count = 0;	/* Not used */
./atm/nicstar.c:677:		skb_queue_tail(&card->lbpool.queue, lb);
./atm/nicstar.c:682:			card->rcbuf = lb;
./atm/nicstar.c:683:			card->rawcell = (struct ns_rcqe *) lb->data;
./atm/nicstar.c:684:			card->rawch = NS_PRV_DMA(lb);
./atm/nicstar.c:689:	     ns_stat_lfbqc_get(readl(card->membase + STAT))) < card->lbnr.min) {
./atm/nicstar.c:699:	skb_queue_head_init(&card->sbpool.queue);
./atm/nicstar.c:700:	card->sbpool.count = 0;	/* Not used */
./atm/nicstar.c:713:		skb_queue_tail(&card->sbpool.queue, sb);
./atm/nicstar.c:719:	     ns_stat_sfbqc_get(readl(card->membase + STAT))) < card->sbnr.min) {
./atm/nicstar.c:729:	skb_queue_head_init(&card->iovpool.queue);
./atm/nicstar.c:730:	card->iovpool.count = 0;
./atm/nicstar.c:743:		skb_queue_tail(&card->iovpool.queue, iovb);
./atm/nicstar.c:744:		card->iovpool.count++;
./atm/nicstar.c:748:	if (card->rct_size == 4096)
./atm/nicstar.c:750:	else			/* (card->rct_size == 16384) */
./atm/nicstar.c:753:	card->efbie = 1;
./atm/nicstar.c:755:	card->intcnt = 0;
./atm/nicstar.c:765:	card->atmdev = atm_dev_register("nicstar", &card->pcidev->dev, &atm_ops,
./atm/nicstar.c:767:	if (card->atmdev == NULL) {
./atm/nicstar.c:774:	if (mac[i] == NULL || !mac_pton(mac[i], card->atmdev->esi)) {
./atm/nicstar.c:775:		nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,
./atm/nicstar.c:776:				   card->atmdev->esi, 6);
./atm/nicstar.c:777:		if (ether_addr_equal(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00")) {
./atm/nicstar.c:778:			nicstar_read_eprom(card->membase,
./atm/nicstar.c:780:					   card->atmdev->esi, 6);
./atm/nicstar.c:784:	printk("nicstar%d: MAC address %pM\n", i, card->atmdev->esi);
./atm/nicstar.c:786:	card->atmdev->dev_data = card;
./atm/nicstar.c:787:	card->atmdev->ci_range.vpi_bits = card->vpibits;
./atm/nicstar.c:788:	card->atmdev->ci_range.vci_bits = card->vcibits;
./atm/nicstar.c:789:	card->atmdev->link_rate = card->max_pcr;
./atm/nicstar.c:790:	card->atmdev->phy = NULL;
./atm/nicstar.c:793:	if (card->max_pcr == ATM_OC3_PCR)
./atm/nicstar.c:794:		suni_init(card->atmdev);
./atm/nicstar.c:798:	if (card->max_pcr == ATM_25_PCR)
./atm/nicstar.c:799:		idt77105_init(card->atmdev);
./atm/nicstar.c:802:	if (card->atmdev->phy && card->atmdev->phy->start)
./atm/nicstar.c:803:		card->atmdev->phy->start(card->atmdev);
./atm/nicstar.c:807:	       NS_CFG_PHYIE, card->membase + CFG);
./atm/nicstar.c:817:		writel(0x00000000, card->membase + CFG);
./atm/nicstar.c:821:		while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
./atm/nicstar.c:826:		while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
./atm/nicstar.c:828:		free_scq(card, card->scq0, NULL);
./atm/nicstar.c:832:		while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
./atm/nicstar.c:837:		while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
./atm/nicstar.c:841:		kfree(card->rsq.org);
./atm/nicstar.c:844:		kfree(card->tsq.org);
./atm/nicstar.c:847:		free_irq(card->pcidev->irq, card);
./atm/nicstar.c:850:		iounmap(card->membase);
./atm/nicstar.c:853:		pci_disable_device(card->pcidev);
./atm/nicstar.c:869:        scq->org = dma_alloc_coherent(&card->pcidev->dev,
./atm/nicstar.c:879:		dma_free_coherent(&card->pcidev->dev,
./atm/nicstar.c:934:	dma_free_coherent(&card->pcidev->dev,
./atm/nicstar.c:955:	addr1 = dma_map_single(&card->pcidev->dev,
./atm/nicstar.c:965:		       card->index);
./atm/nicstar.c:968:	stat = readl(card->membase + STAT);
./atm/nicstar.c:969:	card->sbfqc = ns_stat_sfbqc_get(stat);
./atm/nicstar.c:970:	card->lbfqc = ns_stat_lfbqc_get(stat);
./atm/nicstar.c:973:			if (card->sm_addr) {
./atm/nicstar.c:974:				addr2 = card->sm_addr;
./atm/nicstar.c:975:				handle2 = card->sm_handle;
./atm/nicstar.c:976:				card->sm_addr = 0x00000000;
./atm/nicstar.c:977:				card->sm_handle = NULL;
./atm/nicstar.c:980:				card->sm_addr = addr1;
./atm/nicstar.c:981:				card->sm_handle = handle1;
./atm/nicstar.c:987:			if (card->lg_addr) {
./atm/nicstar.c:988:				addr2 = card->lg_addr;
./atm/nicstar.c:989:				handle2 = card->lg_handle;
./atm/nicstar.c:990:				card->lg_addr = 0x00000000;
./atm/nicstar.c:991:				card->lg_handle = NULL;
./atm/nicstar.c:994:				card->lg_addr = addr1;
./atm/nicstar.c:995:				card->lg_handle = handle1;
./atm/nicstar.c:1002:			if (card->sbfqc >= card->sbnr.max) {
./atm/nicstar.c:1003:				skb_unlink(handle1, &card->sbpool.queue);
./atm/nicstar.c:1005:				skb_unlink(handle2, &card->sbpool.queue);
./atm/nicstar.c:1009:				card->sbfqc += 2;
./atm/nicstar.c:1012:			if (card->lbfqc >= card->lbnr.max) {
./atm/nicstar.c:1013:				skb_unlink(handle1, &card->lbpool.queue);
./atm/nicstar.c:1015:				skb_unlink(handle2, &card->lbpool.queue);
./atm/nicstar.c:1019:				card->lbfqc += 2;
./atm/nicstar.c:1022:		id1 = idr_alloc(&card->idr, handle1, 0, 0, GFP_ATOMIC);
./atm/nicstar.c:1026:		id2 = idr_alloc(&card->idr, handle2, 0, 0, GFP_ATOMIC);
./atm/nicstar.c:1030:		spin_lock_irqsave(&card->res_lock, flags);
./atm/nicstar.c:1032:		writel(addr2, card->membase + DR3);
./atm/nicstar.c:1033:		writel(id2, card->membase + DR2);
./atm/nicstar.c:1034:		writel(addr1, card->membase + DR1);
./atm/nicstar.c:1035:		writel(id1, card->membase + DR0);
./atm/nicstar.c:1037:		       card->membase + CMD);
./atm/nicstar.c:1038:		spin_unlock_irqrestore(&card->res_lock, flags);
./atm/nicstar.c:1041:			card->index,
./atm/nicstar.c:1046:	if (!card->efbie && card->sbfqc >= card->sbnr.min &&
./atm/nicstar.c:1047:	    card->lbfqc >= card->lbnr.min) {
./atm/nicstar.c:1048:		card->efbie = 1;
./atm/nicstar.c:1049:		writel((readl(card->membase + CFG) | NS_CFG_EFBIE),
./atm/nicstar.c:1050:		       card->membase + CFG);
./atm/nicstar.c:1065:	dev = card->atmdev;
./atm/nicstar.c:1066:	card->intcnt++;
./atm/nicstar.c:1068:	PRINTK("nicstar%d: NICStAR generated an interrupt\n", card->index);
./atm/nicstar.c:1070:	spin_lock_irqsave(&card->int_lock, flags);
./atm/nicstar.c:1072:	stat_r = readl(card->membase + STAT);
./atm/nicstar.c:1076:		TXPRINTK("nicstar%d: TSI interrupt\n", card->index);
./atm/nicstar.c:1078:		writel(NS_STAT_TSIF, card->membase + STAT);
./atm/nicstar.c:1083:		writel(NS_STAT_TXICP, card->membase + STAT);
./atm/nicstar.c:1085:			 card->index);
./atm/nicstar.c:1090:		writel(NS_STAT_TSQF, card->membase + STAT);
./atm/nicstar.c:1091:		PRINTK("nicstar%d: TSQ full.\n", card->index);
./atm/nicstar.c:1097:		writel(NS_STAT_TMROF, card->membase + STAT);
./atm/nicstar.c:1098:		PRINTK("nicstar%d: Timer overflow.\n", card->index);
./atm/nicstar.c:1103:		writel(NS_STAT_PHYI, card->membase + STAT);
./atm/nicstar.c:1104:		PRINTK("nicstar%d: PHY interrupt.\n", card->index);
./atm/nicstar.c:1112:		writel(NS_STAT_SFBQF, card->membase + STAT);
./atm/nicstar.c:1114:		       card->index);
./atm/nicstar.c:1119:		writel(NS_STAT_LFBQF, card->membase + STAT);
./atm/nicstar.c:1121:		       card->index);
./atm/nicstar.c:1126:		writel(NS_STAT_RSQF, card->membase + STAT);
./atm/nicstar.c:1127:		printk("nicstar%d: RSQ full.\n", card->index);
./atm/nicstar.c:1133:		RXPRINTK("nicstar%d: End of CS-PDU received.\n", card->index);
./atm/nicstar.c:1135:		writel(NS_STAT_EOPDU, card->membase + STAT);
./atm/nicstar.c:1140:		writel(NS_STAT_RAWCF, card->membase + STAT);
./atm/nicstar.c:1143:		       card->index);
./atm/nicstar.c:1148:		while (readl(card->membase + RAWCT) != card->rawch) {
./atm/nicstar.c:1150:			if (ns_rcqe_islast(card->rawcell)) {
./atm/nicstar.c:1153:				oldbuf = card->rcbuf;
./atm/nicstar.c:1154:				card->rcbuf = idr_find(&card->idr,
./atm/nicstar.c:1155:						       ns_rcqe_nextbufhandle(card->rawcell));
./atm/nicstar.c:1156:				card->rawch = NS_PRV_DMA(card->rcbuf);
./atm/nicstar.c:1157:				card->rawcell = (struct ns_rcqe *)
./atm/nicstar.c:1158:						card->rcbuf->data;
./atm/nicstar.c:1161:				card->rawch += NS_RCQE_SIZE;
./atm/nicstar.c:1162:				card->rawcell++;
./atm/nicstar.c:1172:		writel(NS_STAT_SFBQE, card->membase + STAT);
./atm/nicstar.c:1174:		       card->index);
./atm/nicstar.c:1175:		for (i = 0; i < card->sbnr.min; i++) {
./atm/nicstar.c:1178:				writel(readl(card->membase + CFG) &
./atm/nicstar.c:1179:				       ~NS_CFG_EFBIE, card->membase + CFG);
./atm/nicstar.c:1180:				card->efbie = 0;
./atm/nicstar.c:1184:			skb_queue_tail(&card->sbpool.queue, sb);
./atm/nicstar.c:1188:		card->sbfqc = i;
./atm/nicstar.c:1197:		writel(NS_STAT_LFBQE, card->membase + STAT);
./atm/nicstar.c:1199:		       card->index);
./atm/nicstar.c:1200:		for (i = 0; i < card->lbnr.min; i++) {
./atm/nicstar.c:1203:				writel(readl(card->membase + CFG) &
./atm/nicstar.c:1204:				       ~NS_CFG_EFBIE, card->membase + CFG);
./atm/nicstar.c:1205:				card->efbie = 0;
./atm/nicstar.c:1209:			skb_queue_tail(&card->lbpool.queue, lb);
./atm/nicstar.c:1213:		card->lbfqc = i;
./atm/nicstar.c:1219:		writel(NS_STAT_RSQAF, card->membase + STAT);
./atm/nicstar.c:1220:		RXPRINTK("nicstar%d: RSQ almost full.\n", card->index);
./atm/nicstar.c:1224:	spin_unlock_irqrestore(&card->int_lock, flags);
./atm/nicstar.c:1225:	PRINTK("nicstar%d: end of interrupt service\n", card->index);
./atm/nicstar.c:1247:	PRINTK("nicstar%d: opening vpi.vci %d.%d \n", card->index, (int)vpi,
./atm/nicstar.c:1250:		PRINTK("nicstar%d: unsupported AAL.\n", card->index);
./atm/nicstar.c:1254:	vc = &(card->vcmap[vpi << card->vcibits | vci]);
./atm/nicstar.c:1263:		printk("nicstar%d: %s vci already in use.\n", card->index,
./atm/nicstar.c:1283:				     card->index);
./atm/nicstar.c:1293:			       card->index, vcc->qos.txtp.max_pcr);
./atm/nicstar.c:1298:			modl = tmpl % card->max_pcr;
./atm/nicstar.c:1300:			n = (int)(tmpl / card->max_pcr);
./atm/nicstar.c:1306:				     (card->tst_free_entries -
./atm/nicstar.c:1310:					     card->index);
./atm/nicstar.c:1320:				     card->index);
./atm/nicstar.c:1326:			if (n > (card->tst_free_entries - NS_TST_RESERVED)) {
./atm/nicstar.c:1329:				     card->index);
./atm/nicstar.c:1334:				card->tst_free_entries -= n;
./atm/nicstar.c:1337:				card->index, n);
./atm/nicstar.c:1339:				if (card->scd2vc[frscdi] == NULL) {
./atm/nicstar.c:1340:					card->scd2vc[frscdi] = vc;
./atm/nicstar.c:1347:				     card->index);
./atm/nicstar.c:1348:				card->tst_free_entries += n;
./atm/nicstar.c:1359:				       card->index);
./atm/nicstar.c:1360:				card->scd2vc[frscdi] = NULL;
./atm/nicstar.c:1361:				card->tst_free_entries += n;
./atm/nicstar.c:1376:			vc->scq = card->scq0;
./atm/nicstar.c:1401:				      (vpi << card->vcibits | vci) *
./atm/nicstar.c:1420:	PRINTK("nicstar%d: closing vpi.vci %d.%d \n", card->index,
./atm/nicstar.c:1431:		    (vcc->vpi << card->vcibits | vcc->vci) * NS_RCT_ENTRY_SIZE;
./atm/nicstar.c:1432:		spin_lock_irqsave(&card->res_lock, flags);
./atm/nicstar.c:1435:		       card->membase + CMD);
./atm/nicstar.c:1436:		spin_unlock_irqrestore(&card->res_lock, flags);
./atm/nicstar.c:1443:			stat = readl(card->membase + STAT);
./atm/nicstar.c:1444:			card->sbfqc = ns_stat_sfbqc_get(stat);
./atm/nicstar.c:1445:			card->lbfqc = ns_stat_lfbqc_get(stat);
./atm/nicstar.c:1449:			     card->index);
./atm/nicstar.c:1454:			spin_lock_irqsave(&card->int_lock, flags);
./atm/nicstar.c:1456:			spin_unlock_irqrestore(&card->int_lock, flags);
./atm/nicstar.c:1514:			if (card->tste2vc[i] == vc) {
./atm/nicstar.c:1515:				ns_write_sram(card, card->tst_addr + i, &data,
./atm/nicstar.c:1517:				card->tste2vc[i] = NULL;
./atm/nicstar.c:1518:				card->tst_free_entries++;
./atm/nicstar.c:1522:		card->scd2vc[(vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE] = NULL;
./atm/nicstar.c:1529:		scq_info *scq = card->scq0;
./atm/nicstar.c:1552:		stat = readl(card->membase + STAT);
./atm/nicstar.c:1553:		cfg = readl(card->membase + CFG);
./atm/nicstar.c:1557:		     card->tsq.base, card->tsq.next,
./atm/nicstar.c:1558:		     card->tsq.last, readl(card->membase + TSQT));
./atm/nicstar.c:1561:		     card->rsq.base, card->rsq.next,
./atm/nicstar.c:1562:		     card->rsq.last, readl(card->membase + RSQT));
./atm/nicstar.c:1564:		       card->efbie ? "enabled" : "disabled");
./atm/nicstar.c:1566:		       ns_stat_sfbqc_get(stat), card->sbpool.count,
./atm/nicstar.c:1567:		       ns_stat_lfbqc_get(stat), card->lbpool.count);
./atm/nicstar.c:1569:		       card->hbpool.count, card->iovpool.count);
./atm/nicstar.c:1585:	new_tst = card->tst_addr;
./atm/nicstar.c:1590:		if (card->tste2vc[e] == NULL)
./atm/nicstar.c:1594:		printk("nicstar%d: No free TST entries found. \n", card->index);
./atm/nicstar.c:1603:		if (cl >= NS_TST_NUM_ENTRIES && card->tste2vc[e] == NULL) {
./atm/nicstar.c:1604:			card->tste2vc[e] = vc;
./atm/nicstar.c:1620:	ns_write_sram(card, card->tst_addr + NS_TST_NUM_ENTRIES, &data, 1);
./atm/nicstar.c:1621:	card->tst_addr = new_tst;
./atm/nicstar.c:1634:	TXPRINTK("nicstar%d: ns_send() called.\n", card->index);
./atm/nicstar.c:1637:		       card->index);
./atm/nicstar.c:1645:		       card->index);
./atm/nicstar.c:1653:		       card->index);
./atm/nicstar.c:1660:		printk("nicstar%d: No scatter-gather yet.\n", card->index);
./atm/nicstar.c:1668:	NS_PRV_DMA(skb) = dma_map_single(&card->pcidev->dev, skb->data,
./atm/nicstar.c:1705:		scq = card->scq0;
./atm/nicstar.c:1732:			printk("nicstar%d: Error pushing TBD.\n", card->index);
./atm/nicstar.c:1745:			       card->index);
./atm/nicstar.c:1753:		card->index, skb, index);
./atm/nicstar.c:1755:		card->index, le32_to_cpu(tbd->word_1), le32_to_cpu(tbd->word_2),
./atm/nicstar.c:1780:				       card->index);
./atm/nicstar.c:1809:			     card->index, le32_to_cpu(tsr.word_1),
./atm/nicstar.c:1820:			       card->index);
./atm/nicstar.c:1839:	if (card->tsq.next == card->tsq.last)
./atm/nicstar.c:1840:		one_ahead = card->tsq.base;
./atm/nicstar.c:1842:		one_ahead = card->tsq.next + 1;
./atm/nicstar.c:1844:	if (one_ahead == card->tsq.last)
./atm/nicstar.c:1845:		two_ahead = card->tsq.base;
./atm/nicstar.c:1849:	while (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||
./atm/nicstar.c:1856:		while (ns_tsi_isempty(card->tsq.next)) {
./atm/nicstar.c:1857:			if (card->tsq.next == card->tsq.last)
./atm/nicstar.c:1858:				card->tsq.next = card->tsq.base;
./atm/nicstar.c:1860:				card->tsq.next++;
./atm/nicstar.c:1863:		if (!ns_tsi_tmrof(card->tsq.next)) {
./atm/nicstar.c:1864:			scdi = ns_tsi_getscdindex(card->tsq.next);
./atm/nicstar.c:1866:				scq = card->scq0;
./atm/nicstar.c:1868:				if (card->scd2vc[scdi] == NULL) {
./atm/nicstar.c:1871:					     card->index);
./atm/nicstar.c:1872:					ns_tsi_init(card->tsq.next);
./atm/nicstar.c:1875:				scq = card->scd2vc[scdi]->scq;
./atm/nicstar.c:1877:			drain_scq(card, scq, ns_tsi_getscqpos(card->tsq.next));
./atm/nicstar.c:1882:		ns_tsi_init(card->tsq.next);
./atm/nicstar.c:1883:		previous = card->tsq.next;
./atm/nicstar.c:1884:		if (card->tsq.next == card->tsq.last)
./atm/nicstar.c:1885:			card->tsq.next = card->tsq.base;
./atm/nicstar.c:1887:			card->tsq.next++;
./atm/nicstar.c:1889:		if (card->tsq.next == card->tsq.last)
./atm/nicstar.c:1890:			one_ahead = card->tsq.base;
./atm/nicstar.c:1892:			one_ahead = card->tsq.next + 1;
./atm/nicstar.c:1894:		if (one_ahead == card->tsq.last)
./atm/nicstar.c:1895:			two_ahead = card->tsq.base;
./atm/nicstar.c:1901:		writel(PTR_DIFF(previous, card->tsq.base),
./atm/nicstar.c:1902:		       card->membase + TSQH);
./atm/nicstar.c:1913:		card->index, scq, pos);
./atm/nicstar.c:1915:		printk("nicstar%d: Bad index on drain_scq().\n", card->index);
./atm/nicstar.c:1926:			card->index, skb, i);
./atm/nicstar.c:1928:			dma_unmap_single(&card->pcidev->dev,
./atm/nicstar.c:1951:	if (!ns_rsqe_valid(card->rsq.next))
./atm/nicstar.c:1954:		dequeue_rx(card, card->rsq.next);
./atm/nicstar.c:1955:		ns_rsqe_init(card->rsq.next);
./atm/nicstar.c:1956:		previous = card->rsq.next;
./atm/nicstar.c:1957:		if (card->rsq.next == card->rsq.last)
./atm/nicstar.c:1958:			card->rsq.next = card->rsq.base;
./atm/nicstar.c:1960:			card->rsq.next++;
./atm/nicstar.c:1961:	} while (ns_rsqe_valid(card->rsq.next));
./atm/nicstar.c:1962:	writel(PTR_DIFF(previous, card->rsq.base), card->membase + RSQH);
./atm/nicstar.c:1978:	stat = readl(card->membase + STAT);
./atm/nicstar.c:1979:	card->sbfqc = ns_stat_sfbqc_get(stat);
./atm/nicstar.c:1980:	card->lbfqc = ns_stat_lfbqc_get(stat);
./atm/nicstar.c:1983:	skb = idr_remove(&card->idr, id);
./atm/nicstar.c:1986:			 "nicstar%d: skb not found!\n", card->index);
./atm/nicstar.c:1989:	dma_sync_single_for_cpu(&card->pcidev->dev,
./atm/nicstar.c:1994:	dma_unmap_single(&card->pcidev->dev,
./atm/nicstar.c:2001:	if (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits) {
./atm/nicstar.c:2003:		       card->index, vpi, vci);
./atm/nicstar.c:2008:	vc = &(card->vcmap[vpi << card->vcibits | vci]);
./atm/nicstar.c:2011:			 card->index, vpi, vci);
./atm/nicstar.c:2029:				     card->index);
./atm/nicstar.c:2036:				     card->index);
./atm/nicstar.c:2063:		iovb = skb_dequeue(&(card->iovpool.queue));
./atm/nicstar.c:2068:				       card->index);
./atm/nicstar.c:2074:		} else if (--card->iovpool.count < card->iovnr.min) {
./atm/nicstar.c:2079:				skb_queue_tail(&card->iovpool.queue, new_iovb);
./atm/nicstar.c:2080:				card->iovpool.count++;
./atm/nicstar.c:2092:		printk("nicstar%d: received too big AAL5 SDU.\n", card->index);
./atm/nicstar.c:2111:			     card->index);
./atm/nicstar.c:2124:			     card->index);
./atm/nicstar.c:2144:			printk("nicstar%d: AAL5 CRC error", card->index);
./atm/nicstar.c:2220:			hb = skb_dequeue(&(card->hbpool.queue));
./atm/nicstar.c:2227:					     card->index);
./atm/nicstar.c:2236:				} else if (card->hbpool.count < card->hbnr.min) {
./atm/nicstar.c:2241:						skb_queue_tail(&card->hbpool.
./atm/nicstar.c:2243:						card->hbpool.count++;
./atm/nicstar.c:2247:			} else if (--card->hbpool.count < card->hbnr.min) {
./atm/nicstar.c:2252:					skb_queue_tail(&card->hbpool.queue,
./atm/nicstar.c:2254:					card->hbpool.count++;
./atm/nicstar.c:2256:				if (card->hbpool.count < card->hbnr.min) {
./atm/nicstar.c:2262:						skb_queue_tail(&card->hbpool.
./atm/nicstar.c:2264:						card->hbpool.count++;
./atm/nicstar.c:2274:				if (card->hbpool.count < card->hbnr.max) {
./atm/nicstar.c:2275:					skb_queue_tail(&card->hbpool.queue, hb);
./atm/nicstar.c:2276:					card->hbpool.count++;
./atm/nicstar.c:2308:					     card->index);
./atm/nicstar.c:2327:		       card->index);
./atm/nicstar.c:2341:	if (card->iovpool.count < card->iovnr.max) {
./atm/nicstar.c:2342:		skb_queue_tail(&card->iovpool.queue, iovb);
./atm/nicstar.c:2343:		card->iovpool.count++;
./atm/nicstar.c:2350:	skb_unlink(sb, &card->sbpool.queue);
./atm/nicstar.c:2351:	if (card->sbfqc < card->sbnr.init) {
./atm/nicstar.c:2355:			skb_queue_tail(&card->sbpool.queue, new_sb);
./atm/nicstar.c:2360:	if (card->sbfqc < card->sbnr.init)
./atm/nicstar.c:2365:			skb_queue_tail(&card->sbpool.queue, new_sb);
./atm/nicstar.c:2374:	skb_unlink(lb, &card->lbpool.queue);
./atm/nicstar.c:2375:	if (card->lbfqc < card->lbnr.init) {
./atm/nicstar.c:2379:			skb_queue_tail(&card->lbpool.queue, new_lb);
./atm/nicstar.c:2384:	if (card->lbfqc < card->lbnr.init)
./atm/nicstar.c:2389:			skb_queue_tail(&card->lbpool.queue, new_lb);
./atm/nicstar.c:2404:	stat = readl(card->membase + STAT);
./atm/nicstar.c:2409:			       ns_stat_sfbqc_get(stat), card->sbnr.min,
./atm/nicstar.c:2410:			       card->sbnr.init, card->sbnr.max);
./atm/nicstar.c:2413:			       ns_stat_lfbqc_get(stat), card->lbnr.min,
./atm/nicstar.c:2414:			       card->lbnr.init, card->lbnr.max);
./atm/nicstar.c:2417:			       card->hbpool.count, card->hbnr.min,
./atm/nicstar.c:2418:			       card->hbnr.init, card->hbnr.max);
./atm/nicstar.c:2421:			       card->iovpool.count, card->iovnr.min,
./atm/nicstar.c:2422:			       card->iovnr.init, card->iovnr.max);
./atm/nicstar.c:2426:		    sprintf(page, "Interrupt counter: %u \n", card->intcnt);
./atm/nicstar.c:2427:		card->intcnt = 0;
./atm/nicstar.c:2434:	if (card->max_pcr == ATM_25_PCR && !left--) {
./atm/nicstar.c:2441:			       card->membase + CMD);
./atm/nicstar.c:2443:			phy_regs[i] = readl(card->membase + DR0) & 0x000000FF;
./atm/nicstar.c:2454:		if (card->tste2vc[left + 1] == NULL)
./atm/nicstar.c:2458:				       card->tste2vc[left + 1]->tx_vcc->vpi,
./atm/nicstar.c:2459:				       card->tste2vc[left + 1]->tx_vcc->vci);
./atm/nicstar.c:2481:			    ns_stat_sfbqc_get(readl(card->membase + STAT));
./atm/nicstar.c:2482:			pl.level.min = card->sbnr.min;
./atm/nicstar.c:2483:			pl.level.init = card->sbnr.init;
./atm/nicstar.c:2484:			pl.level.max = card->sbnr.max;
./atm/nicstar.c:2489:			    ns_stat_lfbqc_get(readl(card->membase + STAT));
./atm/nicstar.c:2490:			pl.level.min = card->lbnr.min;
./atm/nicstar.c:2491:			pl.level.init = card->lbnr.init;
./atm/nicstar.c:2492:			pl.level.max = card->lbnr.max;
./atm/nicstar.c:2496:			pl.count = card->hbpool.count;
./atm/nicstar.c:2497:			pl.level.min = card->hbnr.min;
./atm/nicstar.c:2498:			pl.level.init = card->hbnr.init;
./atm/nicstar.c:2499:			pl.level.max = card->hbnr.max;
./atm/nicstar.c:2503:			pl.count = card->iovpool.count;
./atm/nicstar.c:2504:			pl.level.min = card->iovnr.min;
./atm/nicstar.c:2505:			pl.level.init = card->iovnr.init;
./atm/nicstar.c:2506:			pl.level.max = card->iovnr.max;
./atm/nicstar.c:2532:			card->sbnr.min = pl.level.min;
./atm/nicstar.c:2533:			card->sbnr.init = pl.level.init;
./atm/nicstar.c:2534:			card->sbnr.max = pl.level.max;
./atm/nicstar.c:2540:			card->lbnr.min = pl.level.min;
./atm/nicstar.c:2541:			card->lbnr.init = pl.level.init;
./atm/nicstar.c:2542:			card->lbnr.max = pl.level.max;
./atm/nicstar.c:2548:			card->hbnr.min = pl.level.min;
./atm/nicstar.c:2549:			card->hbnr.init = pl.level.init;
./atm/nicstar.c:2550:			card->hbnr.max = pl.level.max;
./atm/nicstar.c:2556:			card->iovnr.min = pl.level.min;
./atm/nicstar.c:2557:			card->iovnr.init = pl.level.init;
./atm/nicstar.c:2558:			card->iovnr.max = pl.level.max;
./atm/nicstar.c:2573:			while (card->sbfqc < card->sbnr.init) {
./atm/nicstar.c:2580:				skb_queue_tail(&card->sbpool.queue, sb);
./atm/nicstar.c:2587:			while (card->lbfqc < card->lbnr.init) {
./atm/nicstar.c:2594:				skb_queue_tail(&card->lbpool.queue, lb);
./atm/nicstar.c:2601:			while (card->hbpool.count > card->hbnr.init) {
./atm/nicstar.c:2604:				spin_lock_irqsave(&card->int_lock, flags);
./atm/nicstar.c:2605:				hb = skb_dequeue(&card->hbpool.queue);
./atm/nicstar.c:2606:				card->hbpool.count--;
./atm/nicstar.c:2607:				spin_unlock_irqrestore(&card->int_lock, flags);
./atm/nicstar.c:2611:					     card->index);
./atm/nicstar.c:2616:			while (card->hbpool.count < card->hbnr.init) {
./atm/nicstar.c:2623:				spin_lock_irqsave(&card->int_lock, flags);
./atm/nicstar.c:2624:				skb_queue_tail(&card->hbpool.queue, hb);
./atm/nicstar.c:2625:				card->hbpool.count++;
./atm/nicstar.c:2626:				spin_unlock_irqrestore(&card->int_lock, flags);
./atm/nicstar.c:2631:			while (card->iovpool.count > card->iovnr.init) {
./atm/nicstar.c:2634:				spin_lock_irqsave(&card->int_lock, flags);
./atm/nicstar.c:2635:				iovb = skb_dequeue(&card->iovpool.queue);
./atm/nicstar.c:2636:				card->iovpool.count--;
./atm/nicstar.c:2637:				spin_unlock_irqrestore(&card->int_lock, flags);
./atm/nicstar.c:2641:					     card->index);
./atm/nicstar.c:2646:			while (card->iovpool.count < card->iovnr.init) {
./atm/nicstar.c:2653:				spin_lock_irqsave(&card->int_lock, flags);
./atm/nicstar.c:2654:				skb_queue_tail(&card->iovpool.queue, iovb);
./atm/nicstar.c:2655:				card->iovpool.count++;
./atm/nicstar.c:2656:				spin_unlock_irqrestore(&card->int_lock, flags);
./atm/nicstar.c:2670:			printk("nicstar%d: %s == NULL \n", card->index,
./atm/nicstar.c:2694:		if (spin_is_locked(&card->int_lock)) {
./atm/nicstar.c:2698:		spin_lock_irqsave(&card->int_lock, flags);
./atm/nicstar.c:2701:		stat_r = readl(card->membase + STAT);
./atm/nicstar.c:2710:		writel(stat_w, card->membase + STAT);
./atm/nicstar.c:2711:		spin_unlock_irqrestore(&card->int_lock, flags);
./atm/nicstar.c:2724:	spin_lock_irqsave(&card->res_lock, flags);
./atm/nicstar.c:2726:	writel((u32) value, card->membase + DR0);
./atm/nicstar.c:2728:	       card->membase + CMD);
./atm/nicstar.c:2729:	spin_unlock_irqrestore(&card->res_lock, flags);
./atm/nicstar.c:2739:	spin_lock_irqsave(&card->res_lock, flags);
./atm/nicstar.c:2742:	       card->membase + CMD);
./atm/nicstar.c:2744:	data = readl(card->membase + DR0) & 0x000000FF;
./atm/nicstar.c:2745:	spin_unlock_irqrestore(&card->res_lock, flags);
./atm/idt77252.c:176:	spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:180:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:190:	    (((addr > card->tst[0] + card->tst_size - 2) &&
./atm/idt77252.c:191:	      (addr < card->tst[0] + card->tst_size)) ||
./atm/idt77252.c:192:	     ((addr > card->tst[1] + card->tst_size - 2) &&
./atm/idt77252.c:193:	      (addr < card->tst[1] + card->tst_size)))) {
./atm/idt77252.c:195:		       card->name, addr, value);
./atm/idt77252.c:198:	spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:202:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:217:	spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:221:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:236:	spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:240:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:372:	spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:375:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:537:	tct = (unsigned long) (card->tct_base + index * SAR_SRAM_TCT_SIZE);
./atm/idt77252.c:539:	printk("%s: TCT %x:", card->name, index);
./atm/idt77252.c:554:	for (i = 0; i < card->tct_size; i++) {
./atm/idt77252.c:555:		vc = card->vcs[i];
./atm/idt77252.c:568:		printk("%s: Connection %d:\n", card->name, vc->index);
./atm/idt77252.c:584:	struct sb_pool *pool = &card->sbpool[queue];
./atm/idt77252.c:617:	card->sbpool[queue].skb[index] = NULL;
./atm/idt77252.c:633:	return card->sbpool[queue].skb[index];
./atm/idt77252.c:644:	scq->base = dma_zalloc_coherent(&card->pcidev->dev, SCQ_SIZE,
./atm/idt77252.c:673:	dma_free_coherent(&card->pcidev->dev, SCQ_SIZE,
./atm/idt77252.c:677:		dma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:688:		dma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:710:	TXPRINTK("%s: SCQ: next 0x%p\n", card->name, scq->next);
./atm/idt77252.c:771:		card->name, atomic_read(&scq->used),
./atm/idt77252.c:779:		       card->name, vc->tx_vcc->vpi, vc->tx_vcc->vci);
./atm/idt77252.c:798:		 card->name, atomic_read(&scq->used), scq->next);
./atm/idt77252.c:802:		TXPRINTK("%s: freeing skb at %p.\n", card->name, skb);
./atm/idt77252.c:804:		dma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:840:		printk("%s: invalid skb->len (%d)\n", card->name, skb->len);
./atm/idt77252.c:845:		 card->name, skb->len);
./atm/idt77252.c:850:	IDT77252_PRV_PADDR(skb) = dma_map_single(&card->pcidev->dev, skb->data,
./atm/idt77252.c:866:			vc = card->vcs[0];
./atm/idt77252.c:872:		printk("%s: Trying to transmit on reserved VC\n", card->name);
./atm/idt77252.c:908:		printk("%s: Traffic type not supported.\n", card->name);
./atm/idt77252.c:928:	dma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:938:	for (i = 0; i < card->scd_size; i++) {
./atm/idt77252.c:939:		if (!card->scd2vc[i]) {
./atm/idt77252.c:940:			card->scd2vc[i] = vc;
./atm/idt77252.c:942:			return card->scd_base + i * SAR_SRAM_SCD_SIZE;
./atm/idt77252.c:974:	card->rsq.base = dma_zalloc_coherent(&card->pcidev->dev, RSQSIZE,
./atm/idt77252.c:975:					     &card->rsq.paddr, GFP_KERNEL);
./atm/idt77252.c:976:	if (card->rsq.base == NULL) {
./atm/idt77252.c:977:		printk("%s: can't allocate RSQ.\n", card->name);
./atm/idt77252.c:981:	card->rsq.last = card->rsq.base + RSQ_NUM_ENTRIES - 1;
./atm/idt77252.c:982:	card->rsq.next = card->rsq.last;
./atm/idt77252.c:983:	for (rsqe = card->rsq.base; rsqe <= card->rsq.last; rsqe++)
./atm/idt77252.c:986:	writel((unsigned long) card->rsq.last - (unsigned long) card->rsq.base,
./atm/idt77252.c:988:	writel(card->rsq.paddr, SAR_REG_RSQB);
./atm/idt77252.c:990:	IPRINTK("%s: RSQ base at 0x%lx (0x%x).\n", card->name,
./atm/idt77252.c:991:		(unsigned long) card->rsq.base,
./atm/idt77252.c:994:		card->name,
./atm/idt77252.c:1005:	dma_free_coherent(&card->pcidev->dev, RSQSIZE,
./atm/idt77252.c:1006:			  card->rsq.base, card->rsq.paddr);
./atm/idt77252.c:1024:			 card->name);
./atm/idt77252.c:1031:		       card->name, __func__,
./atm/idt77252.c:1042:		 card->name, vpi, vci, skb, skb->data);
./atm/idt77252.c:1044:	if ((vpi >= (1 << card->vpibits)) || (vci != (vci & card->vcimask))) {
./atm/idt77252.c:1046:		       card->name, vpi, vci);
./atm/idt77252.c:1051:	vc = card->vcs[VPCI2VC(card, vpi, vci)];
./atm/idt77252.c:1054:		       card->name, vpi, vci);
./atm/idt77252.c:1061:	dma_sync_single_for_cpu(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:1075:				       card->name);
./atm/idt77252.c:1081:					 card->name);
./atm/idt77252.c:1108:		       card->name, vcc->qos.aal);
./atm/idt77252.c:1128:		RXPRINTK("%s: PDU has %d bytes.\n", card->name, len);
./atm/idt77252.c:1133:			         card->name, len, rpp->len, readl(SAR_REG_CDC));
./atm/idt77252.c:1139:			RXPRINTK("%s: AAL5 CRC error.\n", card->name);
./atm/idt77252.c:1150:					 card->name);
./atm/idt77252.c:1182:		dma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:1211:	if (card->rsq.next == card->rsq.last)
./atm/idt77252.c:1212:		rsqe = card->rsq.base;
./atm/idt77252.c:1214:		rsqe = card->rsq.next + 1;
./atm/idt77252.c:1217:		RXPRINTK("%s: no entry in RSQ.\n", card->name);
./atm/idt77252.c:1224:		card->rsq.next = rsqe;
./atm/idt77252.c:1225:		if (card->rsq.next == card->rsq.last)
./atm/idt77252.c:1226:			rsqe = card->rsq.base;
./atm/idt77252.c:1228:			rsqe = card->rsq.next + 1;
./atm/idt77252.c:1231:	writel((unsigned long) card->rsq.next - (unsigned long) card->rsq.base,
./atm/idt77252.c:1244:	if (card->raw_cell_head == NULL) {
./atm/idt77252.c:1245:		u32 handle = le32_to_cpu(*(card->raw_cell_hnd + 1));
./atm/idt77252.c:1246:		card->raw_cell_head = sb_pool_skb(card, handle);
./atm/idt77252.c:1249:	queue = card->raw_cell_head;
./atm/idt77252.c:1256:	dma_sync_single_for_cpu(&card->pcidev->dev, IDT77252_PRV_PADDR(queue),
./atm/idt77252.c:1274:			       card->name, (header >> 28) & 0x000f,
./atm/idt77252.c:1285:		if (vpi >= (1<<card->vpibits) || vci >= (1<<card->vcibits)) {
./atm/idt77252.c:1287:				card->name, vpi, vci);
./atm/idt77252.c:1291:		vc = card->vcs[VPCI2VC(card, vpi, vci)];
./atm/idt77252.c:1294:				card->name, vpi, vci);
./atm/idt77252.c:1302:				card->name, vpi, vci);
./atm/idt77252.c:1309:			       card->name);
./atm/idt77252.c:1316:				 card->name);
./atm/idt77252.c:1347:				card->raw_cell_head = next;
./atm/idt77252.c:1348:				queue = card->raw_cell_head;
./atm/idt77252.c:1349:				dma_sync_single_for_cpu(&card->pcidev->dev,
./atm/idt77252.c:1355:				card->raw_cell_head = NULL;
./atm/idt77252.c:1357:				       card->name);
./atm/idt77252.c:1376:	card->tsq.base = dma_alloc_coherent(&card->pcidev->dev, RSQSIZE,
./atm/idt77252.c:1377:					    &card->tsq.paddr, GFP_KERNEL);
./atm/idt77252.c:1378:	if (card->tsq.base == NULL) {
./atm/idt77252.c:1379:		printk("%s: can't allocate TSQ.\n", card->name);
./atm/idt77252.c:1382:	memset(card->tsq.base, 0, TSQSIZE);
./atm/idt77252.c:1384:	card->tsq.last = card->tsq.base + TSQ_NUM_ENTRIES - 1;
./atm/idt77252.c:1385:	card->tsq.next = card->tsq.last;
./atm/idt77252.c:1386:	for (tsqe = card->tsq.base; tsqe <= card->tsq.last; tsqe++)
./atm/idt77252.c:1389:	writel(card->tsq.paddr, SAR_REG_TSQB);
./atm/idt77252.c:1390:	writel((unsigned long) card->tsq.next - (unsigned long) card->tsq.base,
./atm/idt77252.c:1399:	dma_free_coherent(&card->pcidev->dev, TSQSIZE,
./atm/idt77252.c:1400:			  card->tsq.base, card->tsq.paddr);
./atm/idt77252.c:1411:	if (card->tsq.next == card->tsq.last)
./atm/idt77252.c:1412:		tsqe = card->tsq.base;
./atm/idt77252.c:1414:		tsqe = card->tsq.next + 1;
./atm/idt77252.c:1417:		 card->tsq.base, card->tsq.next, card->tsq.last);
./atm/idt77252.c:1435:			TXPRINTK("%s: Timer RollOver detected.\n", card->name);
./atm/idt77252.c:1445:				       card->name,
./atm/idt77252.c:1451:			vc = card->vcs[conn & 0x1fff];
./atm/idt77252.c:1454:				       card->name, conn & 0x1fff);
./atm/idt77252.c:1459:			       card->name, vc->index);
./atm/idt77252.c:1468:			vc = card->vcs[conn & 0x1fff];
./atm/idt77252.c:1471:				       card->name,
./atm/idt77252.c:1486:			if (vpi >= (1 << card->vpibits) ||
./atm/idt77252.c:1487:			    vci >= (1 << card->vcibits)) {
./atm/idt77252.c:1490:				       card->name, vpi, vci);
./atm/idt77252.c:1494:			vc = card->vcs[VPCI2VC(card, vpi, vci)];
./atm/idt77252.c:1498:				       card->name, vpi, vci);
./atm/idt77252.c:1508:		card->tsq.next = tsqe;
./atm/idt77252.c:1509:		if (card->tsq.next == card->tsq.last)
./atm/idt77252.c:1510:			tsqe = card->tsq.base;
./atm/idt77252.c:1512:			tsqe = card->tsq.next + 1;
./atm/idt77252.c:1515:			 card->tsq.base, card->tsq.next, card->tsq.last);
./atm/idt77252.c:1521:	writel((unsigned long)card->tsq.next - (unsigned long)card->tsq.base,
./atm/idt77252.c:1525:		card->index, readl(SAR_REG_TSQH),
./atm/idt77252.c:1526:		readl(SAR_REG_TSQT), card->tsq.next);
./atm/idt77252.c:1539:	spin_lock_irqsave(&card->tst_lock, flags);
./atm/idt77252.c:1541:	base = card->tst[card->tst_index];
./atm/idt77252.c:1542:	idle = card->tst[card->tst_index ^ 1];
./atm/idt77252.c:1544:	if (test_bit(TST_SWITCH_WAIT, &card->tst_state)) {
./atm/idt77252.c:1545:		jump = base + card->tst_size - 2;
./atm/idt77252.c:1548:		if ((pc ^ idle) & ~(card->tst_size - 1)) {
./atm/idt77252.c:1549:			mod_timer(&card->tst_timer, jiffies + 1);
./atm/idt77252.c:1553:		clear_bit(TST_SWITCH_WAIT, &card->tst_state);
./atm/idt77252.c:1555:		card->tst_index ^= 1;
./atm/idt77252.c:1558:		base = card->tst[card->tst_index];
./atm/idt77252.c:1559:		idle = card->tst[card->tst_index ^ 1];
./atm/idt77252.c:1561:		for (e = 0; e < card->tst_size - 2; e++) {
./atm/idt77252.c:1562:			if (card->soft_tst[e].tste & TSTE_PUSH_IDLE) {
./atm/idt77252.c:1564:					   card->soft_tst[e].tste & TSTE_MASK);
./atm/idt77252.c:1565:				card->soft_tst[e].tste &= ~(TSTE_PUSH_IDLE);
./atm/idt77252.c:1570:	if (test_and_clear_bit(TST_SWITCH_PENDING, &card->tst_state)) {
./atm/idt77252.c:1572:		for (e = 0; e < card->tst_size - 2; e++) {
./atm/idt77252.c:1573:			if (card->soft_tst[e].tste & TSTE_PUSH_ACTIVE) {
./atm/idt77252.c:1575:					   card->soft_tst[e].tste & TSTE_MASK);
./atm/idt77252.c:1576:				card->soft_tst[e].tste &= ~(TSTE_PUSH_ACTIVE);
./atm/idt77252.c:1577:				card->soft_tst[e].tste |= TSTE_PUSH_IDLE;
./atm/idt77252.c:1581:		jump = base + card->tst_size - 2;
./atm/idt77252.c:1584:		set_bit(TST_SWITCH_WAIT, &card->tst_state);
./atm/idt77252.c:1586:		mod_timer(&card->tst_timer, jiffies + 1);
./atm/idt77252.c:1590:	spin_unlock_irqrestore(&card->tst_lock, flags);
./atm/idt77252.c:1602:	avail = card->tst_size - 2;
./atm/idt77252.c:1604:		if (card->soft_tst[e].vc == NULL)
./atm/idt77252.c:1608:		printk("%s: No free TST entries found\n", card->name);
./atm/idt77252.c:1613:		card->name, vc ? vc->index : -1, e);
./atm/idt77252.c:1621:	idle = card->tst[card->tst_index ^ 1];
./atm/idt77252.c:1627:		if ((cl >= avail) && (card->soft_tst[e].vc == NULL)) {
./atm/idt77252.c:1629:				card->soft_tst[e].vc = vc;
./atm/idt77252.c:1631:				card->soft_tst[e].vc = (void *)-1;
./atm/idt77252.c:1633:			card->soft_tst[e].tste = data;
./atm/idt77252.c:1634:			if (timer_pending(&card->tst_timer))
./atm/idt77252.c:1635:				card->soft_tst[e].tste |= TSTE_PUSH_ACTIVE;
./atm/idt77252.c:1638:				card->soft_tst[e].tste |= TSTE_PUSH_IDLE;
./atm/idt77252.c:1641:			cl -= card->tst_size;
./atm/idt77252.c:1659:	spin_lock_irqsave(&card->tst_lock, flags);
./atm/idt77252.c:1663:	set_bit(TST_SWITCH_PENDING, &card->tst_state);
./atm/idt77252.c:1664:	if (!timer_pending(&card->tst_timer))
./atm/idt77252.c:1665:		mod_timer(&card->tst_timer, jiffies + 1);
./atm/idt77252.c:1667:	spin_unlock_irqrestore(&card->tst_lock, flags);
./atm/idt77252.c:1677:	idle = card->tst[card->tst_index ^ 1];
./atm/idt77252.c:1679:	for (e = 0; e < card->tst_size - 2; e++) {
./atm/idt77252.c:1680:		if (card->soft_tst[e].vc == vc) {
./atm/idt77252.c:1681:			card->soft_tst[e].vc = NULL;
./atm/idt77252.c:1683:			card->soft_tst[e].tste = TSTE_OPC_VAR;
./atm/idt77252.c:1684:			if (timer_pending(&card->tst_timer))
./atm/idt77252.c:1685:				card->soft_tst[e].tste |= TSTE_PUSH_ACTIVE;
./atm/idt77252.c:1688:				card->soft_tst[e].tste |= TSTE_PUSH_IDLE;
./atm/idt77252.c:1702:	spin_lock_irqsave(&card->tst_lock, flags);
./atm/idt77252.c:1706:	set_bit(TST_SWITCH_PENDING, &card->tst_state);
./atm/idt77252.c:1707:	if (!timer_pending(&card->tst_timer))
./atm/idt77252.c:1708:		mod_timer(&card->tst_timer, jiffies + 1);
./atm/idt77252.c:1710:	spin_unlock_irqrestore(&card->tst_lock, flags);
./atm/idt77252.c:1721:	spin_lock_irqsave(&card->tst_lock, flags);
./atm/idt77252.c:1726:	set_bit(TST_SWITCH_PENDING, &card->tst_state);
./atm/idt77252.c:1727:	if (!timer_pending(&card->tst_timer))
./atm/idt77252.c:1728:		mod_timer(&card->tst_timer, jiffies + 1);
./atm/idt77252.c:1730:	spin_unlock_irqrestore(&card->tst_lock, flags);
./atm/idt77252.c:1740:	tct = (unsigned long) (card->tct_base + vc->index * SAR_SRAM_TCT_SIZE);
./atm/idt77252.c:1745:		        card->name, tct, vc->scq->scd);
./atm/idt77252.c:1759:		        card->name, tct, vc->scq->scd);
./atm/idt77252.c:1836:	spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:1837:	writel(handle, card->fbq[queue]);
./atm/idt77252.c:1838:	writel(addr, card->fbq[queue]);
./atm/idt77252.c:1839:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:1862:		paddr = dma_map_single(&card->pcidev->dev, skb->data,
./atm/idt77252.c:1876:	dma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:1880:	card->sbpool[POOL_QUEUE(handle)].skb[POOL_INDEX(handle)] = NULL;
./atm/idt77252.c:1893:	dma_sync_single_for_device(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:1899:		dma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),
./atm/idt77252.c:1952:		printk("%s: NULL connection in send().\n", card->name);
./atm/idt77252.c:1958:		printk("%s: Trying to transmit on a non-tx VC.\n", card->name);
./atm/idt77252.c:1970:		printk("%s: Unsupported AAL: %d\n", card->name, vcc->qos.aal);
./atm/idt77252.c:1977:		printk("%s: No scatter-gather yet.\n", card->name);
./atm/idt77252.c:2008:		printk("%s: Out of memory in send_oam().\n", card->name);
./atm/idt77252.c:2149:		       card->name);
./atm/idt77252.c:2154:	tst_free = card->tst_free;
./atm/idt77252.c:2162:	TXPRINTK("%s: CBR target cell rate = %d\n", card->name, tcra);
./atm/idt77252.c:2164:	tmpl = (unsigned long) tcra * ((unsigned long) card->tst_size - 2);
./atm/idt77252.c:2165:	modl = tmpl % (unsigned long)card->utopia_pcr;
./atm/idt77252.c:2167:	tst_entries = (int) (tmpl / card->utopia_pcr);
./atm/idt77252.c:2174:			printk("%s: no CBR bandwidth free.\n", card->name);
./atm/idt77252.c:2181:		       card->name);
./atm/idt77252.c:2186:		printk("%s: not enough CBR bandwidth free.\n", card->name);
./atm/idt77252.c:2192:	card->tst_free = tst_free - tst_entries;
./atm/idt77252.c:2198:			card->name, tst_used, tst_entries);
./atm/idt77252.c:2203:	OPRINTK("%s: setting %d entries in TST.\n", card->name, tst_entries);
./atm/idt77252.c:2225:		tcr = card->link_pcr;
./atm/idt77252.c:2266:		printk("%s: can't get SCQ.\n", card->name);
./atm/idt77252.c:2272:		printk("%s: no SCD available.\n", card->name);
./atm/idt77252.c:2281:		       card->name, qos->txtp.traffic_class);
./atm/idt77252.c:2283:		card->scd2vc[vc->scd_index] = NULL;
./atm/idt77252.c:2292:				card->scd2vc[vc->scd_index] = NULL;
./atm/idt77252.c:2304:				card->scd2vc[vc->scd_index] = NULL;
./atm/idt77252.c:2369:	addr = card->rct_base + (vc->index << 2);
./atm/idt77252.c:2371:	OPRINTK("%s: writing RCT at 0x%lx\n", card->name, addr);
./atm/idt77252.c:2374:	spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:2377:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:2397:	if (vpi >= (1 << card->vpibits)) {
./atm/idt77252.c:2398:		printk("%s: unsupported VPI: %d\n", card->name, vpi);
./atm/idt77252.c:2402:	if (vci >= (1 << card->vcibits)) {
./atm/idt77252.c:2403:		printk("%s: unsupported VCI: %d\n", card->name, vci);
./atm/idt77252.c:2409:	mutex_lock(&card->mutex);
./atm/idt77252.c:2411:	OPRINTK("%s: opening vpi.vci: %d.%d\n", card->name, vpi, vci);
./atm/idt77252.c:2419:		printk("%s: Unsupported AAL: %d\n", card->name, vcc->qos.aal);
./atm/idt77252.c:2420:		mutex_unlock(&card->mutex);
./atm/idt77252.c:2425:	if (!card->vcs[index]) {
./atm/idt77252.c:2426:		card->vcs[index] = kzalloc(sizeof(struct vc_map), GFP_KERNEL);
./atm/idt77252.c:2427:		if (!card->vcs[index]) {
./atm/idt77252.c:2428:			printk("%s: can't alloc vc in open()\n", card->name);
./atm/idt77252.c:2429:			mutex_unlock(&card->mutex);
./atm/idt77252.c:2432:		card->vcs[index]->card = card;
./atm/idt77252.c:2433:		card->vcs[index]->index = index;
./atm/idt77252.c:2435:		spin_lock_init(&card->vcs[index]->lock);
./atm/idt77252.c:2437:	vc = card->vcs[index];
./atm/idt77252.c:2442:	        card->name, vc->index, vcc->vpi, vcc->vci,
./atm/idt77252.c:2456:		printk("%s: %s vci already in use.\n", card->name,
./atm/idt77252.c:2458:		mutex_unlock(&card->mutex);
./atm/idt77252.c:2465:			mutex_unlock(&card->mutex);
./atm/idt77252.c:2473:			mutex_unlock(&card->mutex);
./atm/idt77252.c:2480:	mutex_unlock(&card->mutex);
./atm/idt77252.c:2494:	mutex_lock(&card->mutex);
./atm/idt77252.c:2497:		card->name, vc->index, vcc->vpi, vcc->vci);
./atm/idt77252.c:2511:		addr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;
./atm/idt77252.c:2513:		spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:2516:		spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:2520:				card->name);
./atm/idt77252.c:2547:					card->name, atomic_read(&vc->scq->used));
./atm/idt77252.c:2557:			card->tst_free += vc->ntste;
./atm/idt77252.c:2561:		card->scd2vc[vc->scd_index] = NULL;
./atm/idt77252.c:2565:	mutex_unlock(&card->mutex);
./atm/idt77252.c:2576:	mutex_lock(&card->mutex);
./atm/idt77252.c:2622:	mutex_unlock(&card->mutex);
./atm/idt77252.c:2636:		return sprintf(page, "TSIF:  %lu\n", card->irqstat[15]);
./atm/idt77252.c:2638:		return sprintf(page, "TXICP: %lu\n", card->irqstat[14]);
./atm/idt77252.c:2640:		return sprintf(page, "TSQF:  %lu\n", card->irqstat[12]);
./atm/idt77252.c:2642:		return sprintf(page, "TMROF: %lu\n", card->irqstat[11]);
./atm/idt77252.c:2644:		return sprintf(page, "PHYI:  %lu\n", card->irqstat[10]);
./atm/idt77252.c:2646:		return sprintf(page, "FBQ3A: %lu\n", card->irqstat[8]);
./atm/idt77252.c:2648:		return sprintf(page, "FBQ2A: %lu\n", card->irqstat[7]);
./atm/idt77252.c:2650:		return sprintf(page, "RSQF:  %lu\n", card->irqstat[6]);
./atm/idt77252.c:2652:		return sprintf(page, "EPDU:  %lu\n", card->irqstat[5]);
./atm/idt77252.c:2654:		return sprintf(page, "RAWCF: %lu\n", card->irqstat[4]);
./atm/idt77252.c:2656:		return sprintf(page, "FBQ1A: %lu\n", card->irqstat[3]);
./atm/idt77252.c:2658:		return sprintf(page, "FBQ0A: %lu\n", card->irqstat[2]);
./atm/idt77252.c:2660:		return sprintf(page, "RSQAF: %lu\n", card->irqstat[1]);
./atm/idt77252.c:2664:	for (i = 0; i < card->tct_size; i++) {
./atm/idt77252.c:2670:		vc = card->vcs[i];
./atm/idt77252.c:2684:		tct = (unsigned long) (card->tct_base + i * SAR_SRAM_TCT_SIZE);
./atm/idt77252.c:2719:	if (test_and_set_bit(IDT77252_BIT_INTERRUPT, &card->flags)) {
./atm/idt77252.c:2720:		printk("%s: Re-entering irq_handler()\n", card->name);
./atm/idt77252.c:2727:		INTPRINTK("%s: TSIF\n", card->name);
./atm/idt77252.c:2728:		card->irqstat[15]++;
./atm/idt77252.c:2732:		INTPRINTK("%s: TXICP\n", card->name);
./atm/idt77252.c:2733:		card->irqstat[14]++;
./atm/idt77252.c:2739:		INTPRINTK("%s: TSQF\n", card->name);
./atm/idt77252.c:2740:		card->irqstat[12]++;
./atm/idt77252.c:2744:		INTPRINTK("%s: TMROF\n", card->name);
./atm/idt77252.c:2745:		card->irqstat[11]++;
./atm/idt77252.c:2750:		INTPRINTK("%s: EPDU\n", card->name);
./atm/idt77252.c:2751:		card->irqstat[5]++;
./atm/idt77252.c:2755:		INTPRINTK("%s: RSQAF\n", card->name);
./atm/idt77252.c:2756:		card->irqstat[1]++;
./atm/idt77252.c:2760:		INTPRINTK("%s: RSQF\n", card->name);
./atm/idt77252.c:2761:		card->irqstat[6]++;
./atm/idt77252.c:2765:		INTPRINTK("%s: RAWCF\n", card->name);
./atm/idt77252.c:2766:		card->irqstat[4]++;
./atm/idt77252.c:2771:		INTPRINTK("%s: PHYI", card->name);
./atm/idt77252.c:2772:		card->irqstat[10]++;
./atm/idt77252.c:2773:		if (card->atmdev->phy && card->atmdev->phy->interrupt)
./atm/idt77252.c:2774:			card->atmdev->phy->interrupt(card->atmdev);
./atm/idt77252.c:2782:		INTPRINTK("%s: FBQA: %04x\n", card->name, stat);
./atm/idt77252.c:2785:			card->irqstat[2]++;
./atm/idt77252.c:2787:			card->irqstat[3]++;
./atm/idt77252.c:2789:			card->irqstat[7]++;
./atm/idt77252.c:2791:			card->irqstat[8]++;
./atm/idt77252.c:2793:		schedule_work(&card->tqueue);
./atm/idt77252.c:2797:	clear_bit(IDT77252_BIT_INTERRUPT, &card->flags);
./atm/idt77252.c:2853:	for (vpi = 0; vpi < (1 << card->vpibits); vpi++) {
./atm/idt77252.c:2859:				printk("%s: can't alloc vc\n", card->name);
./atm/idt77252.c:2863:			card->vcs[index] = vc;
./atm/idt77252.c:2872:			addr = card->rct_base + (vc->index << 2);
./atm/idt77252.c:2875:			spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:2879:			spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:2895:	for (vpi = 0; vpi < (1 << card->vpibits); vpi++) {
./atm/idt77252.c:2898:			vc = card->vcs[index];
./atm/idt77252.c:2900:			addr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;
./atm/idt77252.c:2902:			spin_lock_irqsave(&card->cmd_lock, flags);
./atm/idt77252.c:2906:			spin_unlock_irqrestore(&card->cmd_lock, flags);
./atm/idt77252.c:2911:					card->name);
./atm/idt77252.c:2926:		printk("%s: can't alloc vc\n", card->name);
./atm/idt77252.c:2929:	card->vcs[0] = vc;
./atm/idt77252.c:2934:		printk("%s: can't get SCQ.\n", card->name);
./atm/idt77252.c:2938:	card->scd2vc[0] = vc;
./atm/idt77252.c:2940:	vc->scq->scd = card->scd_base;
./atm/idt77252.c:2944:	write_sram(card, card->tct_base + 0, TCT_UBR | card->scd_base);
./atm/idt77252.c:2945:	write_sram(card, card->tct_base + 1, 0);
./atm/idt77252.c:2946:	write_sram(card, card->tct_base + 2, 0);
./atm/idt77252.c:2947:	write_sram(card, card->tct_base + 3, 0);
./atm/idt77252.c:2948:	write_sram(card, card->tct_base + 4, 0);
./atm/idt77252.c:2949:	write_sram(card, card->tct_base + 5, 0);
./atm/idt77252.c:2950:	write_sram(card, card->tct_base + 6, 0);
./atm/idt77252.c:2951:	write_sram(card, card->tct_base + 7, TCT_FLAG_UBR);
./atm/idt77252.c:2963:	if (!test_bit(IDT77252_BIT_INIT, &card->flags)) {
./atm/idt77252.c:2964:		printk("%s: SAR not yet initialized.\n", card->name);
./atm/idt77252.c:2989:		printk("%s: Error initializing OAM.\n", card->name);
./atm/idt77252.c:2994:		printk("%s: Error initializing UBR0.\n", card->name);
./atm/idt77252.c:2998:	IPRINTK("%s: opened IDT77252 ABR SAR.\n", card->name);
./atm/idt77252.c:3023:	DIPRINTK("%s: closed IDT77252 ABR SAR.\n", card->name);
./atm/idt77252.c:3040:	if (!test_bit(IDT77252_BIT_INIT, &card->flags)) {
./atm/idt77252.c:3041:		printk("%s: SAR not yet initialized.\n", card->name);
./atm/idt77252.c:3044:	DIPRINTK("idt77252: deinitialize card %u\n", card->index);
./atm/idt77252.c:3048:	if (card->atmdev)
./atm/idt77252.c:3049:		atm_dev_deregister(card->atmdev);
./atm/idt77252.c:3053:			skb = card->sbpool[i].skb[j];
./atm/idt77252.c:3055:				dma_unmap_single(&card->pcidev->dev,
./atm/idt77252.c:3060:				card->sbpool[i].skb[j] = NULL;
./atm/idt77252.c:3066:	vfree(card->soft_tst);
./atm/idt77252.c:3068:	vfree(card->scd2vc);
./atm/idt77252.c:3070:	vfree(card->vcs);
./atm/idt77252.c:3072:	if (card->raw_cell_hnd) {
./atm/idt77252.c:3073:		dma_free_coherent(&card->pcidev->dev, 2 * sizeof(u32),
./atm/idt77252.c:3074:				  card->raw_cell_hnd, card->raw_cell_paddr);
./atm/idt77252.c:3077:	if (card->rsq.base) {
./atm/idt77252.c:3078:		DIPRINTK("%s: Release RSQ ...\n", card->name);
./atm/idt77252.c:3082:	if (card->tsq.base) {
./atm/idt77252.c:3083:		DIPRINTK("%s: Release TSQ ...\n", card->name);
./atm/idt77252.c:3088:	free_irq(card->pcidev->irq, card);
./atm/idt77252.c:3091:		if (card->fbq[i])
./atm/idt77252.c:3092:			iounmap(card->fbq[i]);
./atm/idt77252.c:3095:	if (card->membase)
./atm/idt77252.c:3096:		iounmap(card->membase);
./atm/idt77252.c:3098:	clear_bit(IDT77252_BIT_INIT, &card->flags);
./atm/idt77252.c:3099:	DIPRINTK("%s: Card deinitialized.\n", card->name);
./atm/idt77252.c:3107:	for (i = 0; i < card->sramsize; i += 4)
./atm/idt77252.c:3111:	if (card->sramsize == (512 * 1024)) {
./atm/idt77252.c:3112:		card->tct_base = SAR_SRAM_TCT_128_BASE;
./atm/idt77252.c:3113:		card->tct_size = (SAR_SRAM_TCT_128_TOP - card->tct_base + 1)
./atm/idt77252.c:3115:		card->rct_base = SAR_SRAM_RCT_128_BASE;
./atm/idt77252.c:3116:		card->rct_size = (SAR_SRAM_RCT_128_TOP - card->rct_base + 1)
./atm/idt77252.c:3118:		card->rt_base = SAR_SRAM_RT_128_BASE;
./atm/idt77252.c:3119:		card->scd_base = SAR_SRAM_SCD_128_BASE;
./atm/idt77252.c:3120:		card->scd_size = (SAR_SRAM_SCD_128_TOP - card->scd_base + 1)
./atm/idt77252.c:3122:		card->tst[0] = SAR_SRAM_TST1_128_BASE;
./atm/idt77252.c:3123:		card->tst[1] = SAR_SRAM_TST2_128_BASE;
./atm/idt77252.c:3124:		card->tst_size = SAR_SRAM_TST1_128_TOP - card->tst[0] + 1;
./atm/idt77252.c:3125:		card->abrst_base = SAR_SRAM_ABRSTD_128_BASE;
./atm/idt77252.c:3126:		card->abrst_size = SAR_ABRSTD_SIZE_8K;
./atm/idt77252.c:3127:		card->fifo_base = SAR_SRAM_FIFO_128_BASE;
./atm/idt77252.c:3128:		card->fifo_size = SAR_RXFD_SIZE_32K;
./atm/idt77252.c:3130:		card->tct_base = SAR_SRAM_TCT_32_BASE;
./atm/idt77252.c:3131:		card->tct_size = (SAR_SRAM_TCT_32_TOP - card->tct_base + 1)
./atm/idt77252.c:3133:		card->rct_base = SAR_SRAM_RCT_32_BASE;
./atm/idt77252.c:3134:		card->rct_size = (SAR_SRAM_RCT_32_TOP - card->rct_base + 1)
./atm/idt77252.c:3136:		card->rt_base = SAR_SRAM_RT_32_BASE;
./atm/idt77252.c:3137:		card->scd_base = SAR_SRAM_SCD_32_BASE;
./atm/idt77252.c:3138:		card->scd_size = (SAR_SRAM_SCD_32_TOP - card->scd_base + 1)
./atm/idt77252.c:3140:		card->tst[0] = SAR_SRAM_TST1_32_BASE;
./atm/idt77252.c:3141:		card->tst[1] = SAR_SRAM_TST2_32_BASE;
./atm/idt77252.c:3142:		card->tst_size = (SAR_SRAM_TST1_32_TOP - card->tst[0] + 1);
./atm/idt77252.c:3143:		card->abrst_base = SAR_SRAM_ABRSTD_32_BASE;
./atm/idt77252.c:3144:		card->abrst_size = SAR_ABRSTD_SIZE_1K;
./atm/idt77252.c:3145:		card->fifo_base = SAR_SRAM_FIFO_32_BASE;
./atm/idt77252.c:3146:		card->fifo_size = SAR_RXFD_SIZE_4K;
./atm/idt77252.c:3150:	for (i = 0; i < card->tct_size; i++) {
./atm/idt77252.c:3162:	for (i = 0; i < card->rct_size; i++) {
./atm/idt77252.c:3163:		write_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE,
./atm/idt77252.c:3165:		write_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 1,
./atm/idt77252.c:3167:		write_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 2,
./atm/idt77252.c:3169:		write_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 3,
./atm/idt77252.c:3184:		write_sram(card, card->rt_base + i, log_to_rate[i]);
./atm/idt77252.c:3194:		write_sram(card, card->rt_base + 256 + i, tmp);
./atm/idt77252.c:3203:		write_sram(card, card->rt_base + 512 + i, tmp);
./atm/idt77252.c:3211:		write_sram(card, card->rt_base + 640 + i, tmp);
./atm/idt77252.c:3215:	IPRINTK("%s: initialize rate table ...\n", card->name);
./atm/idt77252.c:3216:	writel(card->rt_base << 2, SAR_REG_RTBL);
./atm/idt77252.c:3219:	IPRINTK("%s: initialize TST ...\n", card->name);
./atm/idt77252.c:3220:	card->tst_free = card->tst_size - 2;	/* last two are jumps */
./atm/idt77252.c:3222:	for (i = card->tst[0]; i < card->tst[0] + card->tst_size - 2; i++)
./atm/idt77252.c:3224:	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));
./atm/idt77252.c:3226:	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[1] << 2));
./atm/idt77252.c:3228:	for (i = card->tst[1]; i < card->tst[1] + card->tst_size - 2; i++)
./atm/idt77252.c:3230:	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[1] << 2));
./atm/idt77252.c:3232:	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));
./atm/idt77252.c:3235:	card->tst_index = 0;
./atm/idt77252.c:3236:	writel(card->tst[0] << 2, SAR_REG_TSTB);
./atm/idt77252.c:3239:	IPRINTK("%s: initialize ABRSTD ...\n", card->name);
./atm/idt77252.c:3240:	writel(card->abrst_size | (card->abrst_base << 2),
./atm/idt77252.c:3243:	IPRINTK("%s: initialize receive fifo ...\n", card->name);
./atm/idt77252.c:3244:	writel(card->fifo_size | (card->fifo_base << 2),
./atm/idt77252.c:3247:	IPRINTK("%s: SRAM initialization complete.\n", card->name);
./atm/idt77252.c:3253:	struct pci_dev *pcidev = card->pcidev;
./atm/idt77252.c:3265:	if (test_bit(IDT77252_BIT_INIT, &card->flags)) {
./atm/idt77252.c:3275:	IPRINTK("%s: Checking PCI retries.\n", card->name);
./atm/idt77252.c:3277:		printk("%s: can't read PCI retry timeout.\n", card->name);
./atm/idt77252.c:3283:			card->name, pci_byte);
./atm/idt77252.c:3286:			       card->name);
./atm/idt77252.c:3291:	IPRINTK("%s: Checking PCI TRDY.\n", card->name);
./atm/idt77252.c:3293:		printk("%s: can't read PCI TRDY timeout.\n", card->name);
./atm/idt77252.c:3299:		        card->name, pci_byte);
./atm/idt77252.c:3301:			printk("%s: can't set PCI TRDY timeout.\n", card->name);
./atm/idt77252.c:3308:		printk("%s: resetting timer overflow.\n", card->name);
./atm/idt77252.c:3311:	IPRINTK("%s: Request IRQ ... ", card->name);
./atm/idt77252.c:3313:			card->name, card) != 0) {
./atm/idt77252.c:3314:		printk("%s: can't allocate IRQ.\n", card->name);
./atm/idt77252.c:3324:	IPRINTK("%s: Initializing SRAM\n", card->name);
./atm/idt77252.c:3335:	if (card->sramsize == (512 * 1024))
./atm/idt77252.c:3374:	card->vpibits = vpibits;
./atm/idt77252.c:3375:	if (card->sramsize == (512 * 1024)) {
./atm/idt77252.c:3376:		card->vcibits = 10 - card->vpibits;
./atm/idt77252.c:3378:		card->vcibits = 9 - card->vpibits;
./atm/idt77252.c:3381:	card->vcimask = 0;
./atm/idt77252.c:3382:	for (k = 0, i = 1; k < card->vcibits; k++) {
./atm/idt77252.c:3383:		card->vcimask |= i;
./atm/idt77252.c:3387:	IPRINTK("%s: Setting VPI/VCI mask to zero.\n", card->name);
./atm/idt77252.c:3394:	card->raw_cell_hnd = dma_zalloc_coherent(&card->pcidev->dev,
./atm/idt77252.c:3396:						 &card->raw_cell_paddr,
./atm/idt77252.c:3398:	if (!card->raw_cell_hnd) {
./atm/idt77252.c:3399:		printk("%s: memory allocation failure.\n", card->name);
./atm/idt77252.c:3403:	writel(card->raw_cell_paddr, SAR_REG_RAWHND);
./atm/idt77252.c:3404:	IPRINTK("%s: raw cell handle is at 0x%p.\n", card->name,
./atm/idt77252.c:3405:		card->raw_cell_hnd);
./atm/idt77252.c:3407:	size = sizeof(struct vc_map *) * card->tct_size;
./atm/idt77252.c:3408:	IPRINTK("%s: allocate %d byte for VC map.\n", card->name, size);
./atm/idt77252.c:3409:	card->vcs = vzalloc(size);
./atm/idt77252.c:3410:	if (!card->vcs) {
./atm/idt77252.c:3411:		printk("%s: memory allocation failure.\n", card->name);
./atm/idt77252.c:3416:	size = sizeof(struct vc_map *) * card->scd_size;
./atm/idt77252.c:3418:	        card->name, size);
./atm/idt77252.c:3419:	card->scd2vc = vzalloc(size);
./atm/idt77252.c:3420:	if (!card->scd2vc) {
./atm/idt77252.c:3421:		printk("%s: memory allocation failure.\n", card->name);
./atm/idt77252.c:3426:	size = sizeof(struct tst_info) * (card->tst_size - 2);
./atm/idt77252.c:3428:		card->name, size);
./atm/idt77252.c:3429:	card->soft_tst = vmalloc(size);
./atm/idt77252.c:3430:	if (!card->soft_tst) {
./atm/idt77252.c:3431:		printk("%s: memory allocation failure.\n", card->name);
./atm/idt77252.c:3435:	for (i = 0; i < card->tst_size - 2; i++) {
./atm/idt77252.c:3436:		card->soft_tst[i].tste = TSTE_OPC_VAR;
./atm/idt77252.c:3437:		card->soft_tst[i].vc = NULL;
./atm/idt77252.c:3441:		printk("%s: No LT device defined.\n", card->name);
./atm/idt77252.c:3446:		printk("%s: LT had no IOCTL function defined.\n", card->name);
./atm/idt77252.c:3464:	card->link_pcr = (linkrate / 8 / 53);
./atm/idt77252.c:3466:	       card->name, linkrate, card->link_pcr);
./atm/idt77252.c:3469:	card->utopia_pcr = card->link_pcr;
./atm/idt77252.c:3471:	card->utopia_pcr = (160000000 / 8 / 54);
./atm/idt77252.c:3475:	if (card->utopia_pcr > card->link_pcr)
./atm/idt77252.c:3476:		rsvdcr = card->utopia_pcr - card->link_pcr;
./atm/idt77252.c:3478:	tmpl = (unsigned long) rsvdcr * ((unsigned long) card->tst_size - 2);
./atm/idt77252.c:3479:	modl = tmpl % (unsigned long)card->utopia_pcr;
./atm/idt77252.c:3480:	tst_entries = (int) (tmpl / (unsigned long)card->utopia_pcr);
./atm/idt77252.c:3483:	card->tst_free -= tst_entries;
./atm/idt77252.c:3488:	printk("%s: EEPROM: %02x:", card->name,
./atm/idt77252.c:3502:	sprintf(tname, "eth%d", card->index);
./atm/idt77252.c:3505:		memcpy(card->atmdev->esi, tmp->dev_addr, 6);
./atm/idt77252.c:3507:		printk("%s: ESI %pM\n", card->name, card->atmdev->esi);
./atm/idt77252.c:3516:	set_bit(IDT77252_BIT_INIT, &card->flags);
./atm/idt77252.c:3518:	XPRINTK("%s: IDT77252 ABR SAR initialization complete.\n", card->name);
./atm/idt77252.c:3539:		card->name);
./atm/idt77252.c:3540:	if (pci_read_config_word(card->pcidev, PCI_COMMAND, &pci_command)) {
./atm/idt77252.c:3541:		printk("%s: can't read PCI_COMMAND.\n", card->name);
./atm/idt77252.c:3547:		       card->name, pci_command);
./atm/idt77252.c:3552:	if (pci_write_config_word(card->pcidev, PCI_COMMAND, pci_command)) {
./atm/idt77252.c:3553:		printk("%s: can't write PCI_COMMAND.\n", card->name);
./atm/idt77252.c:3566:	IPRINTK("%s: Software resetted.\n", card->name);
./atm/idt77252.c:3620:	card->revision = pcidev->revision;
./atm/idt77252.c:3621:	card->index = index;
./atm/idt77252.c:3622:	card->pcidev = pcidev;
./atm/idt77252.c:3623:	sprintf(card->name, "idt77252-%d", card->index);
./atm/idt77252.c:3625:	INIT_WORK(&card->tqueue, idt77252_softint);
./atm/idt77252.c:3630:	mutex_init(&card->mutex);
./atm/idt77252.c:3631:	spin_lock_init(&card->cmd_lock);
./atm/idt77252.c:3632:	spin_lock_init(&card->tst_lock);
./atm/idt77252.c:3634:	setup_timer(&card->tst_timer, tst_timer, (unsigned long)card);
./atm/idt77252.c:3637:	card->membase = ioremap(membase, 1024);
./atm/idt77252.c:3638:	if (!card->membase) {
./atm/idt77252.c:3639:		printk("%s: can't ioremap() membase\n", card->name);
./atm/idt77252.c:3645:		printk("%s: preset failed\n", card->name);
./atm/idt77252.c:3653:		printk("%s: can't register atm device\n", card->name);
./atm/idt77252.c:3658:	card->atmdev = dev;
./atm/idt77252.c:3663:		printk("%s: can't init SUNI\n", card->name);
./atm/idt77252.c:3669:	card->sramsize = probe_sram(card);
./atm/idt77252.c:3672:		card->fbq[i] = ioremap(srambase | 0x200000 | (i << 18), 4);
./atm/idt77252.c:3673:		if (!card->fbq[i]) {
./atm/idt77252.c:3674:			printk("%s: can't ioremap() FBQ%d\n", card->name, i);
./atm/idt77252.c:3681:	       card->name, ((card->revision > 1) && (card->revision < 25)) ?
./atm/idt77252.c:3682:	       'A' + card->revision - 1 : '?', membase, srambase,
./atm/idt77252.c:3683:	       card->sramsize / 1024);
./atm/idt77252.c:3686:		printk("%s: init_card failed\n", card->name);
./atm/idt77252.c:3691:	dev->ci_range.vpi_bits = card->vpibits;
./atm/idt77252.c:3692:	dev->ci_range.vci_bits = card->vcibits;
./atm/idt77252.c:3693:	dev->link_rate = card->link_pcr;
./atm/idt77252.c:3699:		printk("%s: dev_open failed\n", card->name);
./atm/idt77252.c:3705:	last = &card->next;
./atm/idt77252.c:3718:	iounmap(card->membase);
./atm/idt77252.c:3769:		dev = card->atmdev;
./atm/idt77252.c:3770:		idt77252_chain = card->next;
./atm/idt77252.c:3775:		pci_disable_device(card->pcidev);
